(function (global, factory) {
  global.ES6Promise = factory();
})(window, function () {
  function objectOrFunction(x) {
    var type = typeof x;
    return x !== null && (type === "object" || type === "function");
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  var _isArray = void 0;
  if (Array.isArray) {
    _isArray = Array.isArray;
  } else {
    _isArray = function (x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
  }
  var isArray = _isArray;
  var len = 0;
  var vertxNext = void 0;
  var customSchedulerFn = void 0;
  var asap = function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      if (customSchedulerFn) {
        customSchedulerFn(flush);
      } else {
        scheduleFlush();
      }
    }
  };
  function setScheduler(scheduleFn) {
    customSchedulerFn = scheduleFn;
  }
  function setAsap(asapFn) {
    asap = asapFn;
  }
  var browserWindow = typeof window !== "undefined" ? window : undefined;
  var browserGlobal = browserWindow || ({});
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === "undefined" && typeof process !== "undefined" && ({}).toString.call(process) === "[object process]";
  var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
  function useNextTick() {
    return function () {
      return process.nextTick(flush);
    };
  }
  function useVertxTimer() {
    if (typeof vertxNext !== "undefined") {
      return function () {
        vertxNext(flush);
      };
    }
    return useSetTimeout();
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode("");
    observer.observe(node, {
      characterData: true
    });
    return function () {
      node.data = iterations = ++iterations % 2;
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function () {
      return channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    var globalSetTimeout = setTimeout;
    return function () {
      return globalSetTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  function attemptVertx() {
    try {
      var vertx = Function("return this")().require("vertx");
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }
  var scheduleFlush = void 0;
  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && typeof require === "function") {
    scheduleFlush = attemptVertx();
  } else {
    scheduleFlush = useSetTimeout();
  }
  function then(onFulfillment, onRejection) {
    var parent = this;
    var child = new this.constructor(noop);
    if (child[PROMISE_ID] === undefined) {
      makePromise(child);
    }
    var _state = parent._state;
    if (_state) {
      var callback = arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    } else {
      subscribe(parent, child, onFulfillment, onRejection);
    }
    return child;
  }
  function resolve$1(object) {
    var Constructor = this;
    if (object && typeof object === "object" && object.constructor === Constructor) {
      return object;
    }
    var promise = new Constructor(noop);
    resolve(promise, object);
    return promise;
  }
  var PROMISE_ID = Math.random().toString(36).substring(2);
  function noop() {}
  var PENDING = void 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var TRY_CATCH_ERROR = {
    error: null
  };
  function selfFulfillment() {
    return new TypeError("You cannot resolve a promise with itself");
  }
  function cannotReturnOwn() {
    return new TypeError("A promises callback cannot return that same promise.");
  }
  function getThen(promise) {
    try {
      return promise.then;
    } catch (error) {
      TRY_CATCH_ERROR.error = error;
      return TRY_CATCH_ERROR;
    }
  }
  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
    try {
      then$$1.call(value, fulfillmentHandler, rejectionHandler);
    } catch (e) {
      return e;
    }
  }
  function handleForeignThenable(promise, thenable, then$$1) {
    asap(function (promise) {
      var sealed = false;
      var error = tryThen(then$$1, thenable, function (value) {
        if (sealed) {
          return;
        }
        sealed = true;
        if (thenable !== value) {
          resolve(promise, value);
        } else {
          fulfill(promise, value);
        }
      }, function (reason) {
        if (sealed) {
          return;
        }
        sealed = true;
        reject(promise, reason);
      }, "Settle: " + (promise._label || " unknown promise"));
      if (!sealed && error) {
        sealed = true;
        reject(promise, error);
      }
    }, promise);
  }
  function handleOwnThenable(promise, thenable) {
    if (thenable._state === FULFILLED) {
      fulfill(promise, thenable._result);
    } else if (thenable._state === REJECTED) {
      reject(promise, thenable._result);
    } else {
      subscribe(thenable, undefined, function (value) {
        return resolve(promise, value);
      }, function (reason) {
        return reject(promise, reason);
      });
    }
  }
  function handleMaybeThenable(promise, maybeThenable, then$$1) {
    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
      handleOwnThenable(promise, maybeThenable);
    } else {
      if (then$$1 === TRY_CATCH_ERROR) {
        reject(promise, TRY_CATCH_ERROR.error);
        TRY_CATCH_ERROR.error = null;
      } else if (then$$1 === undefined) {
        fulfill(promise, maybeThenable);
      } else if (isFunction(then$$1)) {
        handleForeignThenable(promise, maybeThenable, then$$1);
      } else {
        fulfill(promise, maybeThenable);
      }
    }
  }
  function resolve(promise, value) {
    if (promise === value) {
      reject(promise, selfFulfillment());
    } else if (objectOrFunction(value)) {
      handleMaybeThenable(promise, value, getThen(value));
    } else {
      fulfill(promise, value);
    }
  }
  function publishRejection(promise) {
    if (promise._onerror) {
      promise._onerror(promise._result);
    }
    publish(promise);
  }
  function fulfill(promise, value) {
    if (promise._state !== PENDING) {
      return;
    }
    promise._result = value;
    promise._state = FULFILLED;
    if (promise._subscribers.length !== 0) {
      asap(publish, promise);
    }
  }
  function reject(promise, reason) {
    if (promise._state !== PENDING) {
      return;
    }
    promise._state = REJECTED;
    promise._result = reason;
    asap(publishRejection, promise);
  }
  function subscribe(parent, child, onFulfillment, onRejection) {
    var _subscribers = parent._subscribers;
    var length = _subscribers.length;
    parent._onerror = null;
    _subscribers[length] = child;
    _subscribers[length + FULFILLED] = onFulfillment;
    _subscribers[length + REJECTED] = onRejection;
    if (length === 0 && parent._state) {
      asap(publish, parent);
    }
  }
  function publish(promise) {
    var subscribers = promise._subscribers;
    var settled = promise._state;
    if (subscribers.length === 0) {
      return;
    }
    var child = void 0, callback = void 0, detail = promise._result;
    for (var i = 0; i < subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];
      if (child) {
        invokeCallback(settled, child, callback, detail);
      } else {
        callback(detail);
      }
    }
    promise._subscribers.length = 0;
  }
  function tryCatch(callback, detail) {
    try {
      return callback(detail);
    } catch (e) {
      TRY_CATCH_ERROR.error = e;
      return TRY_CATCH_ERROR;
    }
  }
  function invokeCallback(settled, promise, callback, detail) {
    var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = void 0, failed = void 0;
    if (hasCallback) {
      value = tryCatch(callback, detail);
      if (value === TRY_CATCH_ERROR) {
        failed = true;
        error = value.error;
        value.error = null;
      } else {
        succeeded = true;
      }
      if (promise === value) {
        reject(promise, cannotReturnOwn());
        return;
      }
    } else {
      value = detail;
      succeeded = true;
    }
    if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
  }
  function initializePromise(promise, resolver) {
    try {
      resolver(function resolvePromise(value) {
        resolve(promise, value);
      }, function rejectPromise(reason) {
        reject(promise, reason);
      });
    } catch (e) {
      reject(promise, e);
    }
  }
  var id = 0;
  function nextId() {
    return id++;
  }
  function makePromise(promise) {
    promise[PROMISE_ID] = id++;
    promise._state = undefined;
    promise._result = undefined;
    promise._subscribers = [];
  }
  function validationError() {
    return new Error("Array Methods must be provided an Array");
  }
  var Enumerator = (function () {
    function Enumerator(Constructor, input) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(noop);
      if (!this.promise[PROMISE_ID]) {
        makePromise(this.promise);
      }
      if (isArray(input)) {
        this.length = input.length;
        this._remaining = input.length;
        this._result = new Array(this.length);
        if (this.length === 0) {
          fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate(input);
          if (this._remaining === 0) {
            fulfill(this.promise, this._result);
          }
        }
      } else {
        reject(this.promise, validationError());
      }
    }
    Enumerator.prototype._enumerate = function _enumerate(input) {
      for (var i = 0; this._state === PENDING && i < input.length; i++) {
        this._eachEntry(input[i], i);
      }
    };
    Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
      var c = this._instanceConstructor;
      var resolve$$1 = c.resolve;
      if (resolve$$1 === resolve$1) {
        var _then = getThen(entry);
        if (_then === then && entry._state !== PENDING) {
          this._settledAt(entry._state, i, entry._result);
        } else if (typeof _then !== "function") {
          this._remaining--;
          this._result[i] = entry;
        } else if (c === Promise$2) {
          var promise = new c(noop);
          handleMaybeThenable(promise, entry, _then);
          this._willSettleAt(promise, i);
        } else {
          this._willSettleAt(new c(function (resolve$$1) {
            return resolve$$1(entry);
          }), i);
        }
      } else {
        this._willSettleAt(c.resolve(entry), i);
      }
    };
    Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
      var promise = this.promise;
      if (promise._state === PENDING) {
        this._remaining--;
        if (state === REJECTED) {
          reject(promise, value);
        } else {
          this._result[i] = value;
        }
      }
      if (this._remaining === 0) {
        fulfill(promise, this._result);
      }
    };
    Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
      var enumerator = this;
      subscribe(promise, undefined, function (value) {
        return enumerator._settledAt(FULFILLED, i, value);
      }, function (reason) {
        return enumerator._settledAt(REJECTED, i, reason);
      });
    };
    return Enumerator;
  })();
  function all(entries) {
    return new Enumerator(this, entries).promise;
  }
  function race(entries) {
    var Constructor = this;
    if (!isArray(entries)) {
      return new Constructor(function (_, reject) {
        return reject(new TypeError("You must pass an array to race."));
      });
    } else {
      return new Constructor(function (resolve, reject) {
        var length = entries.length;
        for (var i = 0; i < length; i++) {
          Constructor.resolve(entries[i]).then(resolve, reject);
        }
      });
    }
  }
  function reject$1(reason) {
    var Constructor = this;
    var promise = new Constructor(noop);
    reject(promise, reason);
    return promise;
  }
  function needsResolver() {
    throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
  }
  function needsNew() {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  var Promise$2 = (function () {
    function Promise(resolver) {
      this[PROMISE_ID] = nextId();
      this._result = this._state = undefined;
      this._subscribers = [];
      if (noop !== resolver) {
        typeof resolver !== "function" && needsResolver();
        this instanceof Promise ? initializePromise(this, resolver) : needsNew();
      }
    }
    Promise.prototype.catch = function _catch(onRejection) {
      return this.then(null, onRejection);
    };
    Promise.prototype.finally = function _finally(callback) {
      var promise = this;
      var constructor = promise.constructor;
      if (isFunction(callback)) {
        return promise.then(function (value) {
          return constructor.resolve(callback()).then(function () {
            return value;
          });
        }, function (reason) {
          return constructor.resolve(callback()).then(function () {
            throw reason;
          });
        });
      }
      return promise.then(callback, callback);
    };
    return Promise;
  })();
  Promise$2.prototype.then = then;
  Promise$2.all = all;
  Promise$2.race = race;
  Promise$2.resolve = resolve$1;
  Promise$2.reject = reject$1;
  Promise$2._setScheduler = setScheduler;
  Promise$2._setAsap = setAsap;
  Promise$2._asap = asap;
  function polyfill() {
    var local = void 0;
    if (typeof global !== "undefined") {
      local = global;
    } else if (typeof self !== "undefined") {
      local = self;
    } else {
      try {
        local = Function("return this")();
      } catch (e) {
        throw new Error("polyfill failed because global object is unavailable in this environment");
      }
    }
    var P = local.Promise;
    if (P) {
      var promiseToString = null;
      try {
        promiseToString = Object.prototype.toString.call(P.resolve());
      } catch (e) {}
      if (promiseToString === "[object Promise]" && !P.cast) {
        if (typeof P.prototype.finally !== "function") {
          P.prototype.finally = Promise$2.prototype.finally;
        }
        return;
      }
    }
    local.Promise = Promise$2;
  }
  Promise$2.polyfill = polyfill;
  Promise$2.Promise = Promise$2;
  Promise$2.polyfill();
  return Promise$2;
});

(function () {
  if (!String.prototype.padStart) {
    String.prototype.padStart = function padStart(targetLength, padString) {
      targetLength = targetLength >> 0;
      padString = String(typeof padString !== "undefined" ? padString : " ");
      if (this.length >= targetLength) {
        return String(this);
      } else {
        targetLength = targetLength - this.length;
        if (targetLength > padString.length) {
          padString += padString.repeat(targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + String(this);
      }
    };
  }
  if (!Object.entries) {
    Object.entries = function (obj) {
      var ownProps = Object.keys(obj), i = ownProps.length, resArray = new Array(i);
      while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];
      return resArray;
    };
  }
  if (!window.WeakSet) {
    var counter = Date.now() % 1000000000;
    function WeakSet(data) {
      this.name = "__st" + (Math.random() * 1000000000 >>> 0) + (counter++ + "__");
      data && data.forEach && data.forEach(this.add, this);
    }
    var proto = WeakSet.prototype;
    proto["add"] = function (val) {
      var name = this.name;
      if (!val[name]) Object.defineProperty(val, name, {
        value: true,
        writable: true
      });
      return this;
    };
    proto["delete"] = function (val) {
      if (!val[this.name]) return false;
      val[this.name] = undefined;
      return true;
    };
    proto["has"] = function (val) {
      return !!val[this.name];
    };
    window.WeakSet = WeakSet;
  }
  (function () {
    var workingDefaultPrevented = (function () {
      var e = document.createEvent("Event");
      e.initEvent("foo", true, true);
      e.preventDefault();
      return e.defaultPrevented;
    })();
    if (!workingDefaultPrevented) {
      var origPreventDefault = Event.prototype.preventDefault;
      Event.prototype.preventDefault = function () {
        if (!this.cancelable) {
          return;
        }
        origPreventDefault.call(this);
        Object.defineProperty(this, "defaultPrevented", {
          get: function () {
            return true;
          },
          configurable: true
        });
      };
    }
    var isIE = (/Trident/).test(navigator.userAgent);
    if (!window.Event || isIE && typeof window.Event !== "function") {
      var origEvent = window.Event;
      window.Event = function (inType, params) {
        params = params || ({});
        var e = document.createEvent("Event");
        e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
        return e;
      };
      if (origEvent) {
        for (var i in origEvent) {
          window.Event[i] = origEvent[i];
        }
        window.Event.prototype = origEvent.prototype;
      }
    }
    if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
      window.CustomEvent = function (inType, params) {
        params = params || ({});
        var e = document.createEvent("CustomEvent");
        e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
        return e;
      };
      window.CustomEvent.prototype = window.Event.prototype;
    }
    if (!window.MouseEvent || isIE && typeof window.MouseEvent !== "function") {
      var origMouseEvent = window.MouseEvent;
      window.MouseEvent = function (inType, params) {
        params = params || ({});
        var e = document.createEvent("MouseEvent");
        e.initMouseEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.view || window, params.detail, params.screenX, params.screenY, params.clientX, params.clientY, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.button, params.relatedTarget);
        return e;
      };
      if (origMouseEvent) {
        for (var i in origMouseEvent) {
          window.MouseEvent[i] = origMouseEvent[i];
        }
      }
      window.MouseEvent.prototype = origMouseEvent.prototype;
    }
    if (!Array.from) {
      Array.from = function (object) {
        return [].slice.call(object);
      };
    }
    if (!Object.assign) {
      var assign = function (target, source) {
        var n$ = Object.getOwnPropertyNames(source);
        for (var i = 0, p; i < n$.length; i++) {
          p = n$[i];
          target[p] = source[p];
        }
      };
      Object.assign = function (target, sources) {
        var args = [].slice.call(arguments, 1);
        for (var i = 0, s; i < args.length; i++) {
          s = args[i];
          if (s) {
            assign(target, s);
          }
        }
        return target;
      };
    }
  })();
  window.fetch || (window.fetch = function (e, n) {
    return (n = n || ({}), new Promise(function (t, r) {
      var s = new XMLHttpRequest();
      for (var o in (s.open(n.method || "get", e, !0), n.headers)) s.setRequestHeader(o, n.headers[o]);
      function u() {
        var e, n = [], t = [], r = {};
        return (s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function (s, o, u) {
          (n.push(o = o.toLowerCase()), t.push([o, u]), r[o] = (e = r[o]) ? e + "," + u : u);
        }), {
          ok: 2 == (s.status / 100 | 0),
          status: s.status,
          statusText: s.statusText,
          url: s.responseURL,
          clone: u,
          text: function () {
            return Promise.resolve(s.responseText);
          },
          json: function () {
            return Promise.resolve(s.responseText).then(JSON.parse);
          },
          blob: function () {
            return Promise.resolve(new Blob([s.response]));
          },
          headers: {
            keys: function () {
              return n;
            },
            entries: function () {
              return t;
            },
            get: function (e) {
              return r[e.toLowerCase()];
            },
            has: function (e) {
              return (e.toLowerCase() in r);
            }
          }
        });
      }
      (s.withCredentials = "include" == n.credentials, s.onload = function () {
        t(u());
      }, s.onerror = r, s.send(n.body || null));
    }));
  });
  (function () {
    var needsTemplate = typeof HTMLTemplateElement === "undefined";
    var brokenDocFragment = !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment);
    var needsDocFrag = false;
    if ((/Trident/).test(navigator.userAgent)) {
      (function () {
        needsDocFrag = true;
        var origCloneNode = Node.prototype.cloneNode;
        Node.prototype.cloneNode = function cloneNode(deep) {
          var newDom = origCloneNode.call(this, deep);
          if (this instanceof DocumentFragment) {
            newDom.__proto__ = DocumentFragment.prototype;
          }
          return newDom;
        };
        DocumentFragment.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll;
        DocumentFragment.prototype.querySelector = HTMLElement.prototype.querySelector;
        Object.defineProperties(DocumentFragment.prototype, {
          "nodeType": {
            get: function () {
              return Node.DOCUMENT_FRAGMENT_NODE;
            },
            configurable: true
          },
          "localName": {
            get: function () {
              return undefined;
            },
            configurable: true
          },
          "nodeName": {
            get: function () {
              return "#document-fragment";
            },
            configurable: true
          }
        });
        var origInsertBefore = Node.prototype.insertBefore;
        function insertBefore(newNode, refNode) {
          if (newNode instanceof DocumentFragment) {
            var child;
            while (child = newNode.firstChild) {
              origInsertBefore.call(this, child, refNode);
            }
          } else {
            origInsertBefore.call(this, newNode, refNode);
          }
          return newNode;
        }
        Node.prototype.insertBefore = insertBefore;
        var origAppendChild = Node.prototype.appendChild;
        Node.prototype.appendChild = function appendChild(child) {
          if (child instanceof DocumentFragment) {
            insertBefore.call(this, child, null);
          } else {
            origAppendChild.call(this, child);
          }
          return child;
        };
        var origRemoveChild = Node.prototype.removeChild;
        var origReplaceChild = Node.prototype.replaceChild;
        Node.prototype.replaceChild = function replaceChild(newChild, oldChild) {
          if (newChild instanceof DocumentFragment) {
            insertBefore.call(this, newChild, oldChild);
            origRemoveChild.call(this, oldChild);
          } else {
            origReplaceChild.call(this, newChild, oldChild);
          }
          return oldChild;
        };
        Document.prototype.createDocumentFragment = function createDocumentFragment() {
          var frag = this.createElement("df");
          frag.__proto__ = DocumentFragment.prototype;
          return frag;
        };
        var origImportNode = Document.prototype.importNode;
        Document.prototype.importNode = function importNode(impNode, deep) {
          deep = deep || false;
          var newNode = origImportNode.call(this, impNode, deep);
          if (impNode instanceof DocumentFragment) {
            newNode.__proto__ = DocumentFragment.prototype;
          }
          return newNode;
        };
      })();
    }
    var capturedCloneNode = Node.prototype.cloneNode;
    var capturedCreateElement = Document.prototype.createElement;
    var capturedImportNode = Document.prototype.importNode;
    var capturedRemoveChild = Node.prototype.removeChild;
    var capturedAppendChild = Node.prototype.appendChild;
    var capturedReplaceChild = Node.prototype.replaceChild;
    var capturedParseFromString = DOMParser.prototype.parseFromString;
    var capturedHTMLElementInnerHTML = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML") || ({
      get: function () {
        return this.innerHTML;
      },
      set: function (text) {
        this.innerHTML = text;
      }
    });
    var capturedChildNodes = Object.getOwnPropertyDescriptor(window.Node.prototype, "childNodes") || ({
      get: function () {
        return this.childNodes;
      }
    });
    var elementQuerySelectorAll = Element.prototype.querySelectorAll;
    var docQuerySelectorAll = Document.prototype.querySelectorAll;
    var fragQuerySelectorAll = DocumentFragment.prototype.querySelectorAll;
    var scriptSelector = "script:not([type]),script[type=\"application/javascript\"],script[type=\"text/javascript\"]";
    function QSA(node, selector) {
      if (!node.childNodes.length) {
        return [];
      }
      switch (node.nodeType) {
        case Node.DOCUMENT_NODE:
          return docQuerySelectorAll.call(node, selector);
        case Node.DOCUMENT_FRAGMENT_NODE:
          return fragQuerySelectorAll.call(node, selector);
        default:
          return elementQuerySelectorAll.call(node, selector);
      }
    }
    var needsCloning = (function () {
      if (!needsTemplate) {
        var t = document.createElement("template");
        var t2 = document.createElement("template");
        t2.content.appendChild(document.createElement("div"));
        t.content.appendChild(t2);
        var clone = t.cloneNode(true);
        return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0 || brokenDocFragment;
      }
    })();
    var TEMPLATE_TAG = "template";
    var PolyfilledHTMLTemplateElement = function () {};
    if (needsTemplate) {
      var contentDoc = document.implementation.createHTMLDocument("template");
      var canDecorate = true;
      var templateStyle = document.createElement("style");
      templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";
      var head = document.head;
      head.insertBefore(templateStyle, head.firstElementChild);
      PolyfilledHTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
      var canProtoPatch = !document.createElement("div").hasOwnProperty("innerHTML");
      PolyfilledHTMLTemplateElement.decorate = function (template) {
        if (template.content || template.namespaceURI !== document.documentElement.namespaceURI) {
          return;
        }
        template.content = contentDoc.createDocumentFragment();
        var child;
        while (child = template.firstChild) {
          capturedAppendChild.call(template.content, child);
        }
        if (canProtoPatch) {
          template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
        } else {
          template.cloneNode = function (deep) {
            return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
          };
          if (canDecorate) {
            try {
              defineInnerHTML(template);
              defineOuterHTML(template);
            } catch (err) {
              canDecorate = false;
            }
          }
        }
        PolyfilledHTMLTemplateElement.bootstrap(template.content);
      };
      var topLevelWrappingMap = {
        "option": ["select"],
        "thead": ["table"],
        "col": ["colgroup", "table"],
        "tr": ["tbody", "table"],
        "th": ["tr", "tbody", "table"],
        "td": ["tr", "tbody", "table"]
      };
      var getTagName = function (text) {
        return ((/<([a-z][^/\0>\x20\t\r\n\f]+)/i).exec(text) || ["", ""])[1].toLowerCase();
      };
      var defineInnerHTML = function defineInnerHTML(obj) {
        Object.defineProperty(obj, "innerHTML", {
          get: function () {
            return getInnerHTML(this);
          },
          set: function (text) {
            var wrap = topLevelWrappingMap[getTagName(text)];
            if (wrap) {
              for (var i = 0; i < wrap.length; i++) {
                text = "<" + wrap[i] + ">" + text + "</" + wrap[i] + ">";
              }
            }
            contentDoc.body.innerHTML = text;
            PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
            while (this.content.firstChild) {
              capturedRemoveChild.call(this.content, this.content.firstChild);
            }
            var body = contentDoc.body;
            if (wrap) {
              for (var j = 0; j < wrap.length; j++) {
                body = body.lastChild;
              }
            }
            while (body.firstChild) {
              capturedAppendChild.call(this.content, body.firstChild);
            }
          },
          configurable: true
        });
      };
      var defineOuterHTML = function defineOuterHTML(obj) {
        Object.defineProperty(obj, "outerHTML", {
          get: function () {
            return "<" + TEMPLATE_TAG + ">" + this.innerHTML + "</" + TEMPLATE_TAG + ">";
          },
          set: function (innerHTML) {
            if (this.parentNode) {
              contentDoc.body.innerHTML = innerHTML;
              var docFrag = this.ownerDocument.createDocumentFragment();
              while (contentDoc.body.firstChild) {
                capturedAppendChild.call(docFrag, contentDoc.body.firstChild);
              }
              capturedReplaceChild.call(this.parentNode, docFrag, this);
            } else {
              throw new Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");
            }
          },
          configurable: true
        });
      };
      defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);
      defineOuterHTML(PolyfilledHTMLTemplateElement.prototype);
      PolyfilledHTMLTemplateElement.bootstrap = function bootstrap(doc) {
        var templates = QSA(doc, TEMPLATE_TAG);
        for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {
          PolyfilledHTMLTemplateElement.decorate(t);
        }
      };
      document.addEventListener("DOMContentLoaded", function () {
        PolyfilledHTMLTemplateElement.bootstrap(document);
      });
      Document.prototype.createElement = function createElement() {
        var el = capturedCreateElement.apply(this, arguments);
        if (el.localName === "template") {
          PolyfilledHTMLTemplateElement.decorate(el);
        }
        return el;
      };
      DOMParser.prototype.parseFromString = function () {
        var el = capturedParseFromString.apply(this, arguments);
        PolyfilledHTMLTemplateElement.bootstrap(el);
        return el;
      };
      Object.defineProperty(HTMLElement.prototype, "innerHTML", {
        get: function () {
          return getInnerHTML(this);
        },
        set: function (text) {
          capturedHTMLElementInnerHTML.set.call(this, text);
          PolyfilledHTMLTemplateElement.bootstrap(this);
        },
        configurable: true,
        enumerable: true
      });
      var escapeAttrRegExp = /[&\u00A0"]/g;
      var escapeDataRegExp = /[&\u00A0<>]/g;
      var escapeReplace = function (c) {
        switch (c) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case "\"":
            return "&quot;";
          case " ":
            return "&nbsp;";
        }
      };
      var escapeAttr = function (s) {
        return s.replace(escapeAttrRegExp, escapeReplace);
      };
      var escapeData = function (s) {
        return s.replace(escapeDataRegExp, escapeReplace);
      };
      var makeSet = function (arr) {
        var set = {};
        for (var i = 0; i < arr.length; i++) {
          set[arr[i]] = true;
        }
        return set;
      };
      var voidElements = makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
      var plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
      var getOuterHTML = function (node, parentNode, callback) {
        switch (node.nodeType) {
          case Node.ELEMENT_NODE:
            {
              var tagName = node.localName;
              var s = "<" + tagName;
              var attrs = node.attributes;
              for (var i = 0, attr; attr = attrs[i]; i++) {
                s += " " + attr.name + "=\"" + escapeAttr(attr.value) + "\"";
              }
              s += ">";
              if (voidElements[tagName]) {
                return s;
              }
              return s + getInnerHTML(node, callback) + "</" + tagName + ">";
            }
          case Node.TEXT_NODE:
            {
              var data = node.data;
              if (parentNode && plaintextParents[parentNode.localName]) {
                return data;
              }
              return escapeData(data);
            }
          case Node.COMMENT_NODE:
            {
              return "<!--" + node.data + "-->";
            }
          default:
            {
              window.console.error(node);
              throw new Error("not implemented");
            }
        }
      };
      var getInnerHTML = function (node, callback) {
        if (node.localName === "template") {
          node = node.content;
        }
        var s = "";
        var c$ = callback ? callback(node) : capturedChildNodes.get.call(node);
        for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
          s += getOuterHTML(child, node, callback);
        }
        return s;
      };
    }
    if (needsTemplate || needsCloning) {
      PolyfilledHTMLTemplateElement._cloneNode = function _cloneNode(template, deep) {
        var clone = capturedCloneNode.call(template, false);
        if (this.decorate) {
          this.decorate(clone);
        }
        if (deep) {
          capturedAppendChild.call(clone.content, capturedCloneNode.call(template.content, true));
          fixClonedDom(clone.content, template.content);
        }
        return clone;
      };
      var fixClonedDom = function fixClonedDom(clone, source) {
        if (!source.querySelectorAll) return;
        var s$ = QSA(source, TEMPLATE_TAG);
        if (s$.length === 0) {
          return;
        }
        var t$ = QSA(clone, TEMPLATE_TAG);
        for (var i = 0, l = t$.length, t, s; i < l; i++) {
          s = s$[i];
          t = t$[i];
          if (PolyfilledHTMLTemplateElement && PolyfilledHTMLTemplateElement.decorate) {
            PolyfilledHTMLTemplateElement.decorate(s);
          }
          capturedReplaceChild.call(t.parentNode, cloneNode.call(s, true), t);
        }
      };
      var fixClonedScripts = function fixClonedScripts(fragment) {
        var scripts = QSA(fragment, scriptSelector);
        for (var ns, s, i = 0; i < scripts.length; i++) {
          s = scripts[i];
          ns = capturedCreateElement.call(document, "script");
          ns.textContent = s.textContent;
          var attrs = s.attributes;
          for (var ai = 0, a; ai < attrs.length; ai++) {
            a = attrs[ai];
            ns.setAttribute(a.name, a.value);
          }
          capturedReplaceChild.call(s.parentNode, ns, s);
        }
      };
      var cloneNode = Node.prototype.cloneNode = function cloneNode(deep) {
        var dom;
        if (!needsDocFrag && brokenDocFragment && this instanceof DocumentFragment) {
          if (!deep) {
            return this.ownerDocument.createDocumentFragment();
          } else {
            dom = importNode.call(this.ownerDocument, this, true);
          }
        } else if (this.nodeType === Node.ELEMENT_NODE && this.localName === TEMPLATE_TAG && this.namespaceURI == document.documentElement.namespaceURI) {
          dom = PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        } else {
          dom = capturedCloneNode.call(this, deep);
        }
        if (deep) {
          fixClonedDom(dom, this);
        }
        return dom;
      };
      var importNode = Document.prototype.importNode = function importNode(element, deep) {
        deep = deep || false;
        if (element.localName === TEMPLATE_TAG) {
          return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
        } else {
          var dom = capturedImportNode.call(this, element, deep);
          if (deep) {
            fixClonedDom(dom, element);
            fixClonedScripts(dom);
          }
          return dom;
        }
      };
    }
    if (needsTemplate) {
      window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
    }
  })();
  if (Element && !Element.prototype.matches) {
    var proto = Element.prototype;
    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
  }
  if (!Element.prototype.closest) {
    Element.prototype.closest = function (s) {
      var el = this;
      if (!document.documentElement.contains(el)) return null;
      do {
        if (el.matches(s)) return el;
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === 1);
      return null;
    };
  }
  (function (global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = factory(global);
    } else {
      factory(global);
    }
  })(typeof window !== "undefined" ? window : global, function (global) {
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var symbolHiddenCounter = 0;
    var globalSymbolRegistry = [];
    var slice = Array.prototype.slice;
    var ES6 = typeof global.ES6 === "object" ? global.ES6 : global.ES6 = {};
    var isArray = Array.isArray;
    var objectToString = Object.prototype.toString;
    var push = Array.prototype.push;
    var emptyFunction = function () {};
    var simpleFunction = function (arg) {
      return arg;
    };
    var isCallable = function (fn) {
      return typeof fn === "function";
    };
    var isConstructor = function (fn) {
      return isCallable(fn);
    };
    var Iterator = function () {};
    var ArrayIterator = function ArrayIterator(array, flag) {
      this._array = array;
      this._flag = flag;
      this._nextIndex = 0;
    };
    var StringIterator = function StringIterator(string, flag) {
      this._string = string;
      this._flag = flag;
      this._nextIndex = 0;
    };
    var isObject = function (value) {
      return value !== null && (typeof value === "object" || typeof value === "function");
    };
    var es6FunctionPrototypeHasInstanceSymbol = function (instance) {
      if (typeof this !== "function") return false;
      return instance instanceof this;
    };
    var es6InstanceOfOperator = function (object, constructor) {
      if (!isObject(constructor)) throw new TypeError("Right-hand side of 'instanceof' is not an object");
      var hasInstanceSymbolProp = constructor[Symbol.hasInstance];
      if (typeof hasInstanceSymbolProp === "undefined") {
        return object instanceof constructor;
      } else if (typeof hasInstanceSymbolProp !== "function") {
        throw new TypeError(typeof hasInstanceSymbolProp + " is not a function");
      } else {
        return hasInstanceSymbolProp.call(constructor, object);
      }
    };
    var generateSymbolName = function (id) {
      return "@@_____" + id + "_____";
    };
    var getNextSymbolId = function () {
      return symbolHiddenCounter++;
    };
    var setupSymbolInternals = function (symbol, desc) {
      defineProperties(symbol, {
        _description: {
          value: desc
        },
        _isSymbol: {
          value: true
        },
        _id: {
          value: getNextSymbolId()
        }
      });
      return symbol;
    };
    var checkSymbolInternals = function (symbol) {
      return symbol._isSymbol === true && typeof symbol._id === "number" && typeof symbol._description === "string";
    };
    var isSymbol = function (symbol) {
      return symbol instanceof Symbol && checkSymbolInternals(symbol);
    };
    var symbolFor = function (key) {
      key = String(key);
      var registryLength = globalSymbolRegistry.length, record, i = 0;
      for (; i < registryLength; ++i) {
        record = globalSymbolRegistry[i];
        if (record.key === key) return record.symbol;
      }
      record = {
        key: key,
        symbol: Symbol(key)
      };
      globalSymbolRegistry.push(record);
      return record.symbol;
    };
    var symbolKeyFor = function (symbol) {
      if (!ES6.isSymbol(symbol)) throw new TypeError(String(symbol) + " is not a symbol");
      var registryLength = globalSymbolRegistry.length, record, i = 0;
      for (; i < registryLength; ++i) {
        record = globalSymbolRegistry[i];
        if (record.symbol === symbol) return record.key;
      }
    };
    var appendArray = function (array1, array2) {
      if (!(typeof array1.length === "number" && array1.length >= 0 && typeof array2.length === "number" && array2.length >= 0)) return;
      var length1 = Math.floor(array1.length), length2 = Math.floor(array2.length), i = 0;
      array1.length = length1 + length2;
      for (; i < length2; ++i) if (array2.hasOwnProperty(i)) array1[length1 + i] = array2[i];
    };
    var es6ObjectPrototypeToString = function toString() {
      if (this === undefined || this === null) return objectToString.call(this);
      if (typeof this[Symbol.toStringTag] === "string") return "[object " + this[Symbol.toStringTag] + "]"; else return objectToString.call(this);
    };
    var es6ArrayPrototypeConcat = function concat() {
      if (this === undefined || this === null) throw new TypeError("Array.prototype.concat called on null or undefined");
      var self = Object(this), targets = slice.call(arguments), outputs = [];
      targets.unshift(self);
      targets.forEach(function (target) {
        if (!isObject(target)) outputs.push(target); else if (typeof target[Symbol.isConcatSpreadable] !== "undefined") {
          if (target[Symbol.isConcatSpreadable]) {
            appendArray(outputs, target);
          } else {
            outputs.push(target);
          }
        } else if (isArray(target)) {
          appendArray(outputs, target);
        } else {
          outputs.push(target);
        }
      });
      return outputs;
    };
    var es6ForOfLoop = function (iterable, callback, thisArg) {
      callback = typeof callback !== "function" ? emptyFunction : callback;
      if (typeof iterable[Symbol.iterator] !== "function") throw new TypeError("Iterable[Symbol.iterator] is not a function");
      var iterator = iterable[Symbol.iterator](), iterationResult;
      if (typeof iterator.next !== "function") throw new TypeError(".iterator.next is not a function");
      while (true) {
        iterationResult = iterator.next();
        if (!isObject(iterationResult)) throw new TypeError("Iterator result " + iterationResult + " is not an object");
        if (iterationResult.done) break;
        callback.call(thisArg, iterationResult.value);
      }
    };
    var simpleInheritance = function (child, parent) {
      if (typeof child !== "function" || typeof parent !== "function") throw new TypeError("Child and Parent must be function type");
      child.prototype = Object.create(parent.prototype);
      child.prototype.constructor = child;
    };
    var Symbol = function Symbol(desc) {
      desc = typeof desc === "undefined" ? "" : String(desc);
      if (this instanceof Symbol) throw new TypeError("Symbol is not a constructor");
      return setupSymbolInternals(Object.create(Symbol.prototype), desc);
    };
    defineProperties(Symbol, {
      "for": {
        value: symbolFor,
        writable: true,
        configurable: true
      },
      "keyFor": {
        value: symbolKeyFor,
        writable: true,
        configurable: true
      },
      "hasInstance": {
        value: Symbol("Symbol.hasInstance")
      },
      "isConcatSpreadable": {
        value: Symbol("Symbol.isConcatSpreadable")
      },
      "iterator": {
        value: Symbol("Symbol.iterator")
      },
      "toStringTag": {
        value: Symbol("Symbol.toStringTag")
      }
    });
    Symbol.prototype.toString = function () {
      return generateSymbolName(this._id);
    };
    Symbol.prototype.valueOf = function () {
      return this;
    };
    defineProperty(Iterator.prototype, Symbol.iterator.toString(), {
      value: function () {
        return this;
      },
      writable: true,
      configurable: true
    });
    simpleInheritance(ArrayIterator, Iterator);
    simpleInheritance(StringIterator, Iterator);
    defineProperty(ArrayIterator.prototype, Symbol.toStringTag.toString(), {
      value: "Array Iterator",
      configurable: true
    });
    defineProperty(StringIterator.prototype, Symbol.toStringTag.toString(), {
      value: "String Iterator",
      configurable: true
    });
    ArrayIterator.prototype.next = function next() {
      if (!(this instanceof ArrayIterator)) throw new TypeError("Method Array Iterator.prototype.next called on incompatible receiver " + String(this));
      var self = this, nextValue;
      if (self._nextIndex === -1) {
        return {
          done: true,
          value: undefined
        };
      }
      if (!(typeof self._array.length === "number" && self._array.length >= 0)) {
        self._nextIndex = -1;
        return {
          done: true,
          value: undefined
        };
      }
      if (self._nextIndex < Math.floor(self._array.length)) {
        if (self._flag === 1) nextValue = [self._nextIndex, self._array[self._nextIndex]]; else if (self._flag === 2) nextValue = self._array[self._nextIndex]; else if (self._flag === 3) nextValue = self._nextIndex;
        self._nextIndex++;
        return {
          done: false,
          value: nextValue
        };
      } else {
        self._nextIndex = -1;
        return {
          done: true,
          value: undefined
        };
      }
    };
    StringIterator.prototype.next = function next() {
      if (!(this instanceof StringIterator)) throw new TypeError("Method String Iterator.prototype.next called on incompatible receiver " + String(this));
      var self = this, stringObject = new String(this._string), nextValue;
      if (self._nextIndex === -1) {
        return {
          done: true,
          value: undefined
        };
      }
      if (self._nextIndex < stringObject.length) {
        nextValue = stringObject[self._nextIndex];
        self._nextIndex++;
        return {
          done: false,
          value: nextValue
        };
      } else {
        self._nextIndex = -1;
        return {
          done: true,
          value: undefined
        };
      }
    };
    var es6ArrayPrototypeIteratorSymbol = function values() {
      if (this === undefined || this === null) throw new TypeError("Cannot convert undefined or null to object");
      var self = Object(this);
      return new ArrayIterator(self, 2);
    };
    var es6StringPrototypeIteratorSymbol = function values() {
      if (this === undefined || this === null) throw new TypeError("String.prototype[Symbol.iterator] called on null or undefined");
      return new StringIterator(String(this), 0);
    };
    var es6ArrayPrototypeEntries = function entries() {
      if (this === undefined || this === null) throw new TypeError("Cannot convert undefined or null to object");
      var self = Object(this);
      return new ArrayIterator(self, 1);
    };
    var es6ArrayPrototypeKeys = function keys() {
      if (this === undefined || this === null) throw new TypeError("Cannot convert undefined or null to object");
      var self = Object(this);
      return new ArrayIterator(self, 3);
    };
    var SpreadOperatorImpl = function (target, thisArg) {
      this._target = target;
      this._values = [];
      this._thisArg = thisArg;
    };
    SpreadOperatorImpl.prototype.spread = function () {
      var self = this;
      slice.call(arguments).forEach(function (iterable) {
        ES6.forOf(iterable, function (value) {
          self._values.push(value);
        });
      });
      return self;
    };
    SpreadOperatorImpl.prototype.add = function () {
      var self = this;
      slice.call(arguments).forEach(function (value) {
        self._values.push(value);
      });
      return self;
    };
    SpreadOperatorImpl.prototype.call = function (thisArg) {
      if (typeof this._target !== "function") throw new TypeError("Target is not a function");
      thisArg = arguments.length <= 0 ? this._thisArg : thisArg;
      return this._target.apply(thisArg, this._values);
    };
    SpreadOperatorImpl.prototype.new = function () {
      if (typeof this._target !== "function") throw new TypeError("Target is not a constructor");
      var temp, returnValue;
      temp = Object.create(this._target.prototype);
      returnValue = this._target.apply(temp, this._values);
      return isObject(returnValue) ? returnValue : temp;
    };
    SpreadOperatorImpl.prototype.array = function () {
      if (!isArray(this._target)) throw new TypeError("Target is not a array");
      push.apply(this._target, this._values);
      return this._target;
    };
    var es6SpreadOperator = function spreadOperator(target, thisArg) {
      if (!(typeof target === "function" || isArray(target))) throw new TypeError("Spread operator only supports on array and function objects at this moment");
      return new SpreadOperatorImpl(target, thisArg);
    };
    var es6ArrayFrom = function from(arrayLike, mapFn, thisArg) {
      var constructor, i = 0, length, outputs;
      constructor = !isConstructor(this) ? Array : this;
      if (arrayLike === undefined || arrayLike === null) throw new TypeError("Cannot convert undefined or null to object");
      arrayLike = Object(arrayLike);
      if (mapFn === undefined) mapFn = simpleFunction; else if (!isCallable(mapFn)) throw new TypeError(mapFn + " is not a function");
      if (typeof arrayLike[Symbol.iterator] === "undefined") {
        if (!(typeof arrayLike.length === "number" && arrayLike.length >= 0)) {
          outputs = new constructor(0);
          outputs.length = 0;
          return outputs;
        }
        length = Math.floor(arrayLike.length);
        outputs = new constructor(length);
        outputs.length = length;
        for (; i < length; ++i) outputs[i] = mapFn.call(thisArg, arrayLike[i]);
      } else {
        outputs = new constructor();
        outputs.length = 0;
        ES6.forOf(arrayLike, function (value) {
          outputs.length++;
          outputs[outputs.length - 1] = mapFn.call(thisArg, value);
        });
      }
      return outputs;
    };
    {
      defineProperties(ES6, {
        isSymbol: {
          value: isSymbol,
          writable: true,
          configurable: true
        },
        instanceOf: {
          value: es6InstanceOfOperator,
          writable: true,
          configurable: true
        },
        forOf: {
          value: es6ForOfLoop,
          writable: true,
          configurable: true
        },
        spreadOperator: {
          value: es6SpreadOperator,
          writable: true,
          configurable: true
        }
      });
      defineProperty(global, "Symbol", {
        value: Symbol,
        writable: true,
        configurable: true
      });
      defineProperty(Function.prototype, Symbol.hasInstance.toString(), {
        value: es6FunctionPrototypeHasInstanceSymbol
      });
      defineProperty(Array.prototype, "concat", {
        value: es6ArrayPrototypeConcat,
        writable: true,
        configurable: true
      });
      defineProperty(Object.prototype, "toString", {
        value: es6ObjectPrototypeToString,
        writable: true,
        configurable: true
      });
      defineProperty(Array.prototype, Symbol.iterator.toString(), {
        value: es6ArrayPrototypeIteratorSymbol,
        writable: true,
        configurable: true
      });
      defineProperty(Array, "from", {
        value: es6ArrayFrom,
        writable: true,
        configurable: true
      });
      defineProperty(Array.prototype, "entries", {
        value: es6ArrayPrototypeEntries,
        writable: true,
        configurable: true
      });
      defineProperty(Array.prototype, "keys", {
        value: es6ArrayPrototypeKeys,
        writable: true,
        configurable: true
      });
      defineProperty(String.prototype, Symbol.iterator.toString(), {
        value: es6StringPrototypeIteratorSymbol,
        writable: true,
        configurable: true
      });
    }
    return ES6;
  });
  Number.isInteger = Number.isInteger || (function (value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  });
  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, "includes", {
      value: function (searchElement, fromIndex) {
        if (this == null) {
          throw new TypeError("\"this\" is null or not defined");
        }
        var o = Object(this);
        var len = o.length >>> 0;
        if (len === 0) {
          return false;
        }
        var n = fromIndex | 0;
        var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
        function sameValueZero(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        }
        while (k < len) {
          if (sameValueZero(o[k], searchElement)) {
            return true;
          }
          k++;
        }
        return false;
      }
    });
  }
  if (!Array.prototype.fill) {
    Object.defineProperty(Array.prototype, "fill", {
      value: function (value) {
        if (this == null) {
          throw new TypeError("this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0;
        var start = arguments[1];
        var relativeStart = start >> 0;
        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end >> 0;
        var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
        while (k < final) {
          O[k] = value;
          k++;
        }
        return O;
      }
    });
  }
})();

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);

let jQuery = {};
const inject = (jQueryNew) => {
    jQuery = jQueryNew;
};

var jQuery$1 = {
	extend: function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && typeof target !== "function" ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( isPlainObject( copy ) ||
							( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = extend( deep, clone, copy );

						// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	},
	isEmptyObject: function(obj) {
		return Object.keys(obj).length === 0;
	},
	ajaxSettings: {
		converters: {
			"text json": (data) => JSON.parse( data + "" )
		}
	},
	trim: function (str) {
		return str.trim();
	}
};

window.jQuery = window.jQuery || jQuery$1;
inject(jQuery$1);

/**
	 @license @nocompile
	 Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	 Code distributed by Google as part of the polymer project is also
	 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	 */
	(function(){/*

Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var aa="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);},n="undefined"!=typeof window&&window===this?this:"undefined"!=typeof global&&null!=global?global:this;function ba(){ba=function(){};n.Symbol||(n.Symbol=da);}var da=function(){var a=0;return function(b){return "jscomp_symbol_"+(b||"")+a++}}();
		function ea(){ba();var a=n.Symbol.iterator;a||(a=n.Symbol.iterator=n.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&aa(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return fa(this)}});ea=function(){};}function fa(a){var b=0;return ha(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})}function ha(a){ea();a={next:a};a[n.Symbol.iterator]=function(){return this};return a}function ia(a){ea();var b=a[Symbol.iterator];return b?b.call(a):fa(a)}
		function ja(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c}function ka(){this.Y=this.root=null;this.C=!1;this.j=this.v=this.O=this.assignedSlot=this.assignedNodes=this.m=null;this.childNodes=this.nextSibling=this.previousSibling=this.lastChild=this.firstChild=this.parentNode=this.o=void 0;this.aa=this.T=!1;}ka.prototype.toJSON=function(){return {}};function p(a){a.J||(a.J=new ka);return a.J}function q(a){return a&&a.J}var r=window.ShadyDOM||{};r.ga=!(!Element.prototype.attachShadow||!Node.prototype.getRootNode);var la=Object.getOwnPropertyDescriptor(Node.prototype,"firstChild");r.h=!!(la&&la.configurable&&la.get);r.W=r.force||!r.ga;var ma=navigator.userAgent.match("Trident"),na=navigator.userAgent.match("Edge");void 0===r.Z&&(r.Z=r.h&&(ma||na));function u(a){return (a=q(a))&&void 0!==a.firstChild}function v(a){return "ShadyRoot"===a.ea}function w(a){a=a.getRootNode();if(v(a))return a}
		var x=Element.prototype,oa=x.matches||x.matchesSelector||x.mozMatchesSelector||x.msMatchesSelector||x.oMatchesSelector||x.webkitMatchesSelector;function pa(a,b){if(a&&b)for(var c=Object.getOwnPropertyNames(b),d=0,e;d<c.length&&(e=c[d]);d++){var f=Object.getOwnPropertyDescriptor(b,e);f&&Object.defineProperty(a,e,f);}}function qa(a,b){for(var c=[],d=1;d<arguments.length;++d)c[d-1]=arguments[d];for(d=0;d<c.length;d++)pa(a,c[d]);return a}function ra(a,b){for(var c in b)a[c]=b[c];}
		var sa=document.createTextNode(""),ta=0,ua=[];(new MutationObserver(function(){for(;ua.length;)try{ua.shift()();}catch(a){throw sa.textContent=ta++,a;}})).observe(sa,{characterData:!0});function va(a){ua.push(a);sa.textContent=ta++;}var wa=!!document.contains;function xa(a,b){for(;b;){if(b==a)return !0;b=b.parentNode;}return !1}var y=[],ya;function za(a){ya||(ya=!0,va(z));y.push(a);}function z(){ya=!1;for(var a=!!y.length;y.length;)y.shift()();return a}z.list=y;function Aa(){this.a=!1;this.addedNodes=[];this.removedNodes=[];this.B=new Set;}function Ba(a){a.a||(a.a=!0,va(function(){Ca(a);}));}function Ca(a){if(a.a){a.a=!1;var b=a.takeRecords();b.length&&a.B.forEach(function(a){a(b);});}}Aa.prototype.takeRecords=function(){if(this.addedNodes.length||this.removedNodes.length){var a=[{addedNodes:this.addedNodes,removedNodes:this.removedNodes}];this.addedNodes=[];this.removedNodes=[];return a}return []};
		function Da(a,b){var c=p(a);c.m||(c.m=new Aa);c.m.B.add(b);var d=c.m;return {ca:b,l:d,fa:a,takeRecords:function(){return d.takeRecords()}}}function Ea(a){var b=a&&a.l;b&&(b.B.delete(a.ca),b.B.size||(p(a.fa).m=null));}
		function Fa(a,b){var c=b.getRootNode();return a.map(function(a){var b=c===a.target.getRootNode();if(b&&a.addedNodes){if(b=Array.from(a.addedNodes).filter(function(a){return c===a.getRootNode()}),b.length)return a=Object.create(a),Object.defineProperty(a,"addedNodes",{value:b,configurable:!0}),a}else if(b)return a}).filter(function(a){return a})}var A={},Ga=Element.prototype.insertBefore,Ha=Element.prototype.replaceChild,Ia=Element.prototype.removeChild,Ja=Element.prototype.setAttribute,Ka=Element.prototype.removeAttribute,La=Element.prototype.cloneNode,Ma=Document.prototype.importNode,Na=Element.prototype.addEventListener,Oa=Element.prototype.removeEventListener,Pa=Window.prototype.addEventListener,Qa=Window.prototype.removeEventListener,Ra=Element.prototype.dispatchEvent,Sa=Node.prototype.contains||HTMLElement.prototype.contains,Ta=Document.prototype.getElementById,
			Ua=Element.prototype.querySelector,Va=DocumentFragment.prototype.querySelector,Wa=Document.prototype.querySelector,Xa=Element.prototype.querySelectorAll,Ya=DocumentFragment.prototype.querySelectorAll,Za=Document.prototype.querySelectorAll;A.appendChild=Element.prototype.appendChild;A.insertBefore=Ga;A.replaceChild=Ha;A.removeChild=Ia;A.setAttribute=Ja;A.removeAttribute=Ka;A.cloneNode=La;A.importNode=Ma;A.addEventListener=Na;A.removeEventListener=Oa;A.ja=Pa;A.ka=Qa;A.dispatchEvent=Ra;A.contains=Sa;
		A.getElementById=Ta;A.qa=Ua;A.ta=Va;A.oa=Wa;A.querySelector=function(a){switch(this.nodeType){case Node.ELEMENT_NODE:return Ua.call(this,a);case Node.DOCUMENT_NODE:return Wa.call(this,a);default:return Va.call(this,a)}};A.ra=Xa;A.ua=Ya;A.pa=Za;A.querySelectorAll=function(a){switch(this.nodeType){case Node.ELEMENT_NODE:return Xa.call(this,a);case Node.DOCUMENT_NODE:return Za.call(this,a);default:return Ya.call(this,a)}};var $a=/[&\u00A0"]/g,ab=/[&\u00A0<>]/g;function bb(a){switch(a){case "&":return "&amp;";case "<":return "&lt;";case ">":return "&gt;";case '"':return "&quot;";case "\u00a0":return "&nbsp;"}}function cb(a){for(var b={},c=0;c<a.length;c++)b[a[c]]=!0;return b}var db=cb("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),eb=cb("style script xmp iframe noembed noframes plaintext noscript".split(" "));
		function fb(a,b){"template"===a.localName&&(a=a.content);for(var c="",d=b?b(a):a.childNodes,e=0,f=d.length,g;e<f&&(g=d[e]);e++){a:{var h=g;var k=a;var l=b;switch(h.nodeType){case Node.ELEMENT_NODE:for(var m=h.localName,t="<"+m,L=h.attributes,U=0;k=L[U];U++)t+=" "+k.name+'="'+k.value.replace($a,bb)+'"';t+=">";h=db[m]?t:t+fb(h,l)+"</"+m+">";break a;case Node.TEXT_NODE:h=h.data;h=k&&eb[k.localName]?h:h.replace(ab,bb);break a;case Node.COMMENT_NODE:h="\x3c!--"+h.data+"--\x3e";break a;default:throw window.console.error(h),
			Error("not implemented");}}c+=h;}return c}var B={},C=document.createTreeWalker(document,NodeFilter.SHOW_ALL,null,!1),D=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT,null,!1);function gb(a){var b=[];C.currentNode=a;for(a=C.firstChild();a;)b.push(a),a=C.nextSibling();return b}B.parentNode=function(a){C.currentNode=a;return C.parentNode()};B.firstChild=function(a){C.currentNode=a;return C.firstChild()};B.lastChild=function(a){C.currentNode=a;return C.lastChild()};B.previousSibling=function(a){C.currentNode=a;return C.previousSibling()};
		B.nextSibling=function(a){C.currentNode=a;return C.nextSibling()};B.childNodes=gb;B.parentElement=function(a){D.currentNode=a;return D.parentNode()};B.firstElementChild=function(a){D.currentNode=a;return D.firstChild()};B.lastElementChild=function(a){D.currentNode=a;return D.lastChild()};B.previousElementSibling=function(a){D.currentNode=a;return D.previousSibling()};B.nextElementSibling=function(a){D.currentNode=a;return D.nextSibling()};
		B.children=function(a){var b=[];D.currentNode=a;for(a=D.firstChild();a;)b.push(a),a=D.nextSibling();return b};B.innerHTML=function(a){return fb(a,function(a){return gb(a)})};B.textContent=function(a){switch(a.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:a=document.createTreeWalker(a,NodeFilter.SHOW_TEXT,null,!1);for(var b="",c;c=a.nextNode();)b+=c.nodeValue;return b;default:return a.nodeValue}};var E={},hb=r.h,ib=[Node.prototype,Element.prototype,HTMLElement.prototype];function F(a){var b;a:{for(b=0;b<ib.length;b++){var c=ib[b];if(c.hasOwnProperty(a)){b=c;break a}}b=void 0;}if(!b)throw Error("Could not find descriptor for "+a);return Object.getOwnPropertyDescriptor(b,a)}
		var G=hb?{parentNode:F("parentNode"),firstChild:F("firstChild"),lastChild:F("lastChild"),previousSibling:F("previousSibling"),nextSibling:F("nextSibling"),childNodes:F("childNodes"),parentElement:F("parentElement"),previousElementSibling:F("previousElementSibling"),nextElementSibling:F("nextElementSibling"),innerHTML:F("innerHTML"),textContent:F("textContent"),firstElementChild:F("firstElementChild"),lastElementChild:F("lastElementChild"),children:F("children")}:{},jb=hb?{firstElementChild:Object.getOwnPropertyDescriptor(DocumentFragment.prototype,
			"firstElementChild"),lastElementChild:Object.getOwnPropertyDescriptor(DocumentFragment.prototype,"lastElementChild"),children:Object.getOwnPropertyDescriptor(DocumentFragment.prototype,"children")}:{},kb=hb?{firstElementChild:Object.getOwnPropertyDescriptor(Document.prototype,"firstElementChild"),lastElementChild:Object.getOwnPropertyDescriptor(Document.prototype,"lastElementChild"),children:Object.getOwnPropertyDescriptor(Document.prototype,"children")}:{};E.X=G;E.sa=jb;E.na=kb;E.parentNode=function(a){return G.parentNode.get.call(a)};
		E.firstChild=function(a){return G.firstChild.get.call(a)};E.lastChild=function(a){return G.lastChild.get.call(a)};E.previousSibling=function(a){return G.previousSibling.get.call(a)};E.nextSibling=function(a){return G.nextSibling.get.call(a)};E.childNodes=function(a){return Array.prototype.slice.call(G.childNodes.get.call(a))};E.parentElement=function(a){return G.parentElement.get.call(a)};E.previousElementSibling=function(a){return G.previousElementSibling.get.call(a)};E.nextElementSibling=function(a){return G.nextElementSibling.get.call(a)};
		E.innerHTML=function(a){return G.innerHTML.get.call(a)};E.textContent=function(a){return G.textContent.get.call(a)};E.children=function(a){switch(a.nodeType){case Node.DOCUMENT_FRAGMENT_NODE:a=jb.children.get.call(a);break;case Node.DOCUMENT_NODE:a=kb.children.get.call(a);break;default:a=G.children.get.call(a);}return Array.prototype.slice.call(a)};
		E.firstElementChild=function(a){switch(a.nodeType){case Node.DOCUMENT_FRAGMENT_NODE:return jb.firstElementChild.get.call(a);case Node.DOCUMENT_NODE:return kb.firstElementChild.get.call(a);default:return G.firstElementChild.get.call(a)}};E.lastElementChild=function(a){switch(a.nodeType){case Node.DOCUMENT_FRAGMENT_NODE:return jb.lastElementChild.get.call(a);case Node.DOCUMENT_NODE:return kb.lastElementChild.get.call(a);default:return G.lastElementChild.get.call(a)}};var H=r.Z?E:B;function lb(a){for(;a.firstChild;)a.removeChild(a.firstChild);}
		var mb=r.h,nb=document.implementation.createHTMLDocument("inert"),ob=Object.getOwnPropertyDescriptor(Node.prototype,"isConnected"),pb=ob&&ob.get,qb=Object.getOwnPropertyDescriptor(Document.prototype,"activeElement"),rb={parentElement:{get:function(){var a=q(this);(a=a&&a.parentNode)&&a.nodeType!==Node.ELEMENT_NODE&&(a=null);return void 0!==a?a:H.parentElement(this)},configurable:!0},parentNode:{get:function(){var a=q(this);a=a&&a.parentNode;return void 0!==a?a:H.parentNode(this)},configurable:!0},
			nextSibling:{get:function(){var a=q(this);a=a&&a.nextSibling;return void 0!==a?a:H.nextSibling(this)},configurable:!0},previousSibling:{get:function(){var a=q(this);a=a&&a.previousSibling;return void 0!==a?a:H.previousSibling(this)},configurable:!0},nextElementSibling:{get:function(){var a=q(this);if(a&&void 0!==a.nextSibling){for(a=this.nextSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return H.nextElementSibling(this)},configurable:!0},previousElementSibling:{get:function(){var a=
				q(this);if(a&&void 0!==a.previousSibling){for(a=this.previousSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return H.previousElementSibling(this)},configurable:!0}},sb={className:{get:function(){return this.getAttribute("class")||""},set:function(a){this.setAttribute("class",a);},configurable:!0}},tb={childNodes:{get:function(){if(u(this)){var a=q(this);if(!a.childNodes){a.childNodes=[];for(var b=this.firstChild;b;b=b.nextSibling)a.childNodes.push(b);}var c=a.childNodes;}else c=
			H.childNodes(this);c.item=function(a){return c[a]};return c},configurable:!0},childElementCount:{get:function(){return this.children.length},configurable:!0},firstChild:{get:function(){var a=q(this);a=a&&a.firstChild;return void 0!==a?a:H.firstChild(this)},configurable:!0},lastChild:{get:function(){var a=q(this);a=a&&a.lastChild;return void 0!==a?a:H.lastChild(this)},configurable:!0},textContent:{get:function(){if(u(this)){for(var a=[],b=0,c=this.childNodes,d;d=c[b];b++)d.nodeType!==Node.COMMENT_NODE&&
		a.push(d.textContent);return a.join("")}return H.textContent(this)},set:function(a){if("undefined"===typeof a||null===a)a="";switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:if(!u(this)&&mb){var b=this.firstChild;(b!=this.lastChild||b&&b.nodeType!=Node.TEXT_NODE)&&lb(this);E.X.textContent.set.call(this,a);}else lb(this),(0<a.length||this.nodeType===Node.ELEMENT_NODE)&&this.appendChild(document.createTextNode(a));break;default:this.nodeValue=a;}},configurable:!0},firstElementChild:{get:function(){var a=
			q(this);if(a&&void 0!==a.firstChild){for(a=this.firstChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return H.firstElementChild(this)},configurable:!0},lastElementChild:{get:function(){var a=q(this);if(a&&void 0!==a.lastChild){for(a=this.lastChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return H.lastElementChild(this)},configurable:!0},children:{get:function(){var a;u(this)?a=Array.prototype.filter.call(this.childNodes,function(a){return a.nodeType===Node.ELEMENT_NODE}):
			a=H.children(this);a.item=function(b){return a[b]};return a},configurable:!0},innerHTML:{get:function(){return u(this)?fb("template"===this.localName?this.content:this):H.innerHTML(this)},set:function(a){var b="template"===this.localName?this.content:this;lb(b);var c=this.localName;c&&"template"!==c||(c="div");c=nb.createElement(c);for(mb?E.X.innerHTML.set.call(c,a):c.innerHTML=a;c.firstChild;)b.appendChild(c.firstChild);},configurable:!0}},ub={shadowRoot:{get:function(){var a=q(this);return a&&a.Y||
			null},configurable:!0}},vb={activeElement:{get:function(){var a=qb&&qb.get?qb.get.call(document):r.h?void 0:document.activeElement;if(a&&a.nodeType){var b=!!v(this);if(this===document||b&&this.host!==a&&A.contains.call(this.host,a)){for(b=w(a);b&&b!==this;)a=b.host,b=w(a);a=this===document?b?null:a:b===this?a:null;}else a=null;}else a=null;return a},set:function(){},configurable:!0}};
		function I(a,b,c){for(var d in b){var e=Object.getOwnPropertyDescriptor(a,d);e&&e.configurable||!e&&c?Object.defineProperty(a,d,b[d]):c&&console.warn("Could not define",d,"on",a);}}function J(a){I(a,rb);I(a,sb);I(a,tb);I(a,vb);}
		function wb(){var a=K.prototype;a.__proto__=DocumentFragment.prototype;I(a,rb,!0);I(a,tb,!0);I(a,vb,!0);Object.defineProperties(a,{nodeType:{value:Node.DOCUMENT_FRAGMENT_NODE,configurable:!0},nodeName:{value:"#document-fragment",configurable:!0},nodeValue:{value:null,configurable:!0}});["localName","namespaceURI","prefix"].forEach(function(b){Object.defineProperty(a,b,{value:void 0,configurable:!0});});["ownerDocument","baseURI","isConnected"].forEach(function(b){Object.defineProperty(a,b,{get:function(){return this.host[b]},
			configurable:!0});});}var xb=r.h?function(){}:function(a){var b=p(a);b.T||(b.T=!0,I(a,rb,!0),I(a,sb,!0));},yb=r.h?function(){}:function(a){p(a).aa||(I(a,tb,!0),I(a,ub,!0));};var zb=H.childNodes;function Ab(a,b,c){xb(a);c=c||null;var d=p(a),e=p(b),f=c?p(c):null;d.previousSibling=c?f.previousSibling:b.lastChild;if(f=q(d.previousSibling))f.nextSibling=a;if(f=q(d.nextSibling=c))f.previousSibling=a;d.parentNode=b;c?c===e.firstChild&&(e.firstChild=a):(e.lastChild=a,e.firstChild||(e.firstChild=a));e.childNodes=null;}
		function Bb(a,b){var c=p(a);if(void 0===c.firstChild)for(b=b||zb(a),c.firstChild=b[0]||null,c.lastChild=b[b.length-1]||null,yb(a),c=0;c<b.length;c++){var d=b[c],e=p(d);e.parentNode=a;e.nextSibling=b[c+1]||null;e.previousSibling=b[c-1]||null;xb(d);}}var Cb=H.parentNode;
		function Db(a,b,c){if(b===a)throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");if(c){var d=q(c);d=d&&d.parentNode;if(void 0!==d&&d!==a||void 0===d&&Cb(c)!==a)throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");}if(c===b)return b;b.parentNode&&Eb(b.parentNode,b);var e,f;if(!b.__noInsertionPoint){if(f=e=w(a)){var g;"slot"===b.localName?g=[b]:b.querySelectorAll&&
			(g=b.querySelectorAll("slot"));f=g&&g.length?g:void 0;}f&&(g=e,d=f,g.a=g.a||[],g.b=g.b||[],g.f=g.f||{},g.a.push.apply(g.a,[].concat(d instanceof Array?d:ja(ia(d)))));}("slot"===a.localName||f)&&(e=e||w(a))&&M(e);if(u(a)){e=c;yb(a);f=p(a);void 0!==f.firstChild&&(f.childNodes=null);if(b.nodeType===Node.DOCUMENT_FRAGMENT_NODE){f=b.childNodes;for(g=0;g<f.length;g++)Ab(f[g],a,e);e=p(b);f=void 0!==e.firstChild?null:void 0;e.firstChild=e.lastChild=f;e.childNodes=f;}else Ab(b,a,e);e=q(a);if(Fb(a)){M(e.root);
			var h=!0;}else e.root&&(h=!0);}h||(h=v(a)?a.host:a,c?(c=Gb(c),A.insertBefore.call(h,b,c)):A.appendChild.call(h,b));Hb(a,b);return b}
		function Eb(a,b){if(b.parentNode!==a)throw Error("The node to be removed is not a child of this node: "+b);var c=w(b),d=q(a);if(u(a)){var e=p(b),f=p(a);b===f.firstChild&&(f.firstChild=e.nextSibling);b===f.lastChild&&(f.lastChild=e.previousSibling);var g=e.previousSibling,h=e.nextSibling;g&&(p(g).nextSibling=h);h&&(p(h).previousSibling=g);e.parentNode=e.previousSibling=e.nextSibling=void 0;void 0!==f.childNodes&&(f.childNodes=null);if(Fb(a)){M(d.root);var k=!0;}}Ib(b);if(c){(e=a&&"slot"===a.localName)&&
		(k=!0);if(c.b){Jb(c);f=c.f;for(ca in f)for(g=f[ca],h=0;h<g.length;h++){var l=g[h];if(xa(b,l)){g.splice(h,1);var m=c.b.indexOf(l);0<=m&&c.b.splice(m,1);h--;m=q(l);if(l=m.j)for(var t=0;t<l.length;t++){var L=l[t],U=Kb(L);U&&A.removeChild.call(U,L);}m.j=[];m.assignedNodes=[];m=!0;}}var ca=m;}else ca=void 0;(ca||e)&&M(c);}k||(k=v(a)?a.host:a,(!d.root&&"slot"!==b.localName||k===Cb(b))&&A.removeChild.call(k,b));Hb(a,null,b);return b}
		function Ib(a){var b=q(a);if(b&&void 0!==b.o){b=a.childNodes;for(var c=0,d=b.length,e;c<d&&(e=b[c]);c++)Ib(e);}if(a=q(a))a.o=void 0;}function Gb(a){var b=a;a&&"slot"===a.localName&&(b=(b=(b=q(a))&&b.j)&&b.length?b[0]:Gb(a.nextSibling));return b}function Fb(a){return (a=(a=q(a))&&a.root)&&Lb(a)}
		function Mb(a,b){if("slot"===b)a=a.parentNode,Fb(a)&&M(q(a).root);else if("slot"===a.localName&&"name"===b&&(b=w(a))){if(b.b){var c=a.ba,d=Nb(a);if(d!==c){c=b.f[c];var e=c.indexOf(a);0<=e&&c.splice(e,1);c=b.f[d]||(b.f[d]=[]);c.push(a);1<c.length&&(b.f[d]=Ob(c));}}M(b);}}function Hb(a,b,c){if(a=(a=q(a))&&a.m)b&&a.addedNodes.push(b),c&&a.removedNodes.push(c),Ba(a);}
		function Pb(a){if(a&&a.nodeType){var b=p(a),c=b.o;void 0===c&&(v(a)?(c=a,b.o=c):(c=(c=a.parentNode)?Pb(c):a,A.contains.call(document.documentElement,a)&&(b.o=c)));return c}}function Qb(a,b,c){var d=[];Rb(a.childNodes,b,c,d);return d}function Rb(a,b,c,d){for(var e=0,f=a.length,g;e<f&&(g=a[e]);e++){var h;if(h=g.nodeType===Node.ELEMENT_NODE){h=g;var k=b,l=c,m=d,t=k(h);t&&m.push(h);l&&l(t)?h=t:(Rb(h.childNodes,k,l,m),h=void 0);}if(h)break}}var Sb=null;
		function Tb(a,b,c){Sb||(Sb=window.ShadyCSS&&window.ShadyCSS.ScopingShim);Sb&&"class"===b?Sb.setElementClass(a,c):(A.setAttribute.call(a,b,c),Mb(a,b));}function Ub(a,b){if(a.ownerDocument!==document)return A.importNode.call(document,a,b);var c=A.importNode.call(document,a,!1);if(b){a=a.childNodes;b=0;for(var d;b<a.length;b++)d=Ub(a[b],!0),c.appendChild(d);}return c}var N="__eventWrappers"+Date.now(),Vb={blur:!0,focus:!0,focusin:!0,focusout:!0,click:!0,dblclick:!0,mousedown:!0,mouseenter:!0,mouseleave:!0,mousemove:!0,mouseout:!0,mouseover:!0,mouseup:!0,wheel:!0,beforeinput:!0,input:!0,keydown:!0,keyup:!0,compositionstart:!0,compositionupdate:!0,compositionend:!0,touchstart:!0,touchend:!0,touchmove:!0,touchcancel:!0,pointerover:!0,pointerenter:!0,pointerdown:!0,pointermove:!0,pointerup:!0,pointercancel:!0,pointerout:!0,pointerleave:!0,gotpointercapture:!0,lostpointercapture:!0,
			dragstart:!0,drag:!0,dragenter:!0,dragleave:!0,dragover:!0,drop:!0,dragend:!0,DOMActivate:!0,DOMFocusIn:!0,DOMFocusOut:!0,keypress:!0};function Wb(a,b){var c=[],d=a;for(a=a===window?window:a.getRootNode();d;)c.push(d),d=d.assignedSlot?d.assignedSlot:d.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&d.host&&(b||d!==a)?d.host:d.parentNode;c[c.length-1]===document&&c.push(window);return c}
		function Xb(a,b){if(!v)return a;a=Wb(a,!0);for(var c=0,d,e,f,g;c<b.length;c++)if(d=b[c],f=d===window?window:d.getRootNode(),f!==e&&(g=a.indexOf(f),e=f),!v(f)||-1<g)return d}
		var Yb={get composed(){!1!==this.isTrusted&&void 0===this.G&&(this.G=Vb[this.type]);return this.G||!1},composedPath:function(){this.S||(this.S=Wb(this.__target,this.composed));return this.S},get target(){return Xb(this.currentTarget,this.composedPath())},get relatedTarget(){if(!this.I)return null;this.U||(this.U=Wb(this.I,!0));return Xb(this.currentTarget,this.U)},stopPropagation:function(){Event.prototype.stopPropagation.call(this);this.H=!0;},stopImmediatePropagation:function(){Event.prototype.stopImmediatePropagation.call(this);
			this.H=this.$=!0;}};function Zb(a){function b(b,d){b=new a(b,d);b.G=d&&!!d.composed;return b}ra(b,a);b.prototype=a.prototype;return b}var $b={focus:!0,blur:!0};function ac(a){return a.__target!==a.target||a.I!==a.relatedTarget}function bc(a,b,c){if(c=b.__handlers&&b.__handlers[a.type]&&b.__handlers[a.type][c])for(var d=0,e;(e=c[d])&&(!ac(a)||a.target!==a.relatedTarget)&&(e.call(b,a),!a.$);d++);}
		function cc(a){var b=a.composedPath();Object.defineProperty(a,"currentTarget",{get:function(){return d},configurable:!0});for(var c=b.length-1;0<=c;c--){var d=b[c];bc(a,d,"capture");if(a.H)return}Object.defineProperty(a,"eventPhase",{get:function(){return Event.AT_TARGET}});var e;for(c=0;c<b.length;c++){d=b[c];var f=q(d);f=f&&f.root;if(0===c||f&&f===e)if(bc(a,d,"bubble"),d!==window&&(e=d.getRootNode()),a.H)break}}
		function dc(a,b,c,d,e,f){for(var g=0;g<a.length;g++){var h=a[g],k=h.type,l=h.capture,m=h.once,t=h.passive;if(b===h.node&&c===k&&d===l&&e===m&&f===t)return g}return -1}
		function ec(a,b,c){if(b){var d=typeof b;if("function"===d||"object"===d)if("object"!==d||b.handleEvent&&"function"===typeof b.handleEvent){if(c&&"object"===typeof c){var e=!!c.capture;var f=!!c.once;var g=!!c.passive;}else e=!!c,g=f=!1;var h=c&&c.K||this,k=b[N];if(k){if(-1<dc(k,h,a,e,f,g))return}else b[N]=[];k=function(e){f&&this.removeEventListener(a,b,c);e.__target||fc(e);if(h!==this){var g=Object.getOwnPropertyDescriptor(e,"currentTarget");Object.defineProperty(e,"currentTarget",{get:function(){return h},
			configurable:!0});}if(e.composed||-1<e.composedPath().indexOf(h))if(ac(e)&&e.target===e.relatedTarget)e.eventPhase===Event.BUBBLING_PHASE&&e.stopImmediatePropagation();else if(e.eventPhase===Event.CAPTURING_PHASE||e.bubbles||e.target===h||h instanceof Window){var k="function"===d?b.call(h,e):b.handleEvent&&b.handleEvent(e);h!==this&&(g?(Object.defineProperty(e,"currentTarget",g),g=null):delete e.currentTarget);return k}};b[N].push({node:h,type:a,capture:e,once:f,passive:g,la:k});$b[a]?(this.__handlers=
			this.__handlers||{},this.__handlers[a]=this.__handlers[a]||{capture:[],bubble:[]},this.__handlers[a][e?"capture":"bubble"].push(k)):(this instanceof Window?A.ja:A.addEventListener).call(this,a,k,c);}}}
		function gc(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive;}else d=!!c,f=e=!1;var g=c&&c.K||this,h=void 0;var k=null;try{k=b[N];}catch(l){}k&&(e=dc(k,g,a,d,e,f),-1<e&&(h=k.splice(e,1)[0].la,k.length||(b[N]=void 0)));(this instanceof Window?A.ka:A.removeEventListener).call(this,a,h||b,c);h&&$b[a]&&this.__handlers&&this.__handlers[a]&&(a=this.__handlers[a][d?"capture":"bubble"],h=a.indexOf(h),-1<h&&a.splice(h,1));}}
		function hc(){for(var a in $b)window.addEventListener(a,function(a){a.__target||(fc(a),cc(a));},!0);}function fc(a){a.__target=a.target;a.I=a.relatedTarget;if(r.h){var b=Object.getPrototypeOf(a);if(!b.hasOwnProperty("__patchProto")){var c=Object.create(b);c.ma=b;pa(c,Yb);b.__patchProto=c;}a.__proto__=b.__patchProto;}else pa(a,Yb);}var ic=Zb(window.Event),jc=Zb(window.CustomEvent),kc=Zb(window.MouseEvent);function O(a,b){return {index:a,s:[],A:b}}
		function lc(a,b,c,d){var e=0,f=0,g=0,h=0,k=Math.min(b-e,d-f);if(0==e&&0==f)a:{for(g=0;g<k;g++)if(a[g]!==c[g])break a;g=k;}if(b==a.length&&d==c.length){h=a.length;for(var l=c.length,m=0;m<k-g&&mc(a[--h],c[--l]);)m++;h=m;}e+=g;f+=g;b-=h;d-=h;if(0==b-e&&0==d-f)return [];if(e==b){for(b=O(e,0);f<d;)b.s.push(c[f++]);return [b]}if(f==d)return [O(e,b-e)];k=e;g=f;d=d-g+1;h=b-k+1;b=Array(d);for(l=0;l<d;l++)b[l]=Array(h),b[l][0]=l;for(l=0;l<h;l++)b[0][l]=l;for(l=1;l<d;l++)for(m=1;m<h;m++)if(a[k+m-1]===c[g+l-1])b[l][m]=
			b[l-1][m-1];else{var t=b[l-1][m]+1,L=b[l][m-1]+1;b[l][m]=t<L?t:L;}k=b.length-1;g=b[0].length-1;d=b[k][g];for(a=[];0<k||0<g;)0==k?(a.push(2),g--):0==g?(a.push(3),k--):(h=b[k-1][g-1],l=b[k-1][g],m=b[k][g-1],t=l<m?l<h?l:h:m<h?m:h,t==h?(h==d?a.push(0):(a.push(1),d=h),k--,g--):t==l?(a.push(3),k--,d=l):(a.push(2),g--,d=m));a.reverse();b=void 0;k=[];for(g=0;g<a.length;g++)switch(a[g]){case 0:b&&(k.push(b),b=void 0);e++;f++;break;case 1:b||(b=O(e,0));b.A++;e++;b.s.push(c[f]);f++;break;case 2:b||(b=O(e,0));
			b.A++;e++;break;case 3:b||(b=O(e,0)),b.s.push(c[f]),f++;}b&&k.push(b);return k}function mc(a,b){return a===b}var Kb=H.parentNode,nc=H.childNodes,oc={};function pc(a){var b=[];do b.unshift(a);while(a=a.parentNode);return b}function K(a,b,c){if(a!==oc)throw new TypeError("Illegal constructor");this.ea="ShadyRoot";a=nc(b);this.host=b;this.c=c&&c.mode;Bb(b,a);c=q(b);c.root=this;c.Y="closed"!==this.c?this:null;c=p(this);c.firstChild=c.lastChild=c.parentNode=c.nextSibling=c.previousSibling=null;c.childNodes=[];this.w=!1;this.a=this.f=this.b=null;c=0;for(var d=a.length;c<d;c++)A.removeChild.call(b,a[c]);}
		function M(a){a.w||(a.w=!0,za(function(){return qc(a)}));}function qc(a){for(var b;a;){a.w&&(b=a);a:{var c=a;a=c.host.getRootNode();if(v(a))for(var d=c.host.childNodes,e=0;e<d.length;e++)if(c=d[e],"slot"==c.localName)break a;a=void 0;}}b&&b._renderRoot();}
		K.prototype._renderRoot=function(){this.w=!1;if(this.b){Jb(this);for(var a=0,b;a<this.b.length;a++){b=this.b[a];var c=q(b),d=c.assignedNodes;c.assignedNodes=[];c.j=[];if(c.O=d)for(c=0;c<d.length;c++){var e=q(d[c]);e.v=e.assignedSlot;e.assignedSlot===b&&(e.assignedSlot=null);}}for(b=this.host.firstChild;b;b=b.nextSibling)rc(this,b);for(a=0;a<this.b.length;a++){b=this.b[a];d=q(b);if(!d.assignedNodes.length)for(c=b.firstChild;c;c=c.nextSibling)rc(this,c,b);(c=(c=q(b.parentNode))&&c.root)&&Lb(c)&&c._renderRoot();
			sc(this,d.j,d.assignedNodes);if(c=d.O){for(e=0;e<c.length;e++)q(c[e]).v=null;d.O=null;c.length>d.assignedNodes.length&&(d.C=!0);}d.C&&(d.C=!1,tc(this,b));}a=this.b;b=[];for(d=0;d<a.length;d++)c=a[d].parentNode,(e=q(c))&&e.root||!(0>b.indexOf(c))||b.push(c);for(a=0;a<b.length;a++){d=b[a];c=d===this?this.host:d;e=[];d=d.childNodes;for(var f=0;f<d.length;f++){var g=d[f];if("slot"==g.localName){g=q(g).j;for(var h=0;h<g.length;h++)e.push(g[h]);}else e.push(g);}d=void 0;f=nc(c);g=lc(e,e.length,f,f.length);
			for(var k=h=0;h<g.length&&(d=g[h]);h++){for(var l=0,m;l<d.s.length&&(m=d.s[l]);l++)Kb(m)===c&&A.removeChild.call(c,m),f.splice(d.index+k,1);k-=d.A;}for(k=0;k<g.length&&(d=g[k]);k++)for(h=f[d.index],l=d.index;l<d.index+d.A;l++)m=e[l],A.insertBefore.call(c,m,h),f.splice(l,0,m);}}};function rc(a,b,c){var d=p(b),e=d.v;d.v=null;c||(c=(a=a.f[b.slot||"__catchall"])&&a[0]);c?(p(c).assignedNodes.push(b),d.assignedSlot=c):d.assignedSlot=void 0;e!==d.assignedSlot&&d.assignedSlot&&(p(d.assignedSlot).C=!0);}
		function sc(a,b,c){for(var d=0,e;d<c.length&&(e=c[d]);d++)if("slot"==e.localName){var f=q(e).assignedNodes;f&&f.length&&sc(a,b,f);}else b.push(c[d]);}function tc(a,b){A.dispatchEvent.call(b,new Event("slotchange"));b=q(b);b.assignedSlot&&tc(a,b.assignedSlot);}function Jb(a){if(a.a&&a.a.length){for(var b=a.a,c,d=0;d<b.length;d++){var e=b[d];Bb(e);Bb(e.parentNode);var f=Nb(e);a.f[f]?(c=c||{},c[f]=!0,a.f[f].push(e)):a.f[f]=[e];a.b.push(e);}if(c)for(var g in c)a.f[g]=Ob(a.f[g]);a.a=[];}}
		function Nb(a){var b=a.name||a.getAttribute("name")||"__catchall";return a.ba=b}function Ob(a){return a.sort(function(a,c){a=pc(a);for(var b=pc(c),e=0;e<a.length;e++){c=a[e];var f=b[e];if(c!==f)return a=Array.from(c.parentNode.childNodes),a.indexOf(c)-a.indexOf(f)}})}function Lb(a){Jb(a);return !(!a.b||!a.b.length)}function uc(a){var b=a.getRootNode();v(b)&&qc(b);return (a=q(a))&&a.assignedSlot||null}
		var vc={addEventListener:ec.bind(window),removeEventListener:gc.bind(window)},wc={addEventListener:ec,removeEventListener:gc,appendChild:function(a){return Db(this,a)},insertBefore:function(a,b){return Db(this,a,b)},removeChild:function(a){return Eb(this,a)},replaceChild:function(a,b){Db(this,a,b);Eb(this,b);return a},cloneNode:function(a){if("template"==this.localName)var b=A.cloneNode.call(this,a);else if(b=A.cloneNode.call(this,!1),a){a=this.childNodes;for(var c=0,d;c<a.length;c++)d=a[c].cloneNode(!0),
			b.appendChild(d);}return b},getRootNode:function(){return Pb(this)},contains:function(a){return xa(this,a)},dispatchEvent:function(a){z();return A.dispatchEvent.call(this,a)}};
		Object.defineProperties(wc,{isConnected:{get:function(){if(pb&&pb.call(this))return !0;if(this.nodeType==Node.DOCUMENT_FRAGMENT_NODE)return !1;var a=this.ownerDocument;if(wa){if(A.contains.call(a,this))return !0}else if(a.documentElement&&A.contains.call(a.documentElement,this))return !0;for(a=this;a&&!(a instanceof Document);)a=a.parentNode||(v(a)?a.host:void 0);return !!(a&&a instanceof Document)},configurable:!0}});
		var xc={get assignedSlot(){return uc(this)}},yc={querySelector:function(a){return Qb(this,function(b){return oa.call(b,a)},function(a){return !!a})[0]||null},querySelectorAll:function(a,b){if(b){b=Array.prototype.slice.call(A.querySelectorAll(this,a));var c=this.getRootNode();return b.filter(function(a){return a.getRootNode()==c})}return Qb(this,function(b){return oa.call(b,a)})}},zc={assignedNodes:function(a){if("slot"===this.localName){var b=this.getRootNode();v(b)&&qc(b);return (b=q(this))?(a&&a.flatten?
			b.j:b.assignedNodes)||[]:[]}}},Ac=qa({setAttribute:function(a,b){Tb(this,a,b);},removeAttribute:function(a){A.removeAttribute.call(this,a);Mb(this,a);},attachShadow:function(a){if(!this)throw"Must provide a host.";if(!a)throw"Not enough arguments.";return new K(oc,this,a)},get slot(){return this.getAttribute("slot")},set slot(a){Tb(this,"slot",a);},get assignedSlot(){return uc(this)}},yc,zc);Object.defineProperties(Ac,ub);
		var Bc=qa({importNode:function(a,b){return Ub(a,b)},getElementById:function(a){return Qb(this,function(b){return b.id==a},function(a){return !!a})[0]||null}},yc);Object.defineProperties(Bc,{_activeElement:vb.activeElement});
		var Cc=HTMLElement.prototype.blur,Dc=qa({blur:function(){var a=q(this);(a=(a=a&&a.root)&&a.activeElement)?a.blur():Cc.call(this);}}),Ec={addEventListener:function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.K=this;this.host.addEventListener(a,b,c);},removeEventListener:function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.K=this;this.host.removeEventListener(a,b,c);},getElementById:function(a){return Qb(this,function(b){return b.id==a},function(a){return !!a})[0]||null}};
		function P(a,b){for(var c=Object.getOwnPropertyNames(b),d=0;d<c.length;d++){var e=c[d],f=Object.getOwnPropertyDescriptor(b,e);f.value?a[e]=f.value:Object.defineProperty(a,e,f);}}if(r.W){var ShadyDOM={inUse:r.W,patch:function(a){yb(a);xb(a);return a},isShadyRoot:v,enqueue:za,flush:z,settings:r,filterMutations:Fa,observeChildren:Da,unobserveChildren:Ea,nativeMethods:A,nativeTree:H};window.ShadyDOM=ShadyDOM;window.Event=ic;window.CustomEvent=jc;window.MouseEvent=kc;hc();var Fc=window.customElements&&window.customElements.nativeHTMLElement||HTMLElement;P(K.prototype,Ec);P(window.Node.prototype,wc);P(window.Window.prototype,vc);P(window.Text.prototype,xc);P(window.DocumentFragment.prototype,
			yc);P(window.Element.prototype,Ac);P(window.Document.prototype,Bc);window.HTMLSlotElement&&P(window.HTMLSlotElement.prototype,zc);P(Fc.prototype,Dc);r.h&&(J(window.Node.prototype),J(window.Text.prototype),J(window.DocumentFragment.prototype),J(window.Element.prototype),J(Fc.prototype),J(window.Document.prototype),window.HTMLSlotElement&&J(window.HTMLSlotElement.prototype));wb();window.ShadowRoot=K;}var Gc=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function Hc(a){var b=Gc.has(a);a=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a);return !b&&a}function Q(a){var b=a.isConnected;if(void 0!==b)return b;for(;a&&!(a.__CE_isImportDocument||a instanceof Document);)a=a.parentNode||(window.ShadowRoot&&a instanceof ShadowRoot?a.host:void 0);return !(!a||!(a.__CE_isImportDocument||a instanceof Document))}
		function Ic(a,b){for(;b&&b!==a&&!b.nextSibling;)b=b.parentNode;return b&&b!==a?b.nextSibling:null}
		function R(a,b,c){c=void 0===c?new Set:c;for(var d=a;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;b(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)R(d,b,c);d=Ic(a,e);continue}else if("template"===f){d=Ic(a,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)R(e,b,c);}d=d.firstChild?d.firstChild:Ic(a,d);}}function S(a,b,c){a[b]=c;}function T(){this.a=new Map;this.V=new Map;this.R=[];this.i=!1;}function Jc(a,b,c){a.a.set(b,c);a.V.set(c.constructor,c);}function Kc(a,b){a.i=!0;a.R.push(b);}function Lc(a,b){a.i&&R(b,function(b){return a.c(b)});}T.prototype.c=function(a){if(this.i&&!a.__CE_patched){a.__CE_patched=!0;for(var b=0;b<this.R.length;b++)this.R[b](a);}};function V(a,b){var c=[];R(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state?a.connectedCallback(d):Mc(a,d);}}
		function W(a,b){var c=[];R(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state&&a.disconnectedCallback(d);}}
		function X(a,b,c){c=void 0===c?{}:c;var d=c.ia||new Set,e=c.F||function(b){return Mc(a,b)},f=[];R(b,function(b){if("link"===b.localName&&"import"===b.getAttribute("rel")){var c=b.import;c instanceof Node&&(c.__CE_isImportDocument=!0,c.__CE_hasRegistry=!0);c&&"complete"===c.readyState?c.__CE_documentLoadHandled=!0:b.addEventListener("load",function(){var c=b.import;if(!c.__CE_documentLoadHandled){c.__CE_documentLoadHandled=!0;var f=new Set(d);f.delete(c);X(a,c,{ia:f,F:e});}});}else f.push(b);},d);if(a.i)for(b=
																																																																																																																																		 0;b<f.length;b++)a.c(f[b]);for(b=0;b<f.length;b++)e(f[b]);}
		function Mc(a,b){if(void 0===b.__CE_state){var c=b.ownerDocument;if(c.defaultView||c.__CE_isImportDocument&&c.__CE_hasRegistry)if(c=a.a.get(b.localName)){c.constructionStack.push(b);var d=c.constructor;try{try{if(new d!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{c.constructionStack.pop();}}catch(g){throw b.__CE_state=2,g;}b.__CE_state=1;b.__CE_definition=c;if(c.attributeChangedCallback)for(c=c.observedAttributes,d=0;d<c.length;d++){var e=c[d],
			f=b.getAttribute(e);null!==f&&a.attributeChangedCallback(b,e,null,f,null);}Q(b)&&a.connectedCallback(b);}}}T.prototype.connectedCallback=function(a){var b=a.__CE_definition;b.connectedCallback&&b.connectedCallback.call(a);};T.prototype.disconnectedCallback=function(a){var b=a.__CE_definition;b.disconnectedCallback&&b.disconnectedCallback.call(a);};
		T.prototype.attributeChangedCallback=function(a,b,c,d,e){var f=a.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(b)&&f.attributeChangedCallback.call(a,b,c,d,e);};function Nc(a){var b=document;this.g=a;this.a=b;this.l=void 0;X(this.g,this.a);"loading"===this.a.readyState&&(this.l=new MutationObserver(this.c.bind(this)),this.l.observe(this.a,{childList:!0,subtree:!0}));}function Oc(a){a.l&&a.l.disconnect();}Nc.prototype.c=function(a){var b=this.a.readyState;"interactive"!==b&&"complete"!==b||Oc(this);for(b=0;b<a.length;b++)for(var c=a[b].addedNodes,d=0;d<c.length;d++)X(this.g,c[d]);};function Pc(){var a=this;this.c=this.a=void 0;this.i=new Promise(function(b){a.c=b;a.a&&b(a.a);});}function Qc(a){if(a.a)throw Error("Already resolved.");a.a=void 0;a.c&&a.c(void 0);}function Y(a){this.L=!1;this.g=a;this.P=new Map;this.M=function(a){return a()};this.u=!1;this.N=[];this.da=new Nc(a);}
		Y.prototype.define=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!Hc(a))throw new SyntaxError("The element name '"+a+"' is not valid.");if(this.g.a.get(a))throw Error("A custom element with name '"+a+"' has already been defined.");if(this.L)throw Error("A custom element is already being defined.");this.L=!0;try{var d=function(a){var b=e[a];if(void 0!==b&&!(b instanceof Function))throw Error("The '"+a+"' callback must be a function.");
			return b},e=b.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var f=d("connectedCallback");var g=d("disconnectedCallback");var h=d("adoptedCallback");var k=d("attributeChangedCallback");var l=b.observedAttributes||[];}catch(m){return}finally{this.L=!1;}b={localName:a,constructor:b,connectedCallback:f,disconnectedCallback:g,adoptedCallback:h,attributeChangedCallback:k,observedAttributes:l,constructionStack:[]};Jc(this.g,a,b);this.N.push(b);
			this.u||(this.u=!0,this.M(function(){return Rc(c)}));};Y.prototype.F=function(a){X(this.g,a);};function Rc(a){if(!1!==a.u){a.u=!1;for(var b=a.N,c=[],d=new Map,e=0;e<b.length;e++)d.set(b[e].localName,[]);X(a.g,document,{F:function(b){if(void 0===b.__CE_state){var e=b.localName,f=d.get(e);f?f.push(b):a.g.a.get(e)&&c.push(b);}}});for(e=0;e<c.length;e++)Mc(a.g,c[e]);for(;0<b.length;){var f=b.shift();e=f.localName;f=d.get(f.localName);for(var g=0;g<f.length;g++)Mc(a.g,f[g]);(e=a.P.get(e))&&Qc(e);}}}
		Y.prototype.get=function(a){if(a=this.g.a.get(a))return a.constructor};Y.prototype.whenDefined=function(a){if(!Hc(a))return Promise.reject(new SyntaxError("'"+a+"' is not a valid custom element name."));var b=this.P.get(a);if(b)return b.i;b=new Pc;this.P.set(a,b);this.g.a.get(a)&&!this.N.some(function(b){return b.localName===a})&&Qc(b);return b.i};Y.prototype.ha=function(a){Oc(this.da);var b=this.M;this.M=function(c){return a(function(){return b(c)})};};window.CustomElementRegistry=Y;
		Y.prototype.define=Y.prototype.define;Y.prototype.upgrade=Y.prototype.F;Y.prototype.get=Y.prototype.get;Y.prototype.whenDefined=Y.prototype.whenDefined;Y.prototype.polyfillWrapFlushCallback=Y.prototype.ha;var Sc=window.Document.prototype.createElement,Tc=window.Document.prototype.createElementNS,Uc=window.Document.prototype.importNode,Vc=window.Document.prototype.prepend,Wc=window.Document.prototype.append,Xc=window.DocumentFragment.prototype.prepend,Yc=window.DocumentFragment.prototype.append,Zc=window.Node.prototype.cloneNode,$c=window.Node.prototype.appendChild,ad=window.Node.prototype.insertBefore,bd=window.Node.prototype.removeChild,cd=window.Node.prototype.replaceChild,dd=Object.getOwnPropertyDescriptor(window.Node.prototype,
			"textContent"),ed=window.Element.prototype.attachShadow,fd=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),gd=window.Element.prototype.getAttribute,hd=window.Element.prototype.setAttribute,id=window.Element.prototype.removeAttribute,jd=window.Element.prototype.getAttributeNS,kd=window.Element.prototype.setAttributeNS,ld=window.Element.prototype.removeAttributeNS,md=window.Element.prototype.insertAdjacentElement,nd=window.Element.prototype.insertAdjacentHTML,od=window.Element.prototype.prepend,
			pd=window.Element.prototype.append,qd=window.Element.prototype.before,rd=window.Element.prototype.after,sd=window.Element.prototype.replaceWith,td=window.Element.prototype.remove,ud=window.HTMLElement,vd=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),wd=window.HTMLElement.prototype.insertAdjacentElement,xd=window.HTMLElement.prototype.insertAdjacentHTML;var yd=new function(){};function zd(){var a=Z;window.HTMLElement=function(){function b(){var b=this.constructor,d=a.V.get(b);if(!d)throw Error("The custom element being constructed was not registered with `customElements`.");var e=d.constructionStack;if(0===e.length)return e=Sc.call(document,d.localName),Object.setPrototypeOf(e,b.prototype),e.__CE_state=1,e.__CE_definition=d,a.c(e),e;d=e.length-1;var f=e[d];if(f===yd)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
			e[d]=yd;Object.setPrototypeOf(f,b.prototype);a.c(f);return f}b.prototype=ud.prototype;return b}();}function Ad(a,b,c){function d(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var f=[],l=0;l<d.length;l++){var m=d[l];m instanceof Element&&Q(m)&&f.push(m);if(m instanceof DocumentFragment)for(m=m.firstChild;m;m=m.nextSibling)e.push(m);else e.push(m);}b.apply(this,d);for(d=0;d<f.length;d++)W(a,f[d]);if(Q(this))for(d=0;d<e.length;d++)f=e[d],f instanceof Element&&V(a,f);}}void 0!==c.D&&(b.prepend=d(c.D));void 0!==c.append&&(b.append=d(c.append));}function Bd(){var a=Z;S(Document.prototype,"createElement",function(b){if(this.__CE_hasRegistry){var c=a.a.get(b);if(c)return new c.constructor}b=Sc.call(this,b);a.c(b);return b});S(Document.prototype,"importNode",function(b,c){b=Uc.call(this,b,c);this.__CE_hasRegistry?X(a,b):Lc(a,b);return b});S(Document.prototype,"createElementNS",function(b,c){if(this.__CE_hasRegistry&&(null===b||"http://www.w3.org/1999/xhtml"===b)){var d=a.a.get(c);if(d)return new d.constructor}b=Tc.call(this,b,c);a.c(b);return b});
			Ad(a,Document.prototype,{D:Vc,append:Wc});}function Cd(){var a=Z;function b(b,d){Object.defineProperty(b,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(b){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,b);else{var c=void 0;if(this.firstChild){var e=this.childNodes,h=e.length;if(0<h&&Q(this)){c=Array(h);for(var k=0;k<h;k++)c[k]=e[k];}}d.set.call(this,b);if(c)for(b=0;b<c.length;b++)W(a,c[b]);}}});}S(Node.prototype,"insertBefore",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);
			b=ad.call(this,b,d);if(Q(this))for(d=0;d<c.length;d++)V(a,c[d]);return b}c=Q(b);d=ad.call(this,b,d);c&&W(a,b);Q(this)&&V(a,b);return d});S(Node.prototype,"appendChild",function(b){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=$c.call(this,b);if(Q(this))for(var e=0;e<c.length;e++)V(a,c[e]);return b}c=Q(b);e=$c.call(this,b);c&&W(a,b);Q(this)&&V(a,b);return e});S(Node.prototype,"cloneNode",function(b){b=Zc.call(this,b);this.ownerDocument.__CE_hasRegistry?X(a,b):
			Lc(a,b);return b});S(Node.prototype,"removeChild",function(b){var c=Q(b),e=bd.call(this,b);c&&W(a,b);return e});S(Node.prototype,"replaceChild",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=cd.call(this,b,d);if(Q(this))for(W(a,d),d=0;d<c.length;d++)V(a,c[d]);return b}c=Q(b);var f=cd.call(this,b,d),g=Q(this);g&&W(a,d);c&&W(a,b);g&&V(a,b);return f});dd&&dd.get?b(Node.prototype,dd):Kc(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){for(var a=
			[],b=0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)bd.call(this,this.firstChild);$c.call(this,document.createTextNode(a));}});});}function Dd(a){var b=Element.prototype;function c(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var h=[],k=0;k<d.length;k++){var l=d[k];l instanceof Element&&Q(l)&&h.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)e.push(l);else e.push(l);}b.apply(this,d);for(d=0;d<h.length;d++)W(a,h[d]);if(Q(this))for(d=0;d<e.length;d++)h=e[d],h instanceof Element&&V(a,h);}}void 0!==qd&&(b.before=c(qd));void 0!==qd&&(b.after=c(rd));void 0!==
		sd&&S(b,"replaceWith",function(b){for(var c=[],d=0;d<arguments.length;++d)c[d-0]=arguments[d];d=[];for(var g=[],h=0;h<c.length;h++){var k=c[h];k instanceof Element&&Q(k)&&g.push(k);if(k instanceof DocumentFragment)for(k=k.firstChild;k;k=k.nextSibling)d.push(k);else d.push(k);}h=Q(this);sd.apply(this,c);for(c=0;c<g.length;c++)W(a,g[c]);if(h)for(W(a,this),c=0;c<d.length;c++)g=d[c],g instanceof Element&&V(a,g);});void 0!==td&&S(b,"remove",function(){var b=Q(this);td.call(this);b&&W(a,this);});}function Ed(){var a=Z;function b(b,c){Object.defineProperty(b,"innerHTML",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(b){var d=this,e=void 0;Q(this)&&(e=[],R(this,function(a){a!==d&&e.push(a);}));c.set.call(this,b);if(e)for(var f=0;f<e.length;f++){var g=e[f];1===g.__CE_state&&a.disconnectedCallback(g);}this.ownerDocument.__CE_hasRegistry?X(a,this):Lc(a,this);return b}});}function c(b,c){S(b,"insertAdjacentElement",function(b,d){var e=Q(d);b=c.call(this,b,d);e&&W(a,d);Q(b)&&V(a,d);
			return b});}function d(b,c){function d(b,c){for(var d=[];b!==c;b=b.nextSibling)d.push(b);for(c=0;c<d.length;c++)X(a,d[c]);}S(b,"insertAdjacentHTML",function(a,b){a=a.toLowerCase();if("beforebegin"===a){var e=this.previousSibling;c.call(this,a,b);d(e||this.parentNode.firstChild,this);}else if("afterbegin"===a)e=this.firstChild,c.call(this,a,b),d(this.firstChild,e);else if("beforeend"===a)e=this.lastChild,c.call(this,a,b),d(e||this.firstChild,null);else if("afterend"===a)e=this.nextSibling,c.call(this,
			a,b),d(this.nextSibling,e);else throw new SyntaxError("The value provided ("+String(a)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");});}ed&&S(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=ed.call(this,a)});fd&&fd.get?b(Element.prototype,fd):vd&&vd.get?b(HTMLElement.prototype,vd):Kc(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){return Zc.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,c=b?this.content:
			this,d=Tc.call(document,this.namespaceURI,this.localName);for(d.innerHTML=a;0<c.childNodes.length;)bd.call(c,c.childNodes[0]);for(a=b?d.content:d;0<a.childNodes.length;)$c.call(c,a.childNodes[0]);}});});S(Element.prototype,"setAttribute",function(b,c){if(1!==this.__CE_state)return hd.call(this,b,c);var d=gd.call(this,b);hd.call(this,b,c);c=gd.call(this,b);a.attributeChangedCallback(this,b,d,c,null);});S(Element.prototype,"setAttributeNS",function(b,c,d){if(1!==this.__CE_state)return kd.call(this,b,c,
			d);var e=jd.call(this,b,c);kd.call(this,b,c,d);d=jd.call(this,b,c);a.attributeChangedCallback(this,c,e,d,b);});S(Element.prototype,"removeAttribute",function(b){if(1!==this.__CE_state)return id.call(this,b);var c=gd.call(this,b);id.call(this,b);null!==c&&a.attributeChangedCallback(this,b,c,null,null);});S(Element.prototype,"removeAttributeNS",function(b,c){if(1!==this.__CE_state)return ld.call(this,b,c);var d=jd.call(this,b,c);ld.call(this,b,c);var e=jd.call(this,b,c);d!==e&&a.attributeChangedCallback(this,
			c,d,e,b);});wd?c(HTMLElement.prototype,wd):md?c(Element.prototype,md):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");xd?d(HTMLElement.prototype,xd):nd?d(Element.prototype,nd):console.warn("Custom Elements: `Element#insertAdjacentHTML` was not patched.");Ad(a,Element.prototype,{D:od,append:pd});Dd(a);}		var Fd=window.customElements;if(!Fd||Fd.forcePolyfill||"function"!=typeof Fd.define||"function"!=typeof Fd.get){var Z=new T;zd();Bd();Ad(Z,DocumentFragment.prototype,{D:Xc,append:Yc});Cd();Ed();document.__CE_hasRegistry=!0;var customElements=new Y(Z);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements});}	}).call(window);

let Core = {};
const inject$1 = (CoreNew) => {
    Core = CoreNew;
};

const EventEnrichment = {};

let enriched = false;

EventEnrichment.run = function () {
	if (enriched) {
		return;
	}

	const stopPropagationSet = new WeakSet();
	const stopImmediatePropagationSet = new WeakSet();

	const originalStopPropagation = Event.prototype.stopPropagation;
	const originalStopImmediatePropagation = Event.prototype.stopImmediatePropagation;

	Event.prototype.stopPropagation = function () {
		stopPropagationSet.add(this);
		return originalStopPropagation.apply(this, arguments);
	};

	Event.prototype.isPropagationStopped = function () {
		return stopPropagationSet.has(this);
	};

	Event.prototype.stopImmediatePropagation = function () {
		stopImmediatePropagationSet.add(this);
		return originalStopImmediatePropagation.apply(this, arguments);
	};

	Event.prototype.isImmediatePropagationStopped = function () {
		return stopImmediatePropagationSet.has(this);
	};

	enriched = true;
};

const patchNodeValue = () => {
	const nativeNodeValue = Object.getOwnPropertyDescriptor(Node.prototype, "nodeValue");
	Object.defineProperty(Node.prototype, "nodeValue", {
		get() {
			return nativeNodeValue.get.apply(this);
		},
		set(text) {
			nativeNodeValue.set.apply(this, arguments);

			// Call manually the mutation observer callback
			const parentElement = this.parentNode;
			if (parentElement instanceof Element && typeof parentElement._processChildren === "function") {
				parentElement._processChildren();
			}
		}
	});
};

var iconFontTTF = "b4b3072255b9125b.ttf";

var iconFontWoff = "4954f2f3d3c66cd6.woff";

var iconFontWoff2 = "04525a240d4d16db.woff2";

/**
 * this file extracts the logic of the insertFontFaceStyle from "@openui5/sap.ui.core/dist/sap/ui/core/IconPool"
 * but adapted to use the ES6 asset import mechanism to avoid too many magic modifications in the original IconPool
 */

/**
 * CSS font family used for the icons provided by SAP.
 */
const SAP_ICON_FONT_FAMILY = 'SAP-icons';

class IconFonts {
	static load (sPath) {

		const fontFace = SAP_ICON_FONT_FAMILY;
		const assetPath = Core$1.getAssetPath();
		const woff2Location = assetPath + iconFontWoff2;
		const woffLocation = assetPath + iconFontWoff;
		const ttfLocation = assetPath + iconFontTTF;

		// load the font asynchronously via CSS
		const fontFaceCSS = "@font-face {" +
				"font-family: '" + fontFace + "';" +
				"src: url('" + woff2Location + "') format('woff2')," + /* Chrome 36+, Firefox 39+, Safari 10+, Edge 14+, Chrome 51+ for Android, PhantomJS 2.1.1+ */
				"url('" + woffLocation + "') format('woff')," + /* IE9+, Safari 5.1+, iOS 5.1+, Android Browser 4.4+, IE Mobile 11+ */
				"url('" + ttfLocation  + "') format('truetype')," + /* Fallback for any older browser (except IE8 and below which are not supported anyway) */
				"local('" + fontFace + "');" + /* fallback to local installed font in case it can't be loaded (e.g. font download is disabled due to browser security settings) */
				"font-weight: normal;" +
				"font-style: normal;" +
			"}";

		const style = document.createElement("style");
		style.type = "text/css";
		style.textContent = fontFaceCSS;
		document.head.appendChild(style);
	}
}

var mKeyCodes = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CONTROL: 17,
  ALT: 18,
  BREAK: 19,
  CAPS_LOCK: 20,
  ESCAPE: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  PRINT: 44,
  INSERT: 45,
  DELETE: 46,
  DIGIT_0: 48,
  DIGIT_1: 49,
  DIGIT_2: 50,
  DIGIT_3: 51,
  DIGIT_4: 52,
  DIGIT_5: 53,
  DIGIT_6: 54,
  DIGIT_7: 55,
  DIGIT_8: 56,
  DIGIT_9: 57,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  WINDOWS: 91,
  CONTEXT_MENU: 93,
  TURN_OFF: 94,
  SLEEP: 95,
  NUMPAD_0: 96,
  NUMPAD_1: 97,
  NUMPAD_2: 98,
  NUMPAD_3: 99,
  NUMPAD_4: 100,
  NUMPAD_5: 101,
  NUMPAD_6: 102,
  NUMPAD_7: 103,
  NUMPAD_8: 104,
  NUMPAD_9: 105,
  NUMPAD_ASTERISK: 106,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_COMMA: 110,
  NUMPAD_SLASH: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUM_LOCK: 144,
  SCROLL_LOCK: 145,
  OPEN_BRACKET: 186,
  PLUS: 187,
  COMMA: 188,
  SLASH: 189,
  DOT: 190,
  PIPE: 191,
  SEMICOLON: 192,
  MINUS: 219,
  GREAT_ACCENT: 220,
  EQUALS: 221,
  SINGLE_QUOTE: 222,
  BACKSLASH: 226
};

var PseudoEvents = {};
function checkModifierKeys(oEvent, bCtrlKey, bAltKey, bShiftKey) {
    return oEvent.shiftKey == bShiftKey && oEvent.altKey == bAltKey && getCtrlKey(oEvent) == bCtrlKey;
}
function hasModifierKeys(oEvent) {
    return oEvent.shiftKey || oEvent.altKey || getCtrlKey(oEvent);
}
function getCtrlKey(oEvent) {
    return !!(oEvent.metaKey || oEvent.ctrlKey);
}
PseudoEvents.events = {
    sapdown: {
        sName: 'sapdown',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowDown' || oEvent.key === 'Down' : oEvent.keyCode == mKeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
        }
    },
    sapdownmodifiers: {
        sName: 'sapdownmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowDown' || oEvent.key === 'Down' : oEvent.keyCode == mKeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
        }
    },
    sapshow: {
        sName: 'sapshow',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            if (oEvent.key) {
                return oEvent.key === 'F4' && !hasModifierKeys(oEvent) || (oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && checkModifierKeys(oEvent, false, true, false);
            }
            return oEvent.keyCode == mKeyCodes.F4 && !hasModifierKeys(oEvent) || oEvent.keyCode == mKeyCodes.ARROW_DOWN && checkModifierKeys(oEvent, false, true, false);
        }
    },
    sapup: {
        sName: 'sapup',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowUp' || oEvent.key === 'Up' : oEvent.keyCode == mKeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
        }
    },
    sapupmodifiers: {
        sName: 'sapupmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowUp' || oEvent.key === 'Up' : oEvent.keyCode == mKeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
        }
    },
    saphide: {
        sName: 'saphide',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowUp' || oEvent.key === 'Up' : oEvent.keyCode == mKeyCodes.ARROW_UP) && checkModifierKeys(oEvent, false, true, false);
        }
    },
    sapleft: {
        sName: 'sapleft',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' : oEvent.keyCode == mKeyCodes.ARROW_LEFT) && !hasModifierKeys(oEvent);
        }
    },
    sapleftmodifiers: {
        sName: 'sapleftmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' : oEvent.keyCode == mKeyCodes.ARROW_LEFT) && hasModifierKeys(oEvent);
        }
    },
    sapright: {
        sName: 'sapright',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowRight' || oEvent.key === 'Right' : oEvent.keyCode == mKeyCodes.ARROW_RIGHT) && !hasModifierKeys(oEvent);
        }
    },
    saprightmodifiers: {
        sName: 'saprightmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'ArrowRight' || oEvent.key === 'Right' : oEvent.keyCode == mKeyCodes.ARROW_RIGHT) && hasModifierKeys(oEvent);
        }
    },
    saphome: {
        sName: 'saphome',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Home' : oEvent.keyCode == mKeyCodes.HOME) && !hasModifierKeys(oEvent);
        }
    },
    saphomemodifiers: {
        sName: 'saphomemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Home' : oEvent.keyCode == mKeyCodes.HOME) && hasModifierKeys(oEvent);
        }
    },
    saptop: {
        sName: 'saptop',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Home' : oEvent.keyCode == mKeyCodes.HOME) && checkModifierKeys(oEvent, true, false, false);
        }
    },
    sapend: {
        sName: 'sapend',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'End' : oEvent.keyCode == mKeyCodes.END) && !hasModifierKeys(oEvent);
        }
    },
    sapendmodifiers: {
        sName: 'sapendmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'End' : oEvent.keyCode == mKeyCodes.END) && hasModifierKeys(oEvent);
        }
    },
    sapbottom: {
        sName: 'sapbottom',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'End' : oEvent.keyCode == mKeyCodes.END) && checkModifierKeys(oEvent, true, false, false);
        }
    },
    sappageup: {
        sName: 'sappageup',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'PageUp' : oEvent.keyCode == mKeyCodes.PAGE_UP) && !hasModifierKeys(oEvent);
        }
    },
    sappageupmodifiers: {
        sName: 'sappageupmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'PageUp' : oEvent.keyCode == mKeyCodes.PAGE_UP) && hasModifierKeys(oEvent);
        }
    },
    sappagedown: {
        sName: 'sappagedown',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'PageDown' : oEvent.keyCode == mKeyCodes.PAGE_DOWN) && !hasModifierKeys(oEvent);
        }
    },
    sappagedownmodifiers: {
        sName: 'sappagedownmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'PageDown' : oEvent.keyCode == mKeyCodes.PAGE_DOWN) && hasModifierKeys(oEvent);
        }
    },
    sapselect: {
        sName: 'sapselect',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            if (oEvent.key) {
                return (oEvent.key === 'Enter' || oEvent.key === 'Spacebar' || oEvent.key === ' ') && !hasModifierKeys(oEvent);
            }
            return (oEvent.keyCode == mKeyCodes.ENTER || oEvent.keyCode == mKeyCodes.SPACE) && !hasModifierKeys(oEvent);
        }
    },
    sapselectmodifiers: {
        sName: 'sapselectmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            if (oEvent.key) {
                return (oEvent.key === 'Enter' || oEvent.key === 'Spacebar' || oEvent.key === ' ') && hasModifierKeys(oEvent);
            }
            return (oEvent.keyCode == mKeyCodes.ENTER || oEvent.keyCode == mKeyCodes.SPACE) && hasModifierKeys(oEvent);
        }
    },
    sapspace: {
        sName: 'sapspace',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Spacebar' || oEvent.key === ' ' : oEvent.keyCode == mKeyCodes.SPACE) && !hasModifierKeys(oEvent);
        }
    },
    sapspacemodifiers: {
        sName: 'sapspacemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Spacebar' || oEvent.key === ' ' : oEvent.keyCode == mKeyCodes.SPACE) && hasModifierKeys(oEvent);
        }
    },
    sapenter: {
        sName: 'sapenter',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Enter' : oEvent.keyCode == mKeyCodes.ENTER) && !hasModifierKeys(oEvent);
        }
    },
    sapentermodifiers: {
        sName: 'sapentermodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Enter' : oEvent.keyCode == mKeyCodes.ENTER) && hasModifierKeys(oEvent);
        }
    },
    sapbackspace: {
        sName: 'sapbackspace',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Backspace' : oEvent.keyCode == mKeyCodes.BACKSPACE) && !hasModifierKeys(oEvent);
        }
    },
    sapbackspacemodifiers: {
        sName: 'sapbackspacemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Backspace' : oEvent.keyCode == mKeyCodes.BACKSPACE) && hasModifierKeys(oEvent);
        }
    },
    sapdelete: {
        sName: 'sapdelete',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Delete' || oEvent.key === 'Del' : oEvent.keyCode == mKeyCodes.DELETE) && !hasModifierKeys(oEvent);
        }
    },
    sapdeletemodifiers: {
        sName: 'sapdeletemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Delete' || oEvent.key === 'Del' : oEvent.keyCode == mKeyCodes.DELETE) && hasModifierKeys(oEvent);
        }
    },
    sapexpand: {
        sName: 'sapexpand',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? (oEvent.key === '+' || oEvent.key === 'Add') && oEvent.location === 'NUMPAD' : oEvent.keyCode == mKeyCodes.NUMPAD_PLUS) && !hasModifierKeys(oEvent);
        }
    },
    sapexpandmodifiers: {
        sName: 'sapexpandmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? (oEvent.key === '+' || oEvent.key === 'Add') && oEvent.location === 'NUMPAD' : oEvent.keyCode == mKeyCodes.NUMPAD_PLUS) && hasModifierKeys(oEvent);
        }
    },
    sapcollapse: {
        sName: 'sapcollapse',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? (oEvent.key === '-' || oEvent.key === 'Subtract') && oEvent.location === 'NUMPAD' : oEvent.keyCode == mKeyCodes.NUMPAD_MINUS) && !hasModifierKeys(oEvent);
        }
    },
    sapcollapsemodifiers: {
        sName: 'sapcollapsemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? (oEvent.key === '-' || oEvent.key === 'Subtract') && oEvent.location === 'NUMPAD' : oEvent.keyCode == mKeyCodes.NUMPAD_MINUS) && hasModifierKeys(oEvent);
        }
    },
    sapcollapseall: {
        sName: 'sapcollapseall',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? (oEvent.key === '*' || oEvent.key === 'Multiply') && oEvent.location === 'NUMPAD' : oEvent.keyCode == mKeyCodes.NUMPAD_ASTERISK) && !hasModifierKeys(oEvent);
        }
    },
    sapescape: {
        sName: 'sapescape',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Escape' || oEvent.key === 'Esc' : oEvent.keyCode == mKeyCodes.ESCAPE) && !hasModifierKeys(oEvent);
        }
    },
    saptabnext: {
        sName: 'saptabnext',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Tab' : oEvent.keyCode == mKeyCodes.TAB) && !hasModifierKeys(oEvent);
        }
    },
    saptabprevious: {
        sName: 'saptabprevious',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'Tab' : oEvent.keyCode == mKeyCodes.TAB) && checkModifierKeys(oEvent, false, false, true);
        }
    },
    sapskipforward: {
        sName: 'sapskipforward',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'F6' : oEvent.keyCode == mKeyCodes.F6) && !hasModifierKeys(oEvent);
        }
    },
    sapskipback: {
        sName: 'sapskipback',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            return (oEvent.key ? oEvent.key === 'F6' : oEvent.keyCode == mKeyCodes.F6) && checkModifierKeys(oEvent, false, false, true);
        }
    },
    sapdecrease: {
        sName: 'sapdecrease',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && !hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && !hasModifierKeys(oEvent);
                }
            }
            var iPreviousKey = bRtl ? mKeyCodes.ARROW_RIGHT : mKeyCodes.ARROW_LEFT;
            return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == mKeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
        }
    },
    sapminus: {
        sName: 'sapminus',
        aTypes: ['keypress'],
        fnCheck: function (oEvent) {
            return oEvent.key ? oEvent.key === '-' || oEvent.key === 'Subtract' : String.fromCharCode(oEvent.which) == '-';
        }
    },
    sapdecreasemodifiers: {
        sName: 'sapdecreasemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && hasModifierKeys(oEvent);
                }
            }
            var iPreviousKey = bRtl ? mKeyCodes.ARROW_RIGHT : mKeyCodes.ARROW_LEFT;
            return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == mKeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
        }
    },
    sapincrease: {
        sName: 'sapincrease',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            var iNextKey;
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && !hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && !hasModifierKeys(oEvent);
                }
            }
            iNextKey = bRtl ? mKeyCodes.ARROW_LEFT : mKeyCodes.ARROW_RIGHT;
            return (oEvent.keyCode == iNextKey || oEvent.keyCode == mKeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
        }
    },
    sapplus: {
        sName: 'sapplus',
        aTypes: ['keypress'],
        fnCheck: function (oEvent) {
            return oEvent.key ? oEvent.key === '+' || oEvent.key === 'Add' : String.fromCharCode(oEvent.which) == '+';
        }
    },
    sapincreasemodifiers: {
        sName: 'sapincreasemodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && hasModifierKeys(oEvent);
                }
            }
            var iNextKey = bRtl ? mKeyCodes.ARROW_LEFT : mKeyCodes.ARROW_RIGHT;
            return (oEvent.keyCode == iNextKey || oEvent.keyCode == mKeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
        }
    },
    sapprevious: {
        sName: 'sapprevious',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && !hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && !hasModifierKeys(oEvent);
                }
            }
            var iPreviousKey = bRtl ? mKeyCodes.ARROW_RIGHT : mKeyCodes.ARROW_LEFT;
            return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == mKeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
        }
    },
    sappreviousmodifiers: {
        sName: 'sappreviousmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowUp' || oEvent.key === 'Up') && hasModifierKeys(oEvent);
                }
            }
            var iPreviousKey = bRtl ? mKeyCodes.ARROW_RIGHT : mKeyCodes.ARROW_LEFT;
            return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == mKeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
        }
    },
    sapnext: {
        sName: 'sapnext',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && !hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && !hasModifierKeys(oEvent);
                }
            }
            var iNextKey = bRtl ? mKeyCodes.ARROW_LEFT : mKeyCodes.ARROW_RIGHT;
            return (oEvent.keyCode == iNextKey || oEvent.keyCode == mKeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
        }
    },
    sapnextmodifiers: {
        sName: 'sapnextmodifiers',
        aTypes: ['keydown'],
        fnCheck: function (oEvent) {
            var bRtl = sap.ui.getCore().getConfiguration().getRTL();
            if (oEvent.key) {
                if (bRtl) {
                    return (oEvent.key === 'ArrowLeft' || oEvent.key === 'Left' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && hasModifierKeys(oEvent);
                } else {
                    return (oEvent.key === 'ArrowRight' || oEvent.key === 'Right' || oEvent.key === 'ArrowDown' || oEvent.key === 'Down') && hasModifierKeys(oEvent);
                }
            }
            var iNextKey = bRtl ? mKeyCodes.ARROW_LEFT : mKeyCodes.ARROW_RIGHT;
            return (oEvent.keyCode == iNextKey || oEvent.keyCode == mKeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
        }
    },
    sapdelayeddoubleclick: {
        sName: 'sapdelayeddoubleclick',
        aTypes: ['click'],
        fnCheck: function (oEvent) {
            var element = oEvent.target;
            var currentTimestamp = oEvent.timeStamp;
            var data = element.dataset['sapdelayeddoubleclick_lastClickTimestamp'];
            var lastTimestamp = data || 0;
            element.dataset['sapdelayeddoubleclick_lastClickTimestamp'] = currentTimestamp;
            var diff = currentTimestamp - lastTimestamp;
            return diff >= 300 && diff <= 1300;
        }
    }
};
PseudoEvents.order = [
    'sapdown',
    'sapdownmodifiers',
    'sapshow',
    'sapup',
    'sapupmodifiers',
    'saphide',
    'sapleft',
    'sapleftmodifiers',
    'sapright',
    'saprightmodifiers',
    'saphome',
    'saphomemodifiers',
    'saptop',
    'sapend',
    'sapendmodifiers',
    'sapbottom',
    'sappageup',
    'sappageupmodifiers',
    'sappagedown',
    'sappagedownmodifiers',
    'sapselect',
    'sapselectmodifiers',
    'sapspace',
    'sapspacemodifiers',
    'sapenter',
    'sapentermodifiers',
    'sapexpand',
    'sapbackspace',
    'sapbackspacemodifiers',
    'sapdelete',
    'sapdeletemodifiers',
    'sapexpandmodifiers',
    'sapcollapse',
    'sapcollapsemodifiers',
    'sapcollapseall',
    'sapescape',
    'saptabnext',
    'saptabprevious',
    'sapskipforward',
    'sapskipback',
    'sapprevious',
    'sappreviousmodifiers',
    'sapnext',
    'sapnextmodifiers',
    'sapdecrease',
    'sapminus',
    'sapdecreasemodifiers',
    'sapincrease',
    'sapplus',
    'sapincreasemodifiers',
    'sapdelayeddoubleclick'
];
PseudoEvents.getBasicTypes = function () {
    var mEvents = PseudoEvents.events, aResult = [];
    for (var sName in mEvents) {
        if (mEvents[sName].aTypes) {
            for (var j = 0, js = mEvents[sName].aTypes.length; j < js; j++) {
                var sType = mEvents[sName].aTypes[j];
                if (aResult.indexOf(sType) == -1) {
                    aResult.push(sType);
                }
            }
        }
    }
    this.getBasicTypes = function () {
        return aResult.slice();
    };
    return aResult;
};
PseudoEvents.addEvent = function (oEvent) {
    PseudoEvents.events[oEvent.sName] = oEvent;
    PseudoEvents.order.push(oEvent.sName);
};

if (typeof window.sap !== "object" && typeof window.sap !== "function") {
  window.sap = {};
}
if (typeof window.sap.ui !== "object") {
  window.sap.ui = {};
}
(function () {
  if (typeof window.sap.ui.Device === "object" || typeof window.sap.ui.Device === "function") {
    var apiVersion = "${version}";
    window.sap.ui.Device._checkAPIVersion(apiVersion);
    return;
  }
  var Device = {};
  var FATAL = 0, ERROR = 1, WARNING = 2, INFO = 3, DEBUG = 4, TRACE = 5;
  var DeviceLogger = function () {
    function pad0(i, w) {
      return ("000" + String(i)).slice(-w);
    }
    this.defaultComponent = "DEVICE";
    this.sWindowName = window.top == window ? "" : "[" + window.location.pathname.split("/").slice(-1)[0] + "] ";
    this.log = function (iLevel, sMessage, sComponent) {
      sComponent = sComponent || this.defaultComponent || "";
      var oNow = new Date(), oLogEntry = {
        time: pad0(oNow.getHours(), 2) + ":" + pad0(oNow.getMinutes(), 2) + ":" + pad0(oNow.getSeconds(), 2),
        date: pad0(oNow.getFullYear(), 4) + "-" + pad0(oNow.getMonth() + 1, 2) + "-" + pad0(oNow.getDate(), 2),
        timestamp: oNow.getTime(),
        level: iLevel,
        message: sMessage || "",
        component: sComponent || ""
      };
      if (window.console) {
        var logText = oLogEntry.date + " " + oLogEntry.time + " " + this.sWindowName + oLogEntry.message + " - " + oLogEntry.component;
        switch (iLevel) {
          case FATAL:
          case ERROR:
            console.error(logText);
            break;
          case WARNING:
            console.warn(logText);
            break;
          case INFO:
            console.info ? console.info(logText) : console.log(logText);
            break;
          case DEBUG:
            console.debug ? console.debug(logText) : console.log(logText);
            break;
          case TRACE:
            console.trace ? console.trace(logText) : console.log(logText);
            break;
        }
      }
      return oLogEntry;
    };
  };
  var oLogger = new DeviceLogger();
  oLogger.log(INFO, "Device API logging initialized");
  Device._checkAPIVersion = function (sVersion) {
    var v = "${version}";
    if (v != sVersion) {
      oLogger.log(WARNING, "Device API version differs: " + v + " <-> " + sVersion);
    }
  };
  var mEventRegistry = {};
  function attachEvent(sEventId, fnFunction, oListener) {
    if (!mEventRegistry[sEventId]) {
      mEventRegistry[sEventId] = [];
    }
    mEventRegistry[sEventId].push({
      oListener: oListener,
      fFunction: fnFunction
    });
  }
  function detachEvent(sEventId, fnFunction, oListener) {
    var aEventListeners = mEventRegistry[sEventId];
    if (!aEventListeners) {
      return this;
    }
    for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
      if (aEventListeners[i].fFunction === fnFunction && aEventListeners[i].oListener === oListener) {
        aEventListeners.splice(i, 1);
        break;
      }
    }
    if (aEventListeners.length == 0) {
      delete mEventRegistry[sEventId];
    }
  }
  function fireEvent(sEventId, mParameters) {
    var aEventListeners = mEventRegistry[sEventId];
    var oInfo;
    if (aEventListeners) {
      aEventListeners = aEventListeners.slice();
      for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
        oInfo = aEventListeners[i];
        oInfo.fFunction.call(oInfo.oListener || window, mParameters);
      }
    }
  }
  var OS = {
    "WINDOWS": "win",
    "MACINTOSH": "mac",
    "LINUX": "linux",
    "IOS": "iOS",
    "ANDROID": "Android",
    "BLACKBERRY": "bb",
    "WINDOWS_PHONE": "winphone"
  };
  function getOS(userAgent) {
    userAgent = userAgent || navigator.userAgent;
    var rPlatform, aMatches;
    function getDesktopOS() {
      var sPlatform = navigator.platform;
      if (sPlatform.indexOf("Win") != -1) {
        var rVersion = /Windows NT (\d+).(\d)/i;
        var uaResult = userAgent.match(rVersion);
        var sVersionStr = "";
        if (uaResult[1] == "6") {
          if (uaResult[2] == 1) {
            sVersionStr = "7";
          } else if (uaResult[2] > 1) {
            sVersionStr = "8";
          }
        } else {
          sVersionStr = uaResult[1];
        }
        return {
          "name": OS.WINDOWS,
          "versionStr": sVersionStr
        };
      } else if (sPlatform.indexOf("Mac") != -1) {
        return {
          "name": OS.MACINTOSH,
          "versionStr": ""
        };
      } else if (sPlatform.indexOf("Linux") != -1) {
        return {
          "name": OS.LINUX,
          "versionStr": ""
        };
      }
      oLogger.log(INFO, "OS detection returned no result");
      return null;
    }
    rPlatform = /Windows Phone (?:OS )?([\d.]*)/;
    aMatches = userAgent.match(rPlatform);
    if (aMatches) {
      return {
        "name": OS.WINDOWS_PHONE,
        "versionStr": aMatches[1]
      };
    }
    if (userAgent.indexOf("(BB10;") > 0) {
      rPlatform = /\sVersion\/([\d.]+)\s/;
      aMatches = userAgent.match(rPlatform);
      if (aMatches) {
        return {
          "name": OS.BLACKBERRY,
          "versionStr": aMatches[1]
        };
      } else {
        return {
          "name": OS.BLACKBERRY,
          "versionStr": "10"
        };
      }
    }
    rPlatform = /\(([a-zA-Z ]+);\s(?:[U]?[;]?)([\D]+)((?:[\d._]*))(?:.*[\)][^\d]*)([\d.]*)\s/;
    aMatches = userAgent.match(rPlatform);
    if (aMatches) {
      var rAppleDevices = /iPhone|iPad|iPod/;
      var rBbDevices = /PlayBook|BlackBerry/;
      if (aMatches[0].match(rAppleDevices)) {
        aMatches[3] = aMatches[3].replace(/_/g, ".");
        return {
          "name": OS.IOS,
          "versionStr": aMatches[3]
        };
      } else if (aMatches[2].match(/Android/)) {
        aMatches[2] = aMatches[2].replace(/\s/g, "");
        return {
          "name": OS.ANDROID,
          "versionStr": aMatches[3]
        };
      } else if (aMatches[0].match(rBbDevices)) {
        return {
          "name": OS.BLACKBERRY,
          "versionStr": aMatches[4]
        };
      }
    }
    rPlatform = /\((Android)[\s]?([\d][.\d]*)?;.*Firefox\/[\d][.\d]*/;
    aMatches = userAgent.match(rPlatform);
    if (aMatches) {
      return {
        "name": OS.ANDROID,
        "versionStr": aMatches.length == 3 ? aMatches[2] : ""
      };
    }
    return getDesktopOS();
  }
  function setOS(customUA) {
    Device.os = getOS(customUA) || ({});
    Device.os.OS = OS;
    Device.os.version = Device.os.versionStr ? parseFloat(Device.os.versionStr) : -1;
    if (Device.os.name) {
      for (var name in OS) {
        if (OS[name] === Device.os.name) {
          Device.os[name.toLowerCase()] = true;
        }
      }
    }
  }
  setOS();
  Device._setOS = setOS;
  var BROWSER = {
    "INTERNET_EXPLORER": "ie",
    "EDGE": "ed",
    "FIREFOX": "ff",
    "CHROME": "cr",
    "SAFARI": "sf",
    "ANDROID": "an"
  };
  var ua = navigator.userAgent;
  function getBrowser(customUa, customNav) {
    function calcBrowser(customUa) {
      var sUserAgent = (customUa || ua).toLowerCase();
      var rwebkit = /(webkit)[ \/]([\w.]+)/;
      var ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/;
      var rmsie = /(msie) ([\w.]+)/;
      var rmsie11 = /(trident)\/[\w.]+;.*rv:([\w.]+)/;
      var redge = /(edge)[ \/]([\w.]+)/;
      var rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/;
      var browserMatch = redge.exec(sUserAgent) || rmsie11.exec(sUserAgent) || rwebkit.exec(sUserAgent) || ropera.exec(sUserAgent) || rmsie.exec(sUserAgent) || sUserAgent.indexOf("compatible") < 0 && rmozilla.exec(sUserAgent) || [];
      var oRes = {
        browser: browserMatch[1] || "",
        version: browserMatch[2] || "0"
      };
      oRes[oRes.browser] = true;
      return oRes;
    }
    var oBrowser = calcBrowser(customUa);
    var sUserAgent = customUa || ua;
    var oNavigator = customNav || window.navigator;
    var oExpMobile;
    var oResult;
    if (oBrowser.mozilla) {
      oExpMobile = /Mobile/;
      if (sUserAgent.match(/Firefox\/(\d+\.\d+)/)) {
        var fVersion = parseFloat(RegExp.$1);
        oResult = {
          name: BROWSER.FIREFOX,
          versionStr: "" + fVersion,
          version: fVersion,
          mozilla: true,
          mobile: oExpMobile.test(sUserAgent)
        };
      } else {
        oResult = {
          mobile: oExpMobile.test(sUserAgent),
          mozilla: true,
          version: -1
        };
      }
    } else if (oBrowser.webkit) {
      var regExpWebkitVersion = sUserAgent.toLowerCase().match(/webkit[\/]([\d.]+)/);
      var webkitVersion;
      if (regExpWebkitVersion) {
        webkitVersion = regExpWebkitVersion[1];
      }
      oExpMobile = /Mobile/;
      var aChromeMatch = sUserAgent.match(/(Chrome|CriOS)\/(\d+\.\d+).\d+/);
      var aFirefoxMatch = sUserAgent.match(/FxiOS\/(\d+\.\d+)/);
      var aAndroidMatch = sUserAgent.match(/Android .+ Version\/(\d+\.\d+)/);
      if (aChromeMatch || aFirefoxMatch || aAndroidMatch) {
        var sName, sVersion, bMobile;
        if (aChromeMatch) {
          sName = BROWSER.CHROME;
          bMobile = oExpMobile.test(sUserAgent);
          sVersion = parseFloat(aChromeMatch[2]);
        } else if (aFirefoxMatch) {
          sName = BROWSER.FIREFOX;
          bMobile = true;
          sVersion = parseFloat(aFirefoxMatch[1]);
        } else if (aAndroidMatch) {
          sName = BROWSER.ANDROID;
          bMobile = oExpMobile.test(sUserAgent);
          sVersion = parseFloat(aAndroidMatch[1]);
        }
        oResult = {
          name: sName,
          mobile: bMobile,
          versionStr: "" + sVersion,
          version: sVersion,
          webkit: true,
          webkitVersion: webkitVersion
        };
      } else {
        var oExp = /(Version|PhantomJS)\/(\d+\.\d+).*Safari/;
        var bStandalone = oNavigator.standalone;
        if (oExp.test(sUserAgent)) {
          var aParts = oExp.exec(sUserAgent);
          var fVersion = parseFloat(aParts[2]);
          oResult = {
            name: BROWSER.SAFARI,
            versionStr: "" + fVersion,
            fullscreen: false,
            webview: false,
            version: fVersion,
            mobile: oExpMobile.test(sUserAgent),
            webkit: true,
            webkitVersion: webkitVersion,
            phantomJS: aParts[1] === "PhantomJS"
          };
        } else if ((/iPhone|iPad|iPod/).test(sUserAgent) && !(/CriOS/).test(sUserAgent) && !(/FxiOS/).test(sUserAgent) && (bStandalone === true || bStandalone === false)) {
          oResult = {
            name: BROWSER.SAFARI,
            version: -1,
            fullscreen: bStandalone,
            webview: !bStandalone,
            mobile: oExpMobile.test(sUserAgent),
            webkit: true,
            webkitVersion: webkitVersion
          };
        } else {
          oResult = {
            mobile: oExpMobile.test(sUserAgent),
            webkit: true,
            webkitVersion: webkitVersion,
            version: -1
          };
        }
      }
    } else if (oBrowser.msie || oBrowser.trident) {
      var fVersion;
      if (document.documentMode && !customUa) {
        if (document.documentMode === 7) {
          fVersion = 8;
        } else {
          fVersion = parseFloat(document.documentMode);
        }
      } else {
        fVersion = parseFloat(oBrowser.version);
      }
      oResult = {
        name: BROWSER.INTERNET_EXPLORER,
        versionStr: "" + fVersion,
        version: fVersion,
        msie: true,
        mobile: false
      };
    } else if (oBrowser.edge) {
      var fVersion = fVersion = parseFloat(oBrowser.version);
      oResult = {
        name: BROWSER.EDGE,
        versionStr: "" + fVersion,
        version: fVersion,
        edge: true
      };
    } else {
      oResult = {
        name: "",
        versionStr: "",
        version: -1,
        mobile: false
      };
    }
    if ((((oBrowser.chrome || window.Intl && window.Intl.v8BreakIterator) && "CSS") in window)) {
      oResult.blink = true;
    }
    return oResult;
  }
  Device._testUserAgent = getBrowser;
  function setBrowser() {
    Device.browser = getBrowser();
    Device.browser.BROWSER = BROWSER;
    if (Device.browser.name) {
      for (var b in BROWSER) {
        if (BROWSER[b] === Device.browser.name) {
          Device.browser[b.toLowerCase()] = true;
        }
      }
    }
  }
  setBrowser();
  Device.support = {};
  Device.support.touch = !!(("ontouchstart" in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
  if (Device.browser.phantomJS) {
    Device.support.touch = false;
  }
  Device.support.pointer = !!window.PointerEvent;
  Device.support.matchmedia = !!window.matchMedia;
  var m = Device.support.matchmedia ? window.matchMedia("all and (max-width:0px)") : null;
  Device.support.matchmedialistener = !!(m && m.addListener);
  Device.support.orientation = !!(((("orientation" in window) && "onorientationchange") in window));
  Device.support.retina = window.retina || window.devicePixelRatio >= 2;
  Device.support.websocket = ("WebSocket" in window);
  Device.support.input = {};
  Device.support.input.placeholder = ("placeholder" in document.createElement("input"));
  Device.media = {};
  var RANGESETS = {
    "SAP_3STEPS": "3Step",
    "SAP_4STEPS": "4Step",
    "SAP_6STEPS": "6Step",
    "SAP_STANDARD": "Std",
    "SAP_STANDARD_EXTENDED": "StdExt"
  };
  Device.media.RANGESETS = RANGESETS;
  Device.media._predefinedRangeSets = {};
  Device.media._predefinedRangeSets[RANGESETS.SAP_3STEPS] = {
    points: [520, 960],
    unit: "px",
    name: RANGESETS.SAP_3STEPS,
    names: ["S", "M", "L"]
  };
  Device.media._predefinedRangeSets[RANGESETS.SAP_4STEPS] = {
    points: [520, 760, 960],
    unit: "px",
    name: RANGESETS.SAP_4STEPS,
    names: ["S", "M", "L", "XL"]
  };
  Device.media._predefinedRangeSets[RANGESETS.SAP_6STEPS] = {
    points: [241, 400, 541, 768, 960],
    unit: "px",
    name: RANGESETS.SAP_6STEPS,
    names: ["XS", "S", "M", "L", "XL", "XXL"]
  };
  Device.media._predefinedRangeSets[RANGESETS.SAP_STANDARD] = {
    points: [600, 1024],
    unit: "px",
    name: RANGESETS.SAP_STANDARD,
    names: ["Phone", "Tablet", "Desktop"]
  };
  Device.media._predefinedRangeSets[RANGESETS.SAP_STANDARD_EXTENDED] = {
    points: [600, 1024, 1440],
    unit: "px",
    name: RANGESETS.SAP_STANDARD_EXTENDED,
    names: ["Phone", "Tablet", "Desktop", "LargeDesktop"]
  };
  var _defaultRangeSet = RANGESETS.SAP_STANDARD;
  var iMediaTimeout = Device.support.matchmedialistener ? 0 : 100;
  var oQuerySets = {};
  var iMediaCurrentWidth = null;
  function getQuery(iFrom, iTo, iUnit) {
    iUnit = iUnit || "px";
    var sQuery = "all";
    if (iFrom > 0) {
      sQuery = sQuery + " and (min-width:" + iFrom + iUnit + ")";
    }
    if (iTo > 0) {
      sQuery = sQuery + " and (max-width:" + iTo + iUnit + ")";
    }
    return sQuery;
  }
  function handleChange(sName) {
    if (!Device.support.matchmedialistener && iMediaCurrentWidth == windowSize()[0]) {
      return;
    }
    if (oQuerySets[sName].timer) {
      clearTimeout(oQuerySets[sName].timer);
      oQuerySets[sName].timer = null;
    }
    oQuerySets[sName].timer = setTimeout(function () {
      var mParams = checkQueries(sName, false);
      if (mParams) {
        fireEvent("media_" + sName, mParams);
      }
    }, iMediaTimeout);
  }
  function checkQueries(sName, bInfoOnly, fnMatches) {
    function getRangeInfo(sSetName, iRangeIdx) {
      var q = oQuerySets[sSetName].queries[iRangeIdx];
      var info = {
        from: q.from,
        unit: oQuerySets[sSetName].unit
      };
      if (q.to >= 0) {
        info.to = q.to;
      }
      if (oQuerySets[sSetName].names) {
        info.name = oQuerySets[sSetName].names[iRangeIdx];
      }
      return info;
    }
    fnMatches = fnMatches || Device.media.matches;
    if (oQuerySets[sName]) {
      var aQueries = oQuerySets[sName].queries;
      var info = null;
      for (var i = 0, len = aQueries.length; i < len; i++) {
        var q = aQueries[i];
        if ((q != oQuerySets[sName].currentquery || bInfoOnly) && fnMatches(q.from, q.to, oQuerySets[sName].unit)) {
          if (!bInfoOnly) {
            oQuerySets[sName].currentquery = q;
          }
          if (!oQuerySets[sName].noClasses && oQuerySets[sName].names && !bInfoOnly) {
            refreshCSSClasses(sName, oQuerySets[sName].names[i]);
          }
          info = getRangeInfo(sName, i);
        }
      }
      return info;
    }
    oLogger.log(WARNING, "No queryset with name " + sName + " found", "DEVICE.MEDIA");
    return null;
  }
  function refreshCSSClasses(sSetName, sRangeName, bRemove) {
    var sClassPrefix = "sapUiMedia-" + sSetName + "-";
    changeRootCSSClass(sClassPrefix + sRangeName, bRemove, sClassPrefix);
  }
  function changeRootCSSClass(sClassName, bRemove, sPrefix) {
    var oRoot = document.documentElement;
    if (oRoot.className.length == 0) {
      if (!bRemove) {
        oRoot.className = sClassName;
      }
    } else {
      var aCurrentClasses = oRoot.className.split(" ");
      var sNewClasses = "";
      for (var i = 0; i < aCurrentClasses.length; i++) {
        if (sPrefix && aCurrentClasses[i].indexOf(sPrefix) != 0 || !sPrefix && aCurrentClasses[i] != sClassName) {
          sNewClasses = sNewClasses + aCurrentClasses[i] + " ";
        }
      }
      if (!bRemove) {
        sNewClasses = sNewClasses + sClassName;
      }
      oRoot.className = sNewClasses;
    }
  }
  function windowSize() {
    return [window.innerWidth, window.innerHeight];
  }
  function matchLegacyBySize(iFrom, iTo, sUnit, iSize) {
    function convertToPx(iValue, sUnit) {
      if (sUnit === "em" || sUnit === "rem") {
        var fnGetStyle = window.getComputedStyle || (function (e) {
          return e.currentStyle;
        });
        var iFontSize = fnGetStyle(document.documentElement).fontSize;
        var iFactor = iFontSize && iFontSize.indexOf("px") >= 0 ? parseFloat(iFontSize, 10) : 16;
        return iValue * iFactor;
      }
      return iValue;
    }
    iFrom = convertToPx(iFrom, sUnit);
    iTo = convertToPx(iTo, sUnit);
    var width = iSize[0];
    var a = iFrom < 0 || iFrom <= width;
    var b = iTo < 0 || width <= iTo;
    return a && b;
  }
  function matchLegacy(iFrom, iTo, sUnit) {
    return matchLegacyBySize(iFrom, iTo, sUnit, windowSize());
  }
  function match(iFrom, iTo, sUnit) {
    var oQuery = getQuery(iFrom, iTo, sUnit);
    var mm = window.matchMedia(oQuery);
    return mm && mm.matches;
  }
  Device.media.matches = Device.support.matchmedia ? match : matchLegacy;
  Device.media.attachHandler = function (fnFunction, oListener, sName) {
    var name = sName || _defaultRangeSet;
    attachEvent("media_" + name, fnFunction, oListener);
  };
  Device.media.detachHandler = function (fnFunction, oListener, sName) {
    var name = sName || _defaultRangeSet;
    detachEvent("media_" + name, fnFunction, oListener);
  };
  Device.media.initRangeSet = function (sName, aRangeBorders, sUnit, aRangeNames, bSuppressClasses) {
    var oConfig;
    if (!sName) {
      oConfig = Device.media._predefinedRangeSets[_defaultRangeSet];
    } else if (sName && Device.media._predefinedRangeSets[sName]) {
      oConfig = Device.media._predefinedRangeSets[sName];
    } else {
      oConfig = {
        name: sName,
        unit: (sUnit || "px").toLowerCase(),
        points: aRangeBorders || [],
        names: aRangeNames,
        noClasses: !!bSuppressClasses
      };
    }
    if (Device.media.hasRangeSet(oConfig.name)) {
      oLogger.log(INFO, "Range set " + oConfig.name + " has already been initialized", "DEVICE.MEDIA");
      return;
    }
    sName = oConfig.name;
    oConfig.queries = [];
    oConfig.timer = null;
    oConfig.currentquery = null;
    oConfig.listener = function () {
      return handleChange(sName);
    };
    var from, to, query;
    var aPoints = oConfig.points;
    for (var i = 0, len = aPoints.length; i <= len; i++) {
      from = i == 0 ? 0 : aPoints[i - 1];
      to = i == aPoints.length ? -1 : aPoints[i];
      query = getQuery(from, to, oConfig.unit);
      oConfig.queries.push({
        query: query,
        from: from,
        to: to
      });
    }
    if (oConfig.names && oConfig.names.length != oConfig.queries.length) {
      oConfig.names = null;
    }
    oQuerySets[oConfig.name] = oConfig;
    if (Device.support.matchmedialistener) {
      oConfig.queries.forEach(function (oQuery) {
        oQuery.media = window.matchMedia(oQuery.query);
        oQuery.media.addListener(oConfig.listener);
      });
    } else {
      window.addEventListener("resize", oConfig.listener, false);
      window.addEventListener("orientationchange", oConfig.listener, false);
    }
    oConfig.listener();
  };
  Device.media.getCurrentRange = function (sName, iWidth) {
    if (!Device.media.hasRangeSet(sName)) {
      return null;
    }
    return checkQueries(sName, true, isNaN(iWidth) ? null : function (from, to, unit) {
      return matchLegacyBySize(from, to, unit, [iWidth, 0]);
    });
  };
  Device.media.hasRangeSet = function (sName) {
    return sName && !!oQuerySets[sName];
  };
  Device.media.removeRangeSet = function (sName) {
    if (!Device.media.hasRangeSet(sName)) {
      oLogger.log(INFO, "RangeSet " + sName + " not found, thus could not be removed.", "DEVICE.MEDIA");
      return;
    }
    for (var x in RANGESETS) {
      if (sName === RANGESETS[x]) {
        oLogger.log(WARNING, "Cannot remove default rangeset - no action taken.", "DEVICE.MEDIA");
        return;
      }
    }
    var oConfig = oQuerySets[sName];
    if (Device.support.matchmedialistener) {
      var queries = oConfig.queries;
      for (var i = 0; i < queries.length; i++) {
        queries[i].media.removeListener(oConfig.listener);
      }
    } else {
      window.removeEventListener("resize", oConfig.listener, false);
      window.removeEventListener("orientationchange", oConfig.listener, false);
    }
    refreshCSSClasses(sName, "", true);
    delete mEventRegistry["media_" + sName];
    delete oQuerySets[sName];
  };
  var SYSTEMTYPE = {
    "TABLET": "tablet",
    "PHONE": "phone",
    "DESKTOP": "desktop",
    "COMBI": "combi"
  };
  Device.system = {};
  function getSystem(simMobileOnDesktop, customUA) {
    var bTabletDetected = isTablet(customUA);
    var isWin8Upwards = Device.os.windows && Device.os.version >= 8;
    var isWin7 = Device.os.windows && Device.os.version === 7;
    var oSystem = {};
    oSystem.tablet = !!((Device.support.touch && !isWin7 || isWin8Upwards || !!simMobileOnDesktop) && bTabletDetected);
    oSystem.phone = !!(Device.os.windows_phone || (Device.support.touch && !isWin7 || !!simMobileOnDesktop) && !bTabletDetected);
    oSystem.desktop = !!(!oSystem.tablet && !oSystem.phone || isWin8Upwards || isWin7 || Device.os.linux);
    oSystem.combi = oSystem.desktop && oSystem.tablet;
    oSystem.SYSTEMTYPE = SYSTEMTYPE;
    for (var type in SYSTEMTYPE) {
      changeRootCSSClass("sap-" + SYSTEMTYPE[type], !oSystem[SYSTEMTYPE[type]]);
    }
    return oSystem;
  }
  function isTablet(customUA) {
    var sUserAgent = customUA || navigator.userAgent;
    if (Device.os.name === Device.os.OS.IOS) {
      return (/ipad/i).test(sUserAgent);
    } else {
      if (Device.support.touch) {
        if (Device.os.windows && Device.os.version >= 8) {
          return true;
        }
        if (Device.browser.chrome && Device.os.android && Device.os.version >= 4.4) {
          return !(/Mobile Safari\/[.0-9]+/).test(sUserAgent);
        } else {
          var densityFactor = window.devicePixelRatio ? window.devicePixelRatio : 1;
          if (Device.os.android && Device.browser.webkit && parseFloat(Device.browser.webkitVersion) > 537.1) {
            densityFactor = 1;
          }
          var bTablet = Math.min(window.screen.width / densityFactor, window.screen.height / densityFactor) >= 600;
          if (isLandscape() && (window.screen.height === 552 || window.screen.height === 553) && (/Nexus 7/i).test(sUserAgent)) {
            bTablet = true;
          }
          return bTablet;
        }
      } else {
        var bAndroidPhone = (/(?=android)(?=.*mobile)/i).test(sUserAgent);
        return Device.browser.msie && sUserAgent.indexOf("Touch") !== -1 || Device.os.android && !bAndroidPhone;
      }
    }
  }
  function setSystem(simMobileOnDesktop, customUA) {
    Device.system = getSystem(simMobileOnDesktop, customUA);
    if (Device.system.tablet || Device.system.phone) {
      Device.browser.mobile = true;
    }
  }
  setSystem();
  Device._getSystem = getSystem;
  Device.orientation = {};
  Device.resize = {};
  Device.orientation.attachHandler = function (fnFunction, oListener) {
    attachEvent("orientation", fnFunction, oListener);
  };
  Device.resize.attachHandler = function (fnFunction, oListener) {
    attachEvent("resize", fnFunction, oListener);
  };
  Device.orientation.detachHandler = function (fnFunction, oListener) {
    detachEvent("orientation", fnFunction, oListener);
  };
  Device.resize.detachHandler = function (fnFunction, oListener) {
    detachEvent("resize", fnFunction, oListener);
  };
  function setOrientationInfo(oInfo) {
    oInfo.landscape = isLandscape(true);
    oInfo.portrait = !oInfo.landscape;
  }
  function handleOrientationChange() {
    setOrientationInfo(Device.orientation);
    fireEvent("orientation", {
      landscape: Device.orientation.landscape
    });
  }
  function handleResizeChange() {
    setResizeInfo(Device.resize);
    fireEvent("resize", {
      height: Device.resize.height,
      width: Device.resize.width
    });
  }
  function setResizeInfo(oInfo) {
    oInfo.width = windowSize()[0];
    oInfo.height = windowSize()[1];
  }
  function handleOrientationResizeChange() {
    var wasL = Device.orientation.landscape;
    var isL = isLandscape();
    if (wasL != isL) {
      handleOrientationChange();
    }
    if (!iResizeTimeout) {
      iResizeTimeout = window.setTimeout(handleResizeTimeout, 150);
    }
  }
  function handleResizeTimeout() {
    handleResizeChange();
    iResizeTimeout = null;
  }
  var bOrientationchange = false;
  var bResize = false;
  var iOrientationTimeout;
  var iResizeTimeout;
  var iClearFlagTimeout;
  var iWindowHeightOld = windowSize()[1];
  var iWindowWidthOld = windowSize()[0];
  var bKeyboardOpen = false;
  var iLastResizeTime;
  var rInputTagRegex = /INPUT|TEXTAREA|SELECT/;
  var bSkipFirstResize = Device.os.ios && Device.browser.name === "sf" && (Device.system.phone && Device.os.version >= 7 && Device.os.version < 7.1 || Device.system.tablet && Device.os.version >= 7);
  function isLandscape(bFromOrientationChange) {
    if (Device.support.touch && Device.support.orientation && Device.os.android) {
      if (bKeyboardOpen && bFromOrientationChange) {
        return !Device.orientation.landscape;
      }
      if (bKeyboardOpen) {
        return Device.orientation.landscape;
      }
    } else if (Device.support.matchmedia && Device.support.orientation) {
      return !!window.matchMedia("(orientation: landscape)").matches;
    }
    var size = windowSize();
    return size[0] > size[1];
  }
  function handleMobileOrientationResizeChange(evt) {
    if (evt.type == "resize") {
      if (bSkipFirstResize && rInputTagRegex.test(document.activeElement.tagName) && !bOrientationchange) {
        return;
      }
      var iWindowHeightNew = windowSize()[1];
      var iWindowWidthNew = windowSize()[0];
      var iTime = new Date().getTime();
      if (iWindowHeightNew === iWindowHeightOld && iWindowWidthNew === iWindowWidthOld) {
        return;
      }
      bResize = true;
      if (iWindowHeightOld != iWindowHeightNew && iWindowWidthOld == iWindowWidthNew) {
        if (!iLastResizeTime || iTime - iLastResizeTime > 300) {
          bKeyboardOpen = iWindowHeightNew < iWindowHeightOld;
        }
        handleResizeChange();
      } else {
        iWindowWidthOld = iWindowWidthNew;
      }
      iLastResizeTime = iTime;
      iWindowHeightOld = iWindowHeightNew;
      if (iClearFlagTimeout) {
        window.clearTimeout(iClearFlagTimeout);
        iClearFlagTimeout = null;
      }
      iClearFlagTimeout = window.setTimeout(clearFlags, 1200);
    } else if (evt.type == "orientationchange") {
      bOrientationchange = true;
    }
    if (iOrientationTimeout) {
      clearTimeout(iOrientationTimeout);
      iOrientationTimeout = null;
    }
    iOrientationTimeout = window.setTimeout(handleMobileTimeout, 50);
  }
  function handleMobileTimeout() {
    if (bResize && (bOrientationchange || Device.system.tablet && Device.os.ios && Device.os.version >= 9)) {
      handleOrientationChange();
      handleResizeChange();
      bOrientationchange = false;
      bResize = false;
      if (iClearFlagTimeout) {
        window.clearTimeout(iClearFlagTimeout);
        iClearFlagTimeout = null;
      }
    }
    iOrientationTimeout = null;
  }
  function clearFlags() {
    bOrientationchange = false;
    bResize = false;
    iClearFlagTimeout = null;
  }
  Device._update = function (simMobileOnDesktop) {
    ua = navigator.userAgent;
    oLogger.log(WARNING, "Device API values manipulated: NOT PRODUCTIVE FEATURE!!! This should be only used for test purposes. Only use if you know what you are doing.");
    setBrowser();
    setOS();
    setSystem(simMobileOnDesktop);
  };
  setResizeInfo(Device.resize);
  setOrientationInfo(Device.orientation);
  window.sap.ui.Device = Device;
  if (Device.support.touch && Device.support.orientation) {
    window.addEventListener("resize", handleMobileOrientationResizeChange, false);
    window.addEventListener("orientationchange", handleMobileOrientationResizeChange, false);
  } else {
    window.addEventListener("resize", handleOrientationResizeChange, false);
  }
  Device.media.initRangeSet();
  Device.media.initRangeSet(RANGESETS["SAP_STANDARD_EXTENDED"]);
  if (window.define) {
    sap.ui.define("sap/ui/Device", [], function () {
      return Device;
    });
  }
})();
var Device = window.sap.ui.Device;

/**
 @license
 Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * @fileoverview
 *
 * This module provides a number of strategies for enqueuing asynchronous
 * tasks. Each sub-module provides a standard `run(fn)` interface that returns a
 * handle, and a `cancel(handle)` interface for canceling async tasks before
 * they run.
 *
 * @summary Module that provides a number of strategies for enqueuing
 * asynchronous tasks.
 */


// Microtask implemented using Mutation Observer
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

function microtaskFlush() {
	const len = microtaskCallbacks.length;
	for (let i = 0; i < len; i++) {
		let cb = microtaskCallbacks[i];
		if (cb) {
			try {
				cb();
			} catch (e) {
				setTimeout(() => { throw e; });
			}
		}
	}
	microtaskCallbacks.splice(0, len);
	microtaskLastHandle += len;
}

/**
 * Async interface wrapper around `setTimeout`.
 *
 * @namespace
 * @summary Async interface wrapper around `setTimeout`.
 */
const timeOut = {
	/**
	 * Returns a sub-module with the async interface providing the provided
	 * delay.
	 *
	 * @memberof timeOut
	 * @param {number=} delay Time to wait before calling callbacks in ms
	 * @return {!AsyncInterface} An async timeout interface
	 */
	after(delay) {
		return {
			run(fn) { return window.setTimeout(fn, delay); },
			cancel(handle) {
				window.clearTimeout(handle);
			}
		};
	},
	/**
	 * Enqueues a function called in the next task.
	 *
	 * @memberof timeOut
	 * @param {!Function} fn Callback to run
	 * @param {number=} delay Delay in milliseconds
	 * @return {number} Handle used for canceling task
	 */
	run(fn, delay) {
		return window.setTimeout(fn, delay);
	},
	/**
	 * Cancels a previously enqueued `timeOut` callback.
	 *
	 * @memberof timeOut
	 * @param {number} handle Handle returned from `run` of callback to cancel
	 * @return {void}
	 */
	cancel(handle) {
		window.clearTimeout(handle);
	}
};


/**
 * Async interface wrapper around `requestAnimationFrame`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestAnimationFrame`.
 */
const animationFrame = {
	/**
	 * Enqueues a function called at `requestAnimationFrame` timing.
	 *
	 * @memberof animationFrame
	 * @param {function(number):void} fn Callback to run
	 * @return {number} Handle used for canceling task
	 */
	run(fn) {
		return window.requestAnimationFrame(fn);
	},
	/**
	 * Cancels a previously enqueued `animationFrame` callback.
	 *
	 * @memberof animationFrame
	 * @param {number} handle Handle returned from `run` of callback to cancel
	 * @return {void}
	 */
	cancel(handle) {
		window.cancelAnimationFrame(handle);
	}
};

/**
 * Async interface wrapper around `requestIdleCallback`.  Falls back to
 * `setTimeout` on browsers that do not support `requestIdleCallback`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestIdleCallback`.
 */
const idlePeriod = {
	/**
	 * Enqueues a function called at `requestIdleCallback` timing.
	 *
	 * @memberof idlePeriod
	 * @param {function(!IdleDeadline):void} fn Callback to run
	 * @return {number} Handle used for canceling task
	 */
	run(fn) {
		return window.requestIdleCallback ?
			window.requestIdleCallback(fn) :
			window.setTimeout(fn, 16);
	},
	/**
	 * Cancels a previously enqueued `idlePeriod` callback.
	 *
	 * @memberof idlePeriod
	 * @param {number} handle Handle returned from `run` of callback to cancel
	 * @return {void}
	 */
	cancel(handle) {
		window.cancelIdleCallback ?
			window.cancelIdleCallback(handle) :
			window.clearTimeout(handle);
	}
};

/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */
const microTask = {

	/**
	 * Enqueues a function called at microtask timing.
	 *
	 * @memberof microTask
	 * @param {!Function=} callback Callback to run
	 * @return {number} Handle used for canceling task
	 */
	run(callback) {
		microtaskNode.textContent = microtaskNodeContent++;
		microtaskCallbacks.push(callback);
		return microtaskCurrHandle++;
	},

	/**
	 * Cancels a previously enqueued `microTask` callback.
	 *
	 * @memberof microTask
	 * @param {number} handle Handle returned from `run` of callback to cancel
	 * @return {void}
	 */
	cancel(handle) {
		const idx = handle - microtaskLastHandle;
		if (idx >= 0) {
			if (!microtaskCallbacks[idx]) {
				throw new Error('invalid async handle: ' + handle);
			}
			microtaskCallbacks[idx] = null;
		}
	}

};

var Async = {
	timeOut: timeOut,
	animationFrame: animationFrame,
	idlePeriod: idlePeriod,
	microTask: microTask
};

/**
 @license
 Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 */
class Debouncer {
	constructor() {
		this._asyncModule = null;
		this._callback = null;
		this._timer = null;
	}
	/**
	 * Sets the scheduler; that is, a module with the Async interface,
	 * a callback and optional arguments to be passed to the run function
	 * from the async module.
	 *
	 * @param {!AsyncInterface} asyncModule Object with Async interface.
	 * @param {function()} callback Callback to run.
	 * @return {void}
	 */
	setConfig(asyncModule, callback) {
		this._asyncModule = asyncModule;
		this._callback = callback;
		this._timer = this._asyncModule.run(() => {
			this._timer = null;
			this._callback();
		});
	}
	/**
	 * Cancels an active debouncer and returns a reference to itself.
	 *
	 * @return {void}
	 */
	cancel() {
		if (this.isActive()) {
			this._asyncModule.cancel(/** @type {number} */(this._timer));
			this._timer = null;
		}
	}
	/**
	 * Flushes an active debouncer and returns a reference to itself.
	 *
	 * @return {void}
	 */
	flush() {
		if (this.isActive()) {
			this.cancel();
			this._callback();
		}
	}
	/**
	 * Returns true if the debouncer is active.
	 *
	 * @return {boolean} True if active.
	 */
	isActive() {
		return this._timer != null;
	}
	/**
	 * Creates a debouncer if no debouncer is passed as a parameter
	 * or it cancels an active debouncer otherwise. The following
	 * example shows how a debouncer can be called multiple times within a
	 * microtask and "debounced" such that the provided callback function is
	 * called once. Add this method to a custom element:
	 *
	 * ```js
	 * import {microTask} from '@polymer/polymer/lib/utils/async.js';
	 * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
	 * // ...
	 *
	 * _debounceWork() {
 *   this._debounceJob = Debouncer.debounce(this._debounceJob,
 *       microTask, () => this._doWork());
 * }
	 * ```
	 *
	 * If the `_debounceWork` method is called multiple times within the same
	 * microtask, the `_doWork` function will be called only once at the next
	 * microtask checkpoint.
	 *
	 * Note: In testing it is often convenient to avoid asynchrony. To accomplish
	 * this with a debouncer, you can use `enqueueDebouncer` and
	 * `flush`. For example, extend the above example by adding
	 * `enqueueDebouncer(this._debounceJob)` at the end of the
	 * `_debounceWork` method. Then in a test, call `flush` to ensure
	 * the debouncer has completed.
	 *
	 * @param {Debouncer?} debouncer Debouncer object.
	 * @param {!AsyncInterface} asyncModule Object with Async interface
	 * @param {function()} callback Callback to run.
	 * @return {!Debouncer} Returns a debouncer object.
	 */
	static debounce(debouncer, asyncModule, callback) {
		if (debouncer instanceof Debouncer) {
			debouncer.cancel();
		} else {
			debouncer = new Debouncer();
		}
		debouncer.setConfig(asyncModule, callback);
		return debouncer;
	}
}

/**
 @license
 Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * @fileoverview
 *
 * Module for adding listeners to a node for the following normalized
 * cross-platform "gesture" events:
 * - `down` - mouse or touch went down
 * - `up` - mouse or touch went up
 * - `tap` - mouse click or finger tap
 * - `track` - mouse drag or touch move
 *
 * @summary Module for adding cross-platform gesture event listeners.
 */

const timeOut$1 = Async.timeOut;
const microTask$1 = Async.microTask;

const passiveTouchGestures = true;

// detect native touch action support
let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
// number of last N track positions to keep
let TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
let MOUSE_HAS_BUTTONS = (function () {
	try {
		return new MouseEvent('test', { buttons: 1 }).buttons === 1;
	} catch (e) {
		return false;
	}
})();

/**
 * @param {string} name Possible mouse event name
 * @return {boolean} true if mouse event, false if not
 */
function isMouseEvent(name) {
	return MOUSE_EVENTS.indexOf(name) > -1;
}

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
let SUPPORTS_PASSIVE = false;
(function () {
	try {
		let opts = Object.defineProperty({}, 'passive', { get() { SUPPORTS_PASSIVE = true; } });
		window.addEventListener('test', null, opts);
		window.removeEventListener('test', null, opts);
	} catch (e) { }
})();

/**
 * Generate settings for event listeners, dependant on `passiveTouchGestures`
 *
 * @param {string} eventName Event name to determine if `{passive}` option is
 *   needed
 * @return {{passive: boolean} | undefined} Options to use for addEventListener
 *   and removeEventListener
 */
function PASSIVE_TOUCH(eventName) {
	if (isMouseEvent(eventName) || eventName === 'touchend') {
		return;
	}
	if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {
		return { passive: true };
	} else {
		return;
	}
}

// Check for touch-only devices
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

// keep track of any labels hit by the mouseCanceller
/** @type {!Array<!HTMLLabelElement>} */
const clickedLabels = [];

/** @type {!Object<boolean>} */
const labellable = {
	'button': true,
	'input': true,
	'keygen': true,
	'meter': true,
	'output': true,
	'textarea': true,
	'progress': true,
	'select': true
};

// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute
/** @type {!Object<boolean>} */
const canBeDisabled = {
	'button': true,
	'command': true,
	'fieldset': true,
	'input': true,
	'keygen': true,
	'optgroup': true,
	'option': true,
	'select': true,
	'textarea': true
};

/**
 * @param {HTMLElement} el Element to check labelling status
 * @return {boolean} element can have labels
 */
function canBeLabelled(el) {
	return labellable[el.localName] || false;
}

/**
 * @param {HTMLElement} el Element that may be labelled.
 * @return {!Array<!HTMLLabelElement>} Relevant label for `el`
 */
function matchingLabels(el) {
	let labels = Array.prototype.slice.call(/** @type {HTMLInputElement} */(el).labels || []);
	// IE doesn't have `labels` and Safari doesn't populate `labels`
	// if element is in a shadowroot.
	// In this instance, finding the non-ancestor labels is enough,
	// as the mouseCancellor code will handle ancstor labels
	if (!labels.length) {
		labels = [];
		let root = el.getRootNode();
		// if there is an id on `el`, check for all labels with a matching `for` attribute
		if (el.id) {
			let matching = root.querySelectorAll(`label[for = ${el.id}]`);
			for (let i = 0; i < matching.length; i++) {
				labels.push(/** @type {!HTMLLabelElement} */(matching[i]));
			}
		}
	}
	return labels;
}

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
let mouseCanceller = function (mouseEvent) {
	// Check for sourceCapabilities, used to distinguish synthetic events
	// if mouseEvent did not come from a device that fires touch events,
	// it was made by a real mouse and should be counted
	// http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
	let sc = mouseEvent.sourceCapabilities;
	if (sc && !sc.firesTouchEvents) {
		return;
	}
	// skip synthetic mouse events
	mouseEvent[HANDLED_OBJ] = { skip: true };
	// disable "ghost clicks"
	if (mouseEvent.type === 'click') {
		let clickFromLabel = false;
		let path = mouseEvent.composedPath && mouseEvent.composedPath();
		if (path) {
			for (let i = 0; i < path.length; i++) {
				if (path[i].nodeType === Node.ELEMENT_NODE) {
					if (path[i].localName === 'label') {
						clickedLabels.push(path[i]);
					} else if (canBeLabelled(path[i])) {
						let ownerLabels = matchingLabels(path[i]);
						// check if one of the clicked labels is labelling this element
						for (let j = 0; j < ownerLabels.length; j++) {
							clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
						}
					}
				}
				if (path[i] === POINTERSTATE.mouse.target) {
					return;
				}
			}
		}
		// if one of the clicked labels was labelling the target element,
		// this is not a ghost click
		if (clickFromLabel) {
			return;
		}
		mouseEvent.preventDefault();
		mouseEvent.stopPropagation();
	}
};

/**
 * @param {boolean=} setup True to add, false to remove.
 * @return {void}
 */
function setupTeardownMouseCanceller(setup) {
	let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
	for (let i = 0, en; i < events.length; i++) {
		en = events[i];
		if (setup) {
			// reset clickLabels array
			clickedLabels.length = 0;
			document.addEventListener(en, mouseCanceller, true);
		} else {
			document.removeEventListener(en, mouseCanceller, true);
		}
	}
}

function ignoreMouse(e) {
	if (!POINTERSTATE.mouse.mouseIgnoreJob) {
		setupTeardownMouseCanceller(true);
	}
	let unset = function () {
		setupTeardownMouseCanceller();
		POINTERSTATE.mouse.target = null;
		POINTERSTATE.mouse.mouseIgnoreJob = null;
	};
	POINTERSTATE.mouse.target = e.composedPath()[0];
	POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(
		POINTERSTATE.mouse.mouseIgnoreJob
		, timeOut$1.after(MOUSE_TIMEOUT)
		, unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
	let type = ev.type;
	// exit early if the event is not a mouse event
	if (!isMouseEvent(type)) {
		return false;
	}
	// ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
	// instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
	if (type === 'mousemove') {
		// allow undefined for testing events
		let buttons = ev.buttons === undefined ? 1 : ev.buttons;
		if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
			buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
		}
		// buttons is a bitmask, check that the left button bit is set (1)
		return Boolean(buttons & 1);
	} else {
		// allow undefined for testing events
		let button = ev.button === undefined ? 0 : ev.button;
		// ev.button is 0 in mousedown/mouseup/click for left button activation
		return button === 0;
	}
}

function isSyntheticClick(ev) {
	if (ev.type === 'click') {
		// ev.detail is 0 for HTMLElement.click in most browsers
		if (ev.detail === 0) {
			return true;
		}
		// in the worst case, check that the x/y position of the click is within
		// the bounding box of the target of the event
		// Thanks IE 10 >:(
		let t = _findOriginalTarget(ev);
		// make sure the target of the event is an element so we can use getBoundingClientRect,
		// if not, just assume it is a synthetic click
		if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {
			return true;
		}
		let bcr = /** @type {Element} */(t).getBoundingClientRect();
		// use page x/y to account for scrolling
		let x = ev.pageX, y = ev.pageY;
		// ev is a synthetic click if the position is outside the bounding box of the target
		return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
	}
	return false;
}

let POINTERSTATE = {
	mouse: {
		target: null,
		mouseIgnoreJob: null
	},
	touch: {
		x: 0,
		y: 0,
		id: -1,
		scrollDecided: false
	}
};

function firstTouchAction(ev) {
	let ta = 'auto';
	let path = ev.composedPath && ev.composedPath();
	if (path) {
		for (let i = 0, n; i < path.length; i++) {
			n = path[i];
			if (n[TOUCH_ACTION]) {
				ta = n[TOUCH_ACTION];
				break;
			}
		}
	}
	return ta;
}

function trackDocument(stateObj, movefn, upfn) {
	stateObj.movefn = movefn;
	stateObj.upfn = upfn;
	document.addEventListener('mousemove', movefn);
	document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
	document.removeEventListener('mousemove', stateObj.movefn);
	document.removeEventListener('mouseup', stateObj.upfn);
	stateObj.movefn = null;
	stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

/** @type {!Object<string, !GestureRecognizer>} */
const gestures = {};

/** @type {!Array<!GestureRecognizer>} */
const recognizers = [];

/**
 * Finds the element rendered on the screen at the provided coordinates.
 *
 * Similar to `document.elementFromPoint`, but pierces through
 * shadow roots.
 *
 * @param {number} x Horizontal pixel coordinate
 * @param {number} y Vertical pixel coordinate
 * @return {Element} Returns the deepest shadowRoot inclusive element
 * found at the screen position given.
 */
function deepTargetFind(x, y) {
	let node = document.elementFromPoint(x, y);
	let next = node;
	// this code path is only taken when native ShadowDOM is used
	// if there is a shadowroot, it may have a node at x/y
	// if there is not a shadowroot, exit the loop
	while (next && next.shadowRoot && !window.ShadyDOM) {
		// if there is a node at x/y in the shadowroot, look deeper
		let oldNext = next;
		next = next.shadowRoot.elementFromPoint(x, y);
		// on Safari, elementFromPoint may return the shadowRoot host
		if (oldNext === next) {
			break;
		}
		if (next) {
			node = next;
		}
	}
	return node;
}

/**
 * a cheaper check than ev.composedPath()[0];
 *
 * @private
 * @param {Event|Touch} ev Event.
 * @return {EventTarget} Returns the event target.
 */
function _findOriginalTarget(ev) {
	// shadowdom
	if (ev.composedPath) {
		const targets = /** @type {!Array<!EventTarget>} */(ev.composedPath());
		// It shouldn't be, but sometimes targets is empty (window on Safari).
		return targets.length > 0 ? targets[0] : ev.target;
	}
	// shadydom
	return ev.target;
}

/**
 * @private
 * @param {Event} ev Event.
 * @return {void}
 */
function _handleNative(ev) {
	let handled;
	let type = ev.type;
	let node = ev.currentTarget;
	let gobj = node[GESTURE_KEY];
	if (!gobj) {
		return;
	}
	let gs = gobj[type];
	if (!gs) {
		return;
	}
	if (!ev[HANDLED_OBJ]) {
		ev[HANDLED_OBJ] = {};
		if (type.slice(0, 5) === 'touch') {
			ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign
			let t = ev.changedTouches[0];
			if (type === 'touchstart') {
				// only handle the first finger
				if (ev.touches.length === 1) {
					POINTERSTATE.touch.id = t.identifier;
				}
			}
			if (POINTERSTATE.touch.id !== t.identifier) {
				return;
			}
			if (!HAS_NATIVE_TA) {
				if (type === 'touchstart' || type === 'touchmove') {
					_handleTouchAction(ev);
				}
			}
		}
	}
	handled = ev[HANDLED_OBJ];
	// used to ignore synthetic mouse events
	if (handled.skip) {
		return;
	}
	// reset recognizer state
	for (let i = 0, r; i < recognizers.length; i++) {
		r = recognizers[i];
		if (gs[r.name] && !handled[r.name]) {
			if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
				r.reset();
			}
		}
	}
	// enforce gesture recognizer order
	for (let i = 0, r; i < recognizers.length; i++) {
		r = recognizers[i];
		if (gs[r.name] && !handled[r.name]) {
			handled[r.name] = true;
			r[type](ev);
		}
	}
}

/**
 * @private
 * @param {TouchEvent} ev Event.
 * @return {void}
 */
function _handleTouchAction(ev) {
	let t = ev.changedTouches[0];
	let type = ev.type;
	if (type === 'touchstart') {
		POINTERSTATE.touch.x = t.clientX;
		POINTERSTATE.touch.y = t.clientY;
		POINTERSTATE.touch.scrollDecided = false;
	} else if (type === 'touchmove') {
		if (POINTERSTATE.touch.scrollDecided) {
			return;
		}
		POINTERSTATE.touch.scrollDecided = true;
		let ta = firstTouchAction(ev);
		let shouldPrevent = false;
		let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
		let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
		if (!ev.cancelable) ; else if (ta === 'none') {
			shouldPrevent = true;
		} else if (ta === 'pan-x') {
			shouldPrevent = dy > dx;
		} else if (ta === 'pan-y') {
			shouldPrevent = dx > dy;
		}
		if (shouldPrevent) {
			ev.preventDefault();
		} else {
			prevent('track');
		}
	}
}

/**
 * Adds an event listener to a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to add listener on
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function to call
 * @return {boolean} Returns true if a gesture event listener was added.
 */
function addListener(node, evType, handler) {
	if (gestures[evType]) {
		_add(node, evType, handler);
		return true;
	}
	return false;
}

/**
 * Removes an event listener from a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to remove listener from
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function previously passed to
 *  `addListener`.
 * @return {boolean} Returns true if a gesture event listener was removed.
 */
function removeListener(node, evType, handler) {
	if (gestures[evType]) {
		_remove(node, evType, handler);
		return true;
	}
	return false;
}

/**
 * automate the event listeners for the native events
 *
 * @private
 * @param {!EventTarget} node Node on which to add the event.
 * @param {string} evType Event type to add.
 * @param {function(!Event)} handler Event handler function.
 * @return {void}
 */
function _add(node, evType, handler) {
	let recognizer = gestures[evType];
	let deps = recognizer.deps;
	let name = recognizer.name;
	let gobj = node[GESTURE_KEY];
	if (!gobj) {
		node[GESTURE_KEY] = gobj = {};
	}
	for (let i = 0, dep, gd; i < deps.length; i++) {
		dep = deps[i];
		// don't add mouse handlers on iOS because they cause gray selection overlays
		if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
			continue;
		}
		gd = gobj[dep];
		if (!gd) {
			gobj[dep] = gd = { _count: 0 };
		}
		if (gd._count === 0) {
			node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
		}
		gd[name] = (gd[name] || 0) + 1;
		gd._count = (gd._count || 0) + 1;
	}
	node.addEventListener(evType, handler);
	if (recognizer.touchAction) {
		setTouchAction(node, recognizer.touchAction);
	}
}

/**
 * automate event listener removal for native events
 *
 * @private
 * @param {!EventTarget} node Node on which to remove the event.
 * @param {string} evType Event type to remove.
 * @param {function(!Event): void} handler Event handler function.
 * @return {void}
 */
function _remove(node, evType, handler) {
	let recognizer = gestures[evType];
	let deps = recognizer.deps;
	let name = recognizer.name;
	let gobj = node[GESTURE_KEY];
	if (gobj) {
		for (let i = 0, dep, gd; i < deps.length; i++) {
			dep = deps[i];
			gd = gobj[dep];
			if (gd && gd[name]) {
				gd[name] = (gd[name] || 1) - 1;
				gd._count = (gd._count || 1) - 1;
				if (gd._count === 0) {
					node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
				}
			}
		}
	}
	node.removeEventListener(evType, handler);
}

/**
 * Registers a new gesture event recognizer for adding new custom
 * gesture event types.
 *
 * @param {!GestureRecognizer} recog Gesture recognizer descriptor
 * @return {void}
 */
function register(recog) {
	recognizers.push(recog);
	for (let i = 0; i < recog.emits.length; i++) {
		gestures[recog.emits[i]] = recog;
	}
}

/**
 * @private
 * @param {string} evName Event name.
 * @return {Object} Returns the gesture for the given event name.
 */
function _findRecognizerByEvent(evName) {
	for (let i = 0, r; i < recognizers.length; i++) {
		r = recognizers[i];
		for (let j = 0, n; j < r.emits.length; j++) {
			n = r.emits[j];
			if (n === evName) {
				return r;
			}
		}
	}
	return null;
}

/**
 * Sets scrolling direction on node.
 *
 * This value is checked on first move, thus it should be called prior to
 * adding event listeners.
 *
 * @param {!EventTarget} node Node to set touch action setting on
 * @param {string} value Touch action value
 * @return {void}
 */
function setTouchAction(node, value) {
	if (HAS_NATIVE_TA && node instanceof HTMLElement) {
		// NOTE: add touchAction async so that events can be added in
		// custom element constructors. Otherwise we run afoul of custom
		// elements restriction against settings attributes (style) in the
		// constructor.
		microTask$1.run(() => {
			node.style.touchAction = value;
		});
	}
	node[TOUCH_ACTION] = value;
}

/**
 * Dispatches an event on the `target` element of `type` with the given
 * `detail`.
 * @private
 * @param {!EventTarget} target The element on which to fire an event.
 * @param {string} type The type of event to fire.
 * @param {!Object=} detail The detail object to populate on the event.
 * @return {void}
 */
function _fire(target, type, detail) {
	let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
	ev.detail = detail;
	target.dispatchEvent(ev);
	// forward `preventDefault` in a clean way
	if (ev.defaultPrevented) {
		let preventer = detail.preventer || detail.sourceEvent;
		if (preventer && preventer.preventDefault) {
			preventer.preventDefault();
		}
	}
}

/**
 * Prevents the dispatch and default action of the given event name.
 *
 * @param {string} evName Event name.
 * @return {void}
 */
function prevent(evName) {
	let recognizer = _findRecognizerByEvent(evName);
	if (recognizer.info) {
		recognizer.info.prevent = true;
	}
}

/* eslint-disable valid-jsdoc */

register({
	name: 'downup',
	deps: ['mousedown', 'touchstart', 'touchend'],
	flow: {
		start: ['mousedown', 'touchstart'],
		end: ['mouseup', 'touchend']
	},
	emits: ['down', 'up'],

	info: {
		movefn: null,
		upfn: null
	},

	/**
	 * @this {GestureRecognizer}
	 * @return {void}
	 */
	reset: function () {
		untrackDocument(this.info);
	},

	/**
	 * @this {GestureRecognizer}
	 * @param {MouseEvent} e
	 * @return {void}
	 */
	mousedown: function (e) {
		if (!hasLeftMouseButton(e)) {
			return;
		}
		let t = _findOriginalTarget(e);
		let self = this;
		let movefn = function movefn(e) {
			if (!hasLeftMouseButton(e)) {
				downupFire('up', t, e);
				untrackDocument(self.info);
			}
		};
		let upfn = function upfn(e) {
			if (hasLeftMouseButton(e)) {
				downupFire('up', t, e);
			}
			untrackDocument(self.info);
		};
		trackDocument(this.info, movefn, upfn);
		downupFire('down', t, e);
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchstart: function (e) {
		downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchend: function (e) {
		downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);
	}
});

/**
 * @param {string} type
 * @param {EventTarget} target
 * @param {Event|Touch} event
 * @param {Event=} preventer
 * @return {void}
 */
function downupFire(type, target, event, preventer) {
	if (!target) {
		return;
	}
	_fire(target, type, {
		x: event.clientX,
		y: event.clientY,
		sourceEvent: event,
		preventer: preventer,
		prevent: function (e) {
			return prevent(e);
		}
	});
}

register({
	name: 'track',
	touchAction: 'none',
	deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
	flow: {
		start: ['mousedown', 'touchstart'],
		end: ['mouseup', 'touchend']
	},
	emits: ['track'],

	info: {
		x: 0,
		y: 0,
		state: 'start',
		started: false,
		moves: [],
		/** @this {GestureInfo} */
		addMove: function (move) {
			if (this.moves.length > TRACK_LENGTH) {
				this.moves.shift();
			}
			this.moves.push(move);
		},
		movefn: null,
		upfn: null,
		prevent: false
	},

	/**
	 * @this {GestureRecognizer}
	 * @return {void}
	 */
	reset: function () {
		this.info.state = 'start';
		this.info.started = false;
		this.info.moves = [];
		this.info.x = 0;
		this.info.y = 0;
		this.info.prevent = false;
		untrackDocument(this.info);
	},

	/**
	 * @this {GestureRecognizer}
	 * @param {MouseEvent} e
	 * @return {void}
	 */
	mousedown: function (e) {
		if (!hasLeftMouseButton(e)) {
			return;
		}
		let t = _findOriginalTarget(e);
		let self = this;
		let movefn = function movefn(e) {
			let x = e.clientX, y = e.clientY;
			if (trackHasMovedEnough(self.info, x, y)) {
				// first move is 'start', subsequent moves are 'move', mouseup is 'end'
				self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
				if (self.info.state === 'start') {
					// if and only if tracking, always prevent tap
					prevent('tap');
				}
				self.info.addMove({ x: x, y: y });
				if (!hasLeftMouseButton(e)) {
					// always fire "end"
					self.info.state = 'end';
					untrackDocument(self.info);
				}
				if (t) {
					trackFire(self.info, t, e);
				}
				self.info.started = true;
			}
		};
		let upfn = function upfn(e) {
			if (self.info.started) {
				movefn(e);
			}

			// remove the temporary listeners
			untrackDocument(self.info);
		};
		// add temporary document listeners as mouse retargets
		trackDocument(this.info, movefn, upfn);
		this.info.x = e.clientX;
		this.info.y = e.clientY;
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchstart: function (e) {
		let ct = e.changedTouches[0];
		this.info.x = ct.clientX;
		this.info.y = ct.clientY;
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchmove: function (e) {
		let t = _findOriginalTarget(e);
		let ct = e.changedTouches[0];
		let x = ct.clientX, y = ct.clientY;
		if (trackHasMovedEnough(this.info, x, y)) {
			if (this.info.state === 'start') {
				// if and only if tracking, always prevent tap
				prevent('tap');
			}
			this.info.addMove({ x: x, y: y });
			trackFire(this.info, t, ct);
			this.info.state = 'track';
			this.info.started = true;
		}
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchend: function (e) {
		let t = _findOriginalTarget(e);
		let ct = e.changedTouches[0];
		// only trackend if track was started and not aborted
		if (this.info.started) {
			// reset started state on up
			this.info.state = 'end';
			this.info.addMove({ x: ct.clientX, y: ct.clientY });
			trackFire(this.info, t, ct);
		}
	}
});

/**
 * @param {!GestureInfo} info
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
function trackHasMovedEnough(info, x, y) {
	if (info.prevent) {
		return false;
	}
	if (info.started) {
		return true;
	}
	let dx = Math.abs(info.x - x);
	let dy = Math.abs(info.y - y);
	return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
}

/**
 * @param {!GestureInfo} info
 * @param {?EventTarget} target
 * @param {Touch} touch
 * @return {void}
 */
function trackFire(info, target, touch) {
	if (!target) {
		return;
	}
	let secondlast = info.moves[info.moves.length - 2];
	let lastmove = info.moves[info.moves.length - 1];
	let dx = lastmove.x - info.x;
	let dy = lastmove.y - info.y;
	let ddx, ddy = 0;
	if (secondlast) {
		ddx = lastmove.x - secondlast.x;
		ddy = lastmove.y - secondlast.y;
	}
	_fire(target, 'track', {
		state: info.state,
		x: touch.clientX,
		y: touch.clientY,
		dx: dx,
		dy: dy,
		ddx: ddx,
		ddy: ddy,
		sourceEvent: touch,
		hover: function () {
			return deepTargetFind(touch.clientX, touch.clientY);
		}
	});
}

register({
	name: 'tap',
	deps: ['mousedown', 'click', 'touchstart', 'touchend'],
	flow: {
		start: ['mousedown', 'touchstart'],
		end: ['click', 'touchend']
	},
	emits: ['tap'],
	info: {
		x: NaN,
		y: NaN,
		prevent: false
	},
	/**
	 * @this {GestureRecognizer}
	 * @return {void}
	 */
	reset: function () {
		this.info.x = NaN;
		this.info.y = NaN;
		this.info.prevent = false;
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {MouseEvent} e
	 * @return {void}
	 */
	mousedown: function (e) {
		if (hasLeftMouseButton(e)) {
			this.info.x = e.clientX;
			this.info.y = e.clientY;
		}
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {MouseEvent} e
	 * @return {void}
	 */
	click: function (e) {
		if (hasLeftMouseButton(e)) {
			trackForward(this.info, e);
		}
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchstart: function (e) {
		const touch = e.changedTouches[0];
		this.info.x = touch.clientX;
		this.info.y = touch.clientY;
	},
	/**
	 * @this {GestureRecognizer}
	 * @param {TouchEvent} e
	 * @return {void}
	 */
	touchend: function (e) {
		trackForward(this.info, e.changedTouches[0], e);
	}
});

/**
 * @param {!GestureInfo} info
 * @param {Event | Touch} e
 * @param {Event=} preventer
 * @return {void}
 */
function trackForward(info, e, preventer) {
	let dx = Math.abs(e.clientX - info.x);
	let dy = Math.abs(e.clientY - info.y);
	// find original target from `preventer` for TouchEvents, or `e` for MouseEvents
	let t = _findOriginalTarget((preventer || e));
	if (!t || (canBeDisabled[/** @type {!HTMLElement} */(t).localName] && t.hasAttribute('disabled'))) {
		return;
	}
	// dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
	if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
		// prevent taps from being generated if an event has canceled them
		if (!info.prevent) {
			_fire(t, 'tap', {
				x: e.clientX,
				y: e.clientY,
				sourceEvent: e,
				preventer: preventer
			});
		}
	}
}

/* eslint-enable valid-jsdoc */

var Gestures = {
	addListener: addListener,
	removeListener: removeListener,
	findOriginalTarget: _findOriginalTarget
};

/**
 * @namespace
 * @public
 */
var oControlEvents = {};

/**
 * List of DOM events that a UIArea automatically takes care of.
 *
 * A control/element doesn't have to bind listeners for these events.
 * It instead can implement an <code>on<i>event</i>(oEvent)</code> method
 * for any of the following events that it wants to be notified about:
 *
 * click, dblclick, contextmenu, focusin, focusout, keydown, keypress, keyup, mousedown, mouseout, mouseover,
 * mouseup, select, selectstart, dragstart, dragenter, dragover, dragleave, dragend, drop, paste, cut, input,
 * touchstart, touchend, touchmove, touchcancel, tap, swipe, swipeleft, swiperight, scrollstart, scrollstop
 *
 * The mouse events and touch events are supported simultaneously on both desktop and mobile browsers. Do NOT
 * create both onmouse* and ontouch* functions to avoid one event being handled twice on the same control.
 *
 * @public
 */
oControlEvents.events = [ // IMPORTANT: update the public documentation when extending this list
	"click",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"keydown",
	"keypress",
	"keyup",
	"mousedown",
	"mouseout",
	"mouseover",
	"mouseup",
	"select",
	"selectstart",
	"dragstart",
	"dragenter",
	"dragover",
	"dragleave",
	"dragend",
	"drop",
	"paste",
	"cut",
	/* input event is fired synchronously on IE9+ when the value of an <input> or <textarea> element is changed */
	/* for more details please see : https://developer.mozilla.org/en-US/docs/Web/Reference/Events/input */
	"input"
];

// touch events natively supported
if (Device.support.touch) {
	oControlEvents.events.push("touchstart", "touchend", "touchmove", "touchcancel");
}

oControlEvents.gestures = [
	"down",
	"up",
	"tap"
];

/**
 * Binds all events for listening with the given callback function.
 *
 * @param {function} fnCallback Callback function
 * @public
 */
oControlEvents.bindAnyEvent = function (fnCallback) {
	if (fnCallback) {
		oControlEvents.events.forEach(event => {
			document.addEventListener(event, fnCallback);
		});

		oControlEvents.gestures.forEach(gesture => {
			Gestures.addListener(document, gesture, fnCallback);
		});
	}
};

/**
 * Unbinds all events for listening with the given callback function.
 *
 * @param {function} fnCallback Callback function
 * @public
 */
oControlEvents.unbindAnyEvent = function unbindAnyEvent(fnCallback) {
	if (fnCallback) {
		oControlEvents.events.forEach(event => {
			document.removeEventListener(event, fnCallback);
		});

		oControlEvents.gestures.forEach(gesture => {
			Gestures.removeListener(document, gesture, fnCallback);
		});
	}
};

const handleEvent = function (event) {

	// Get the DOM node where the original event occurred
	let target = getDomTarget(event);
	event.ui5target = target;

	// Traverse the DOM
	let shouldPropagate = true;
	while (shouldPropagate && target instanceof HTMLElement) {
		shouldPropagate = processDOMNode(target, event);
		if (shouldPropagate) {
			target = getParentDOMNode(target);
		}
	}
};

const getDomTarget = function(event) {

	// Default - composedPath should be used (also covered by polyfill)
	if (typeof event.composedPath === "function") {
		const composedPath = event.composedPath();
		if (Array.isArray(composedPath) && composedPath.length) {
			return composedPath[0];
		}
	}

	// Fallback
	return event.target;
};

const processDOMNode = function(node, event) {
	const id = node.getAttribute("data-sap-ui");
	const tag = node.tagName;
	let control;

	if (tag.match(/^ui5-/i)) {
		control = node;
	}

	if (control && control._handleEvent) {
		return dispatchEvent(control, event);
	}
	return true;
};

const dispatchEvent = function(control, event) {

	// Handle the original event (such as "keydown")
	control._handleEvent(event);
	if (event.isImmediatePropagationStopped()) {
		return false;
	}

	// Handle pseudo events that derive from the original event (such as "sapselect")
	const pseudoTypes = getPseudoTypesFor(event);
	for (let i = 0, len = pseudoTypes.length; i < len; i++) {
		control._handleEvent(event, pseudoTypes[i]);
		if (event.isImmediatePropagationStopped()) {
			return false;
		}
	}

	if (event.isPropagationStopped()) {
		return false;
	}

	return true;
};

// Stores the calculated list of pseudo events per event
const pseudoMap = new WeakMap();

const getPseudoTypesFor = function(event) {

	if (pseudoMap.has(event)) {
		return pseudoMap.get(event);
	}

	const aPseudoTypes = [];

	if (PseudoEvents.getBasicTypes().indexOf(event.type) !== -1) {
		const iLength = PseudoEvents.order.length;
		let oPseudo = null;

		for (let i = 0; i < iLength; i++) {
			oPseudo = PseudoEvents.events[PseudoEvents.order[i]];
			if (oPseudo.aTypes
				&& oPseudo.aTypes.indexOf(event.type) > -1
				&& oPseudo.fnCheck
				&& oPseudo.fnCheck(event)) {
				aPseudoTypes.push(oPseudo.sName);
			}
		}
	}

	pseudoMap.set(event, aPseudoTypes);

	return aPseudoTypes;
};

const getParentDOMNode = function(node) {
	const parentNode = node.parentNode;

	// Skip the custom element tag (host) only if crossing a shadow DOM boundary
	// The reason is that the event was already dispatched to the light control while traversing the shadow DOM
	if (parentNode && parentNode.host) {
		return parentNode.host;
	}

	return parentNode;
};


class DOMEventHandler {
	constructor() {
		throw new Error("Static class");
	}

	static start() {
		oControlEvents.bindAnyEvent(handleEvent);
	}

	static stop() {
		oControlEvents.unbindAnyEvent(handleEvent);
	}
}

class NativeResize {

	static initialize() {
		NativeResize.resizeObserver = new window.ResizeObserver(entries => {

			// call attached callbacks
			entries.forEach(entry => {
				const callbacks = NativeResize.observedObjects.get(entry.target);

				callbacks.forEach(el => el());
			});
		});

		NativeResize.observedObjects = new Map();
	}

	static attachListener(ref, callback) {
		const observedDOMs = NativeResize.observedObjects;
		const callbacks = observedDOMs.get(ref) || [];

		// if no callbacks has been added for this ref - start observing it
		if (!callbacks.length) {
			NativeResize.resizeObserver.observe(ref);
		}

		// save the callbacks in an array
		observedDOMs.set(ref, [...callbacks, callback]);
	}

	static detachListener(ref, callback) {
		const callbacks = NativeResize.observedObjects.get(ref) || [];
		const filteredCallbacks = callbacks.filter((fn) => fn !== callback);

		// TODO: think for a validation mechanism
		if (!callbacks.length || (callbacks.length === filteredCallbacks.length && callbacks.length !== 0)) {
			return;
		}

		NativeResize.observedObjects.set(ref, filteredCallbacks);

		if (!filteredCallbacks.length) {
			NativeResize.resizeObserver.unobserve(ref);
		}
	}
}

const INTERVAL = 300;

class CustomResize {

	static initialize() {
		CustomResize.initialized = false;
		CustomResize.resizeInterval = undefined;
		CustomResize.resizeListeners = new Map();
	}

	static attachListener(ref, callback) {
		const observedObject = CustomResize.resizeListeners.get(ref);
		const existingCallbacks = observedObject ? observedObject.callbacks : [];

		CustomResize.resizeListeners.set(ref, {
			width: ref ? ref.offsetWidth : 0,
			height: ref ? ref.offsetHeight : 0,
			callbacks: existingCallbacks.concat(callback)
		});

		CustomResize.initListener();
	}

	static initListener() {
		if (CustomResize.resizeListeners.size > 0 && !CustomResize.initialized) {
			CustomResize.resizeInterval = setInterval(CustomResize.checkListeners.bind(CustomResize), INTERVAL);
		}
	}

	static checkListeners() {
		CustomResize.resizeListeners.forEach((entry, ref) => {
			const changed = CustomResize.checkSizes(entry, ref);

			if (changed) {
				CustomResize.updateSizes(entry, ref.offsetWidth, ref.offsetHeight);
				entry.callbacks.forEach(el => el());
			}
		});
	}

	static updateSizes(sizes, newWidth, newHeight) {
		sizes.width = newWidth;
		sizes.height = newHeight;
	}

	static checkSizes(entry, ref) {
		const oldHeight = entry.height;
		const oldWidth = entry.width;
		const newHeight = ref.offsetHeight;
		const newWidth = ref.offsetWidth;

		return ((oldHeight !== newHeight) || oldWidth !== newWidth);
	}

	static detachListener(ref, callback) {
		const listenerObject = CustomResize.resizeListeners.get(ref);
		const callbacks = listenerObject ? listenerObject.callbacks : [];
		const filteredCallbacks = callbacks.filter((fn) => fn !== callback);

		if (!listenerObject || (callbacks.length === filteredCallbacks.length && callbacks.length !== 0)) {
			return;
		}

		CustomResize.resizeListeners.set(ref, Object.assign(listenerObject, { callbacks: filteredCallbacks }));

		if (!filteredCallbacks.length) {
			listenerObject.callbacks = null;
			CustomResize.resizeListeners.delete(ref);
		}

		if (CustomResize.resizeListeners.size === 0) {
			CustomResize.initialized = false;
			clearInterval(CustomResize.resizeInterval);
		}
	}
}

class ResizeHandler {

	static initialize() {
		ResizeHandler.Implementation = window.ResizeObserver ? NativeResize : CustomResize;
		ResizeHandler.Implementation.initialize();
	}

	/**
	 * @static
	 * @private
	 * @param {*} ref Reference to be observed
	 * @param {*} callback Callback to be executed
	 * @memberof ResizeHandler
	 */
	static attachListener(ref, callback) {
		ResizeHandler.Implementation.attachListener.call(ResizeHandler.Implementation, ref, callback);
	}

	/**
	 * @static
	 * @private
	 * @param {*} ref Reference to be unobserved
	 * @memberof ResizeHandler
	 */
	static detachListener(ref, callback) {
		ResizeHandler.Implementation.detachListener.call(ResizeHandler.Implementation, ref, callback);
	}


	/**
	 * @static
	 * @public
	 * @param {*} ref Reference to a UI5 Control or DOM Element to be observed
	 * @param {*} callback Callback to be executed
	 * @memberof ResizeHandler
	 */
	static register(ref, callback) {

		if (ref instanceof WebComponent) {
			ref = ref.getDomRef();
		}

		ResizeHandler.attachListener(ref, callback);
	}


	/**
	 * @static
	 * @public
	 * @param {*} ref Reference to UI5 Control or DOM Element to be unobserved
	 * @memberof ResizeHandler
	 */
	static deregister(ref, callback) {

		if (ref instanceof WebComponent) {
			ref = ref.getDomRef();
		}

		ResizeHandler.detachListener(ref, callback);
	}
}

var fnNow = !(typeof window != "undefined" && window.performance && performance.now && performance.timing) ? Date.now : (function () {
  var iNavigationStart = performance.timing.navigationStart;
  return function perfnow() {
    return iNavigationStart + performance.now();
  };
})();

var Log = {};
Log.Level = {
    NONE: -1,
    FATAL: 0,
    ERROR: 1,
    WARNING: 2,
    INFO: 3,
    DEBUG: 4,
    TRACE: 5,
    ALL: 5 + 1
};
var sDefaultComponent, aLog = [], mMaxLevel = { '': Log.Level.ERROR }, oListener = null, bLogSupportInfo = false;
function pad0(i, w) {
    return ('000' + String(i)).slice(-w);
}
function level(sComponent) {
    return !sComponent || isNaN(mMaxLevel[sComponent]) ? mMaxLevel[''] : mMaxLevel[sComponent];
}
function getLogEntryListenerInstance() {
    if (!oListener) {
        oListener = {
            listeners: [],
            onLogEntry: function (oLogEntry) {
                for (var i = 0; i < oListener.listeners.length; i++) {
                    if (oListener.listeners[i].onLogEntry) {
                        oListener.listeners[i].onLogEntry(oLogEntry);
                    }
                }
            },
            attach: function (oLog, oLstnr) {
                if (oLstnr) {
                    oListener.listeners.push(oLstnr);
                    if (oLstnr.onAttachToLog) {
                        oLstnr.onAttachToLog(oLog);
                    }
                }
            },
            detach: function (oLog, oLstnr) {
                for (var i = 0; i < oListener.listeners.length; i++) {
                    if (oListener.listeners[i] === oLstnr) {
                        if (oLstnr.onDetachFromLog) {
                            oLstnr.onDetachFromLog(oLog);
                        }
                        oListener.listeners.splice(i, 1);
                        return;
                    }
                }
            }
        };
    }
    return oListener;
}
Log.fatal = function (sMessage, sDetails, sComponent, fnSupportInfo) {
    log(Log.Level.FATAL, sMessage, sDetails, sComponent, fnSupportInfo);
};
Log.error = function (sMessage, sDetails, sComponent, fnSupportInfo) {
    log(Log.Level.ERROR, sMessage, sDetails, sComponent, fnSupportInfo);
};
Log.warning = function (sMessage, sDetails, sComponent, fnSupportInfo) {
    log(Log.Level.WARNING, sMessage, sDetails, sComponent, fnSupportInfo);
};
Log.info = function (sMessage, sDetails, sComponent, fnSupportInfo) {
    log(Log.Level.INFO, sMessage, sDetails, sComponent, fnSupportInfo);
};
Log.debug = function (sMessage, sDetails, sComponent, fnSupportInfo) {
    log(Log.Level.DEBUG, sMessage, sDetails, sComponent, fnSupportInfo);
};
Log.trace = function (sMessage, sDetails, sComponent, fnSupportInfo) {
    log(Log.Level.TRACE, sMessage, sDetails, sComponent, fnSupportInfo);
};
Log.setLevel = function (iLogLevel, sComponent, _bDefault) {
    sComponent = sComponent || sDefaultComponent || '';
    if (!_bDefault || mMaxLevel[sComponent] == null) {
        mMaxLevel[sComponent] = iLogLevel;
        var sLogLevel;
        Object.keys(Log.Level).forEach(function (sLevel) {
            if (Log.Level[sLevel] === iLogLevel) {
                sLogLevel = sLevel;
            }
        });
        log(Log.Level.INFO, 'Changing log level ' + (sComponent ? 'for \'' + sComponent + '\' ' : '') + 'to ' + sLogLevel, '', 'sap.base.log');
    }
};
Log.getLevel = function (sComponent) {
    return level(sComponent || sDefaultComponent);
};
Log.isLoggable = function (iLevel, sComponent) {
    return (iLevel == null ? Log.Level.DEBUG : iLevel) <= level(sComponent || sDefaultComponent);
};
Log.logSupportInfo = function (bEnabled) {
    bLogSupportInfo = bEnabled;
};
function log(iLevel, sMessage, sDetails, sComponent, fnSupportInfo) {
    if (bLogSupportInfo) {
        if (!fnSupportInfo && !sComponent && typeof sDetails === 'function') {
            fnSupportInfo = sDetails;
            sDetails = '';
        }
        if (!fnSupportInfo && typeof sComponent === 'function') {
            fnSupportInfo = sComponent;
            sComponent = '';
        }
    }
    sComponent = sComponent || sDefaultComponent;
    if (iLevel <= level(sComponent)) {
        var fNow = fnNow(), oNow = new Date(fNow), iMicroSeconds = Math.floor((fNow - Math.floor(fNow)) * 1000), oLogEntry = {
                time: pad0(oNow.getHours(), 2) + ':' + pad0(oNow.getMinutes(), 2) + ':' + pad0(oNow.getSeconds(), 2) + '.' + pad0(oNow.getMilliseconds(), 3) + pad0(iMicroSeconds, 3),
                date: pad0(oNow.getFullYear(), 4) + '-' + pad0(oNow.getMonth() + 1, 2) + '-' + pad0(oNow.getDate(), 2),
                timestamp: fNow,
                level: iLevel,
                message: String(sMessage || ''),
                details: String(sDetails || ''),
                component: String(sComponent || '')
            };
        if (bLogSupportInfo && typeof fnSupportInfo === 'function') {
            oLogEntry.supportInfo = fnSupportInfo();
        }
        aLog.push(oLogEntry);
        if (oListener) {
            oListener.onLogEntry(oLogEntry);
        }
        if (console) {
            var logText = oLogEntry.date + ' ' + oLogEntry.time + ' ' + oLogEntry.message + ' - ' + oLogEntry.details + ' ' + oLogEntry.component;
            switch (iLevel) {
            case Log.Level.FATAL:
            case Log.Level.ERROR:
                console.error(logText);
                break;
            case Log.Level.WARNING:
                console.warn(logText);
                break;
            case Log.Level.INFO:
                console.info ? console.info(logText) : console.log(logText);
                break;
            case Log.Level.DEBUG:
                console.debug ? console.debug(logText) : console.log(logText);
                break;
            case Log.Level.TRACE:
                console.trace ? console.trace(logText) : console.log(logText);
                break;
            }
            if (console.info && oLogEntry.supportInfo) {
                console.info(oLogEntry.supportInfo);
            }
        }
        return oLogEntry;
    }
}
Log.getLogEntries = function () {
    return aLog.slice();
};
Log.addLogListener = function (oListener) {
    getLogEntryListenerInstance().attach(this, oListener);
};
Log.removeLogListener = function (oListener) {
    getLogEntryListenerInstance().detach(this, oListener);
};
function Logger(sComponent) {
    this.fatal = function (msg, detail, comp, support) {
        Log.fatal(msg, detail, comp || sComponent, support);
        return this;
    };
    this.error = function (msg, detail, comp, support) {
        Log.error(msg, detail, comp || sComponent, support);
        return this;
    };
    this.warning = function (msg, detail, comp, support) {
        Log.warning(msg, detail, comp || sComponent, support);
        return this;
    };
    this.info = function (msg, detail, comp, support) {
        Log.info(msg, detail, comp || sComponent, support);
        return this;
    };
    this.debug = function (msg, detail, comp, support) {
        Log.debug(msg, detail, comp || sComponent, support);
        return this;
    };
    this.trace = function (msg, detail, comp, support) {
        Log.trace(msg, detail, comp || sComponent, support);
        return this;
    };
    this.setLevel = function (level, comp) {
        Log.setLevel(level, comp || sComponent);
        return this;
    };
    this.getLevel = function (comp) {
        return Log.getLevel(comp || sComponent);
    };
    this.isLoggable = function (level, comp) {
        return Log.isLoggable(level, comp || sComponent);
    };
}
Log.getLogger = function (sComponent, iDefaultLogLevel) {
    if (!isNaN(iDefaultLogLevel) && mMaxLevel[sComponent] == null) {
        mMaxLevel[sComponent] = iDefaultLogLevel;
    }
    return new Logger(sComponent);
};

var fnAssert = function (bResult, vMessage) {
  if (!bResult) {
    var sMessage = typeof vMessage === "function" ? vMessage() : vMessage;
    if (console && console.assert) {
      console.assert(bResult, sMessage);
    } else {
      Log.debug("[Assertions] " + sMessage);
    }
  }
};

var LoaderExtensions = {};
var FRAGMENT = 'fragment';
var VIEW = 'view';
var KNOWN_SUBTYPES = {
    js: [
        VIEW,
        FRAGMENT,
        'controller',
        'designtime'
    ],
    xml: [
        VIEW,
        FRAGMENT
    ],
    json: [
        VIEW,
        FRAGMENT
    ],
    html: [
        VIEW,
        FRAGMENT
    ]
};
var rTypes;
(function () {
    var s = '';
    for (var sType in KNOWN_SUBTYPES) {
        s = (s ? s + '|' : '') + sType;
    }
    s = '\\.(' + s + ')$';
    rTypes = new RegExp(s);
}());
LoaderExtensions.getKnownSubtypes = function () {
    return KNOWN_SUBTYPES;
};
LoaderExtensions.getAllRequiredModules = function () {
    var aModuleNames = [], mModules = sap.ui.loader._.getAllModules(true), oModule;
    for (var sModuleName in mModules) {
        oModule = mModules[sModuleName];
        if (oModule.ui5 && oModule.state !== -1) {
            aModuleNames.push(oModule.ui5);
        }
    }
    return aModuleNames;
};
LoaderExtensions.loadResource = function (sResourceName, mOptions) {
    var sType, oData, sUrl, oError, oDeferred, iSyncCallBehavior;
    if (typeof sResourceName === 'string') {
        mOptions = mOptions || {};
    } else {
        mOptions = sResourceName || {};
        sResourceName = mOptions.name;
    }
    mOptions = jQuery.extend({
        failOnError: true,
        async: false
    }, mOptions);
    sType = mOptions.dataType;
    if (sType == null && sResourceName) {
        sType = (sType = rTypes.exec(sResourceName || mOptions.url)) && sType[1];
    }
    fnAssert(/^(xml|html|json|text)$/.test(sType), 'type must be one of xml, html, json or text');
    oDeferred = mOptions.async ? new jQuery.Deferred() : null;
    function handleData(d, e) {
        if (d == null && mOptions.failOnError) {
            oError = e || new Error('no data returned for ' + sResourceName);
            if (mOptions.async) {
                oDeferred.reject(oError);
                Log.error(oError);
            }
            return null;
        }
        if (mOptions.async) {
            oDeferred.resolve(d);
        }
        return d;
    }
    function convertData(d) {
        var vConverter = jQuery.ajaxSettings.converters['text ' + sType];
        if (typeof vConverter === 'function') {
            d = vConverter(d);
        }
        return handleData(d);
    }
    oData = sap.ui.loader._.getModuleContent(sResourceName, mOptions.url);
    if (oData != undefined) {
        if (mOptions.async) {
            setTimeout(function () {
                convertData(oData);
            }, 0);
        } else {
            oData = convertData(oData);
        }
    } else {
        iSyncCallBehavior = sap.ui.loader._.getSyncCallBehavior();
        if (!mOptions.async && iSyncCallBehavior) {
            if (iSyncCallBehavior >= 1) {
                Log.error('[nosync] loading resource \'' + (sResourceName || mOptions.url) + '\' with sync XHR');
            } else {
                throw new Error('[nosync] loading resource \'' + (sResourceName || mOptions.url) + '\' with sync XHR');
            }
        }
        jQuery.ajax({
            url: sUrl = mOptions.url || sap.ui.loader._.getResourcePath(sResourceName),
            async: mOptions.async,
            dataType: sType,
            headers: mOptions.headers,
            success: function (data, textStatus, xhr) {
                oData = handleData(data);
            },
            error: function (xhr, textStatus, error) {
                oError = new Error('resource ' + sResourceName + ' could not be loaded from ' + sUrl + '. Check for \'file not found\' or parse errors. Reason: ' + error);
                oError.status = textStatus;
                oError.error = error;
                oError.statusCode = xhr.status;
                oData = handleData(null, oError);
            }
        });
    }
    if (mOptions.async) {
        return Promise.resolve(oDeferred);
    }
    if (oError != null && mOptions.failOnError) {
        throw oError;
    }
    return oData;
};

var VersionInfo = {};
VersionInfo.load = function (mOptions) {
    mOptions = mOptions || {};
    mOptions.async = true;
    return VersionInfo._load(mOptions);
};
var oVersionInfoPromise = null;
VersionInfo._load = function (mOptions) {
    if (typeof mOptions !== 'object') {
        mOptions = { library: mOptions };
    }
    mOptions.async = mOptions.async === true;
    mOptions.failOnError = mOptions.failOnError !== false;
    if (!sap.ui.versioninfo) {
        if (mOptions.async && oVersionInfoPromise instanceof Promise) {
            return oVersionInfoPromise.then(function () {
                return sap.ui.getVersionInfo(mOptions);
            });
        }
        var fnHandleSuccess = function (oVersionInfo) {
            oVersionInfoPromise = null;
            if (oVersionInfo === null) {
                return undefined;
            }
            sap.ui.versioninfo = oVersionInfo;
            return sap.ui.getVersionInfo(mOptions);
        };
        var fnHandleError = function (oError) {
            oVersionInfoPromise = null;
            throw oError;
        };
        var vReturn = LoaderExtensions.loadResource('sap-ui-version.json', {
            async: mOptions.async,
            failOnError: mOptions.async || mOptions.failOnError
        });
        if (vReturn instanceof Promise) {
            oVersionInfoPromise = vReturn;
            return vReturn.then(fnHandleSuccess, fnHandleError);
        } else {
            return fnHandleSuccess(vReturn);
        }
    } else {
        var oResult;
        if (typeof mOptions.library !== 'undefined') {
            var aLibs = sap.ui.versioninfo.libraries;
            if (aLibs) {
                for (var i = 0, l = aLibs.length; i < l; i++) {
                    if (aLibs[i].name === mOptions.library) {
                        oResult = aLibs[i];
                        break;
                    }
                }
            }
        } else {
            oResult = sap.ui.versioninfo;
        }
        return mOptions.async ? Promise.resolve(oResult) : oResult;
    }
};

var ObjectPath = {};
var defaultRootContext = window;
function getObjectPathArray(vObjectPath) {
  return Array.isArray(vObjectPath) ? vObjectPath : vObjectPath.split(".");
}
ObjectPath.create = function (vObjectPath, oRootContext) {
  var oObject = oRootContext || defaultRootContext;
  var aNames = getObjectPathArray(vObjectPath);
  for (var i = 0; i < aNames.length; i++) {
    var sName = aNames[i];
    if (oObject[sName] === null || oObject[sName] !== undefined && (typeof oObject[sName] !== "object" && typeof oObject[sName] !== "function")) {
      throw new Error("Could not set object-path for '" + aNames.join(".") + "', path segment '" + sName + "' already exists.");
    }
    oObject[sName] = oObject[sName] || ({});
    oObject = oObject[sName];
  }
  return oObject;
};
ObjectPath.get = function (vObjectPath, oRootContext) {
  var oObject = oRootContext || defaultRootContext;
  var aNames = getObjectPathArray(vObjectPath);
  var sPropertyName = aNames.pop();
  for (var i = 0; i < aNames.length && oObject; i++) {
    oObject = oObject[aNames[i]];
  }
  return oObject ? oObject[sPropertyName] : undefined;
};
ObjectPath.set = function (vObjectPath, vValue, oRootContext) {
  oRootContext = oRootContext || defaultRootContext;
  var aNames = getObjectPathArray(vObjectPath);
  var sPropertyName = aNames.pop();
  var oObject = ObjectPath.create(aNames, oRootContext);
  oObject[sPropertyName] = vValue;
};

if (window.OpenAjax && window.OpenAjax.hub) {
    OpenAjax.hub.registerLibrary('sap', 'http://www.sap.com/', '0.1', {});
}
if (typeof window.sap !== 'object' && typeof window.sap !== 'function') {
    window.sap = {};
}
if (typeof window.sap.ui !== 'object') {
    window.sap.ui = {};
}
sap.ui = Object.assign(sap.ui, {
    version: '${version}',
    buildinfo: {
        lastchange: '${lastchange}',
        buildtime: '${buildtime}'
    }
});
var oCfgData = window['sap-ui-config'] || {};
var syncCallBehavior = 0;
if (oCfgData['xx-nosync'] === 'warn' || /(?:\?|&)sap-ui-xx-nosync=(?:warn)/.exec(window.location.search)) {
    syncCallBehavior = 1;
}
if (oCfgData['xx-nosync'] === true || oCfgData['xx-nosync'] === 'true' || /(?:\?|&)sap-ui-xx-nosync=(?:x|X|true)/.exec(window.location.search)) {
    syncCallBehavior = 2;
}
sap.ui.getVersionInfo = function (mOptions) {
    if (mOptions && mOptions.async) {
        Log.info('Do not use deprecated function \'sap.ui.getVersionInfo\'. Use' + ' \'sap/ui/VersionInfo\' module\'s asynchronous .load function instead');
    } else {
        Log.warning('Do not use deprecated function \'sap.ui.getVersionInfo\' synchronously! Use' + ' \'sap/ui/VersionInfo\' module\'s asynchronous .load function instead', 'Deprecation', null, function () {
            return {
                type: 'sap.ui.getVersionInfo',
                name: 'Global'
            };
        });
    }
    return VersionInfo._load(mOptions);
};
sap.ui.namespace = function (sNamespace) {
    fnAssert(false, 'sap.ui.namespace is long time deprecated and shouldn\'t be used');
    return ObjectPath.create(sNamespace);
};
sap.ui.lazyRequire = function (sClassName, sMethods, sModuleName) {
    fnAssert(typeof sClassName === 'string' && sClassName, 'lazyRequire: sClassName must be a non-empty string');
    fnAssert(!sMethods || typeof sMethods === 'string', 'lazyRequire: sMethods must be empty or a string');
    if (syncCallBehavior === 2) {
        Log.error('[nosync] lazy stub creation ignored for \'' + sClassName + '\'');
        return;
    }
    var sFullClass = sClassName.replace(/\//gi, '.'), iLastDotPos = sFullClass.lastIndexOf('.'), sPackage = sFullClass.substr(0, iLastDotPos), sClass = sFullClass.substr(iLastDotPos + 1), oPackage = ObjectPath.create(sPackage), oClass = oPackage[sClass], aMethods = (sMethods || 'new').split(' '), iConstructor = aMethods.indexOf('new');
    sModuleName = sModuleName || sFullClass;
    if (!oClass) {
        if (iConstructor >= 0) {
            oClass = function () {
                if (syncCallBehavior) {
                    if (syncCallBehavior === 1) {
                        Log.error('[nosync] lazy stub for constructor \'' + sFullClass + '\' called');
                    }
                } else {
                    Log.debug('lazy stub for constructor \'' + sFullClass + '\' called.');
                }
                sap.ui.requireSync(sModuleName.replace(/\./g, '/'));
                var oRealClass = oPackage[sClass];
                fnAssert(typeof oRealClass === 'function', 'lazyRequire: oRealClass must be a function after loading');
                if (oRealClass._sapUiLazyLoader) {
                    throw new Error('lazyRequire: stub \'' + sFullClass + '\'has not been replaced by module \'' + sModuleName + '\'');
                }
                var oInstance = Object.create(oRealClass.prototype);
                var oResult = oRealClass.apply(oInstance, arguments);
                if (oResult && (typeof oResult === 'function' || typeof oResult === 'object')) {
                    oInstance = oResult;
                }
                return oInstance;
            };
            oClass._sapUiLazyLoader = true;
            aMethods.splice(iConstructor, 1);
        } else {
            oClass = {};
        }
        oPackage[sClass] = oClass;
    }
    aMethods.forEach(function (sMethod) {
        if (!oClass[sMethod]) {
            oClass[sMethod] = function () {
                if (syncCallBehavior) {
                    if (syncCallBehavior === 1) {
                        Log.error('[no-sync] lazy stub for method \'' + sFullClass + '.' + sMethod + '\' called');
                    }
                } else {
                    Log.debug('lazy stub for method \'' + sFullClass + '.' + sMethod + '\' called.');
                }
                sap.ui.requireSync(sModuleName.replace(/\./g, '/'));
                var oRealClass = oPackage[sClass];
                fnAssert(typeof oRealClass === 'function' || typeof oRealClass === 'object', 'lazyRequire: oRealClass must be a function or object after loading');
                fnAssert(typeof oRealClass[sMethod] === 'function', 'lazyRequire: method must be a function');
                if (oRealClass[sMethod]._sapUiLazyLoader) {
                    throw new Error('lazyRequire: stub \'' + sFullClass + '.' + sMethod + '\' has not been replaced by loaded module \'' + sModuleName + '\'');
                }
                return oRealClass[sMethod].apply(oRealClass, arguments);
            };
            oClass[sMethod]._sapUiLazyLoader = true;
        }
    });
};
sap.ui.lazyRequire._isStub = function (sClassName) {
    fnAssert(typeof sClassName === 'string' && sClassName, 'lazyRequire._isStub: sClassName must be a non-empty string');
    var iLastDotPos = sClassName.lastIndexOf('.'), sContext = sClassName.slice(0, iLastDotPos), sProperty = sClassName.slice(iLastDotPos + 1), oContext = ObjectPath.get(sContext || '');
    return !!(oContext && typeof oContext[sProperty] === 'function' && oContext[sProperty]._sapUiLazyLoader);
};
sap.ui.resource = function (sLibraryName, sResourcePath) {
    fnAssert(typeof sLibraryName === 'string', 'sLibraryName must be a string');
    fnAssert(typeof sResourcePath === 'string', 'sResourcePath must be a string');
    return sap.ui.require.toUrl((String(sLibraryName).replace(/\./g, '/') + '/' + sResourcePath).replace(/^\/*/, ''));
};
sap.ui.localResources = function (sNamespace) {
    fnAssert(sNamespace, 'sNamespace must not be empty');
    var mPaths = {};
    mPaths[sNamespace.replace(/\./g, '/')] = './' + sNamespace.replace(/\./g, '/');
    sap.ui.loader.config({ paths: mPaths });
};
var Global = sap.ui;

var BaseObject;
var Interface = function (oObject, aMethods, bFacade) {
  if (!oObject) {
    return oObject;
  }
  BaseObject = BaseObject || sap.ui.requireSync("sap/ui/base/Object");
  function fCreateDelegator(oObject, sMethodName) {
    return function () {
      var tmp = oObject[sMethodName].apply(oObject, arguments);
      if (bFacade) {
        return this;
      } else {
        return tmp instanceof BaseObject ? tmp.getInterface() : tmp;
      }
    };
  }
  if (!aMethods) {
    return {};
  }
  var sMethodName;
  for (var i = 0, ml = aMethods.length; i < ml; i++) {
    sMethodName = aMethods[i];
    if (!oObject[sMethodName] || typeof oObject[sMethodName] === "function") {
      this[sMethodName] = fCreateDelegator(oObject, sMethodName);
    }
  }
};

var fnUniqueSort = function (aArray) {
    fnAssert(aArray instanceof Array, 'uniqueSort: input parameter must be an Array');
    var l = aArray.length;
    if (l > 1) {
        aArray.sort();
        var j = 0;
        for (var i = 1; i < l; i++) {
            if (aArray[i] !== aArray[j]) {
                aArray[++j] = aArray[i];
            }
        }
        if (++j < l) {
            aArray.splice(j, l - j);
        }
    }
    return aArray;
};

var Metadata = function (sClassName, oClassInfo) {
    fnAssert(typeof sClassName === 'string' && sClassName, 'Metadata: sClassName must be a non-empty string');
    fnAssert(typeof oClassInfo === 'object', 'Metadata: oClassInfo must be empty or an object');
    if (!oClassInfo || typeof oClassInfo.metadata !== 'object') {
        oClassInfo = {
            metadata: oClassInfo || {},
            constructor: ObjectPath.get(sClassName)
        };
        oClassInfo.metadata.__version = 1;
    }
    oClassInfo.metadata.__version = oClassInfo.metadata.__version || 2;
    if (typeof oClassInfo.constructor !== 'function') {
        throw Error('constructor for class ' + sClassName + ' must have been declared before creating metadata for it');
    }
    this._sClassName = sClassName;
    this._oClass = oClassInfo.constructor;
    this.extend(oClassInfo);
};
Metadata.prototype.extend = function (oClassInfo) {
    this.applySettings(oClassInfo);
    this.afterApplySettings();
};
Metadata.prototype.applySettings = function (oClassInfo) {
    var that = this, oStaticInfo = oClassInfo.metadata, oPrototype;
    if (oStaticInfo.baseType) {
        var oParentClass = ObjectPath.get(oStaticInfo.baseType);
        if (typeof oParentClass !== 'function') {
            Log.fatal('base class \'' + oStaticInfo.baseType + '\' does not exist');
        }
        if (oParentClass.getMetadata) {
            this._oParent = oParentClass.getMetadata();
            fnAssert(oParentClass === oParentClass.getMetadata().getClass(), 'Metadata: oParentClass must match the class in the parent metadata');
        } else {
            this._oParent = new Metadata(oStaticInfo.baseType, {});
        }
    } else {
        this._oParent = undefined;
    }
    this._bAbstract = !!oStaticInfo['abstract'];
    this._bFinal = !!oStaticInfo['final'];
    this._sStereotype = oStaticInfo.stereotype || (this._oParent ? this._oParent._sStereotype : 'object');
    this._bDeprecated = !!oStaticInfo['deprecated'];
    this._aInterfaces = oStaticInfo.interfaces || [];
    this._aPublicMethods = oStaticInfo.publicMethods || [];
    this._bInterfacesUnique = false;
    oPrototype = this._oClass.prototype;
    for (var n in oClassInfo) {
        if (n !== 'metadata' && n !== 'constructor') {
            oPrototype[n] = oClassInfo[n];
            if (!n.match(/^_|^on|^init$|^exit$/)) {
                that._aPublicMethods.push(n);
            }
        }
    }
};
Metadata.prototype.afterApplySettings = function () {
    if (this._oParent) {
        this._aAllPublicMethods = this._oParent._aAllPublicMethods.concat(this._aPublicMethods);
        this._bInterfacesUnique = false;
    } else {
        this._aAllPublicMethods = this._aPublicMethods;
    }
};
Metadata.prototype.getStereotype = function () {
    return this._sStereotype;
};
Metadata.prototype.getName = function () {
    return this._sClassName;
};
Metadata.prototype.getClass = function () {
    return this._oClass;
};
Metadata.prototype.getParent = function () {
    return this._oParent;
};
Metadata.prototype._dedupInterfaces = function () {
    if (!this._bInterfacesUnique) {
        fnUniqueSort(this._aInterfaces);
        fnUniqueSort(this._aPublicMethods);
        fnUniqueSort(this._aAllPublicMethods);
        this._bInterfacesUnique = true;
    }
};
Metadata.prototype.getPublicMethods = function () {
    this._dedupInterfaces();
    return this._aPublicMethods;
};
Metadata.prototype.getAllPublicMethods = function () {
    this._dedupInterfaces();
    return this._aAllPublicMethods;
};
Metadata.prototype.getInterfaces = function () {
    this._dedupInterfaces();
    return this._aInterfaces;
};
Metadata.prototype.isInstanceOf = function (sInterface) {
    if (this._oParent) {
        if (this._oParent.isInstanceOf(sInterface)) {
            return true;
        }
    }
    var a = this._aInterfaces;
    for (var i = 0, l = a.length; i < l; i++) {
        if (a[i] === sInterface) {
            return true;
        }
    }
    return false;
};
var WRITABLE_IFF_PHANTOM = !!Device.browser.phantomJS;
Object.defineProperty(Metadata.prototype, '_mImplementedTypes', {
    get: function () {
        if (this === Metadata.prototype) {
            throw new Error('sap.ui.base.Metadata: The \'_mImplementedTypes\' property must not be accessed on the prototype');
        }
        var result = Object.create(this._oParent ? this._oParent._mImplementedTypes : null);
        result[this._sClassName] = true;
        var aInterfaces = this._aInterfaces, i = aInterfaces.length;
        while (i-- > 0) {
            if (!result[aInterfaces[i]]) {
                result[aInterfaces[i]] = true;
            }
        }
        Object.defineProperty(this, '_mImplementedTypes', {
            value: Object.freeze(result),
            writable: WRITABLE_IFF_PHANTOM,
            configurable: false
        });
        return result;
    },
    configurable: true
});
Metadata.prototype.isA = function (vTypeName) {
    var mTypes = this._mImplementedTypes;
    if (Array.isArray(vTypeName)) {
        for (var i = 0; i < vTypeName.length; i++) {
            if (vTypeName[i] in mTypes) {
                return true;
            }
        }
        return false;
    }
    return vTypeName in mTypes;
};
Metadata.prototype.isAbstract = function () {
    return this._bAbstract;
};
Metadata.prototype.isFinal = function () {
    return this._bFinal;
};
Metadata.prototype.isDeprecated = function () {
    return this._bDeprecated;
};
Metadata.prototype.addPublicMethods = function (sMethod) {
    var aNames = sMethod instanceof Array ? sMethod : arguments;
    Array.prototype.push.apply(this._aPublicMethods, aNames);
    Array.prototype.push.apply(this._aAllPublicMethods, aNames);
    this._bInterfacesUnique = false;
};
Metadata.createClass = function (fnBaseClass, sClassName, oClassInfo, FNMetaImpl) {
    if (typeof fnBaseClass === 'string') {
        FNMetaImpl = oClassInfo;
        oClassInfo = sClassName;
        sClassName = fnBaseClass;
        fnBaseClass = null;
    }
    fnAssert(!fnBaseClass || typeof fnBaseClass === 'function');
    fnAssert(typeof sClassName === 'string' && !!sClassName);
    fnAssert(!oClassInfo || typeof oClassInfo === 'object');
    fnAssert(!FNMetaImpl || typeof FNMetaImpl === 'function');
    FNMetaImpl = FNMetaImpl || Metadata;
    if (typeof FNMetaImpl.preprocessClassInfo === 'function') {
        oClassInfo = FNMetaImpl.preprocessClassInfo(oClassInfo);
    }
    oClassInfo = oClassInfo || {};
    oClassInfo.metadata = oClassInfo.metadata || {};
    if (!oClassInfo.hasOwnProperty('constructor')) {
        oClassInfo.constructor = undefined;
    }
    var fnClass = oClassInfo.constructor;
    fnAssert(!fnClass || typeof fnClass === 'function');
    if (fnBaseClass) {
        if (!fnClass) {
            if (oClassInfo.metadata.deprecated) {
                fnClass = function () {
                    Log.warning('Usage of deprecated class: ' + sClassName);
                    fnBaseClass.apply(this, arguments);
                };
            } else {
                fnClass = function () {
                    fnBaseClass.apply(this, arguments);
                };
            }
        }
        fnClass.prototype = Object.create(fnBaseClass.prototype);
        fnClass.prototype.constructor = fnClass;
        oClassInfo.metadata.baseType = fnBaseClass.getMetadata().getName();
    } else {
        fnClass = fnClass || function () {
        };
        delete oClassInfo.metadata.baseType;
    }
    oClassInfo.constructor = fnClass;
    ObjectPath.set(sClassName, fnClass);
    var oMetadata = new FNMetaImpl(sClassName, oClassInfo);
    fnClass.getMetadata = fnClass.prototype.getMetadata = function () {
        return oMetadata;
    };
    if (!fnClass.getMetadata().isFinal()) {
        fnClass.extend = function (sSCName, oSCClassInfo, fnSCMetaImpl) {
            return Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
        };
    }
    return fnClass;
};

var BaseObject$1 = Metadata.createClass('sap.ui.base.Object', {
    constructor: function () {
        if (!(this instanceof BaseObject$1)) {
            throw Error('Cannot instantiate object: "new" is missing!');
        }
    }
});
BaseObject$1.prototype.destroy = function () {
};
BaseObject$1.prototype.getInterface = function () {
    var oInterface = new Interface(this, this.getMetadata().getAllPublicMethods());
    this.getInterface = function () {
        return oInterface;
    };
    return oInterface;
};
BaseObject$1.defineClass = function (sClassName, oStaticInfo, FNMetaImpl) {
    var oMetadata = new (FNMetaImpl || Metadata)(sClassName, oStaticInfo);
    var fnClass = oMetadata.getClass();
    fnClass.getMetadata = fnClass.prototype.getMetadata = function () {
        return oMetadata;
    };
    if (!oMetadata.isFinal()) {
        fnClass.extend = function (sSCName, oSCClassInfo, fnSCMetaImpl) {
            return Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
        };
    }
    Log.debug('defined class \'' + sClassName + '\'' + (oMetadata.getParent() ? ' as subclass of ' + oMetadata.getParent().getName() : ''));
    return oMetadata;
};
BaseObject$1.prototype.isA = function (vTypeName) {
    return this.getMetadata().isA(vTypeName);
};
BaseObject$1.isA = function (oObject, vTypeName) {
    return oObject instanceof BaseObject$1 && oObject.isA(vTypeName);
};

var CalendarType = {
  Gregorian: "Gregorian",
  Islamic: "Islamic",
  Japanese: "Japanese",
  Persian: "Persian",
  Buddhist: "Buddhist"
};

var rLocale = /^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?((?:-[0-9A-Z]{5,8}|-[0-9][0-9A-Z]{3})*)((?:-[0-9A-WYZ](?:-[0-9A-Z]{2,8})+)*)(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;
var Locale = BaseObject$1.extend('sap.ui.core.Locale', {
    constructor: function (sLocaleId) {
        BaseObject$1.apply(this);
        var aResult = rLocale.exec(sLocaleId.replace(/_/g, '-'));
        if (aResult === null) {
            throw 'The given language \'' + sLocaleId + '\' does not adhere to BCP-47.';
        }
        this.sLocaleId = sLocaleId;
        this.sLanguage = aResult[1] || null;
        this.sScript = aResult[2] || null;
        this.sRegion = aResult[3] || null;
        this.sVariant = aResult[4] && aResult[4].slice(1) || null;
        this.sExtension = aResult[5] && aResult[5].slice(1) || null;
        this.sPrivateUse = aResult[6] || null;
        if (this.sLanguage) {
            this.sLanguage = this.sLanguage.toLowerCase();
        }
        if (this.sScript) {
            this.sScript = this.sScript.toLowerCase().replace(/^[a-z]/, function ($) {
                return $.toUpperCase();
            });
        }
        if (this.sRegion) {
            this.sRegion = this.sRegion.toUpperCase();
        }
    },
    getLanguage: function () {
        return this.sLanguage;
    },
    getScript: function () {
        return this.sScript;
    },
    getRegion: function () {
        return this.sRegion;
    },
    getVariant: function () {
        return this.sVariant;
    },
    getVariantSubtags: function () {
        return this.sVariant ? this.sVariant.split('-') : [];
    },
    getExtension: function () {
        return this.sExtension;
    },
    getExtensionSubtags: function () {
        return this.sExtension ? this.sExtension.slice(2).split('-') : [];
    },
    getPrivateUse: function () {
        return this.sPrivateUse;
    },
    getPrivateUseSubtags: function () {
        return this.sPrivateUse ? this.sPrivateUse.slice(2).split('-') : [];
    },
    hasPrivateUseSubtag: function (sSubtag) {
        fnAssert(sSubtag && sSubtag.match(/^[0-9A-Z]{1,8}$/i), 'subtag must be a valid BCP47 private use tag');
        return this.getPrivateUseSubtags().indexOf(sSubtag) >= 0;
    },
    toString: function () {
        var r = [this.sLanguage];
        if (this.sScript) {
            r.push(this.sScript);
        }
        if (this.sRegion) {
            r.push(this.sRegion);
        }
        if (this.sVariant) {
            r.push(this.sVariant);
        }
        if (this.sExtension) {
            r.push(this.sExtension);
        }
        if (this.sPrivateUse) {
            r.push(this.sPrivateUse);
        }
        return r.join('-');
    },
    getSAPLogonLanguage: function () {
        var sLanguage = this.sLanguage || '', m;
        if (sLanguage.indexOf('-') >= 0) {
            sLanguage = sLanguage.slice(0, sLanguage.indexOf('-'));
        }
        sLanguage = M_ISO639_OLD_TO_NEW[sLanguage] || sLanguage;
        if (sLanguage === 'zh') {
            if (this.sScript === 'Hant' || !this.sScript && this.sRegion === 'TW') {
                sLanguage = 'zf';
            }
        }
        if (this.sPrivateUse && (m = /-(saptrc|sappsd)(?:-|$)/i.exec(this.sPrivateUse))) {
            sLanguage = m[1].toLowerCase() === 'saptrc' ? '1Q' : '2Q';
        }
        return sLanguage.toUpperCase();
    }
});
var M_ISO639_OLD_TO_NEW = {
    'iw': 'he',
    'ji': 'yi',
    'in': 'id',
    'sh': 'sr'
};
function getDesigntimePropertyAsArray(sValue) {
    var m = /\$([-a-z0-9A-Z._]+)(?::([^$]*))?\$/.exec(sValue);
    return m && m[2] ? m[2].split(/,/) : null;
}
var A_RTL_LOCALES = getDesigntimePropertyAsArray('$cldr-rtl-locales:ar,fa,he$') || [];
Locale._cldrLocales = getDesigntimePropertyAsArray('$cldr-locales:ar,ar_EG,ar_SA,bg,br,ca,cs,da,de,de_AT,de_CH,el,el_CY,en,en_AU,en_GB,en_HK,en_IE,en_IN,en_NZ,en_PG,en_SG,en_ZA,es,es_AR,es_BO,es_CL,es_CO,es_MX,es_PE,es_UY,es_VE,et,fa,fi,fr,fr_BE,fr_CA,fr_CH,fr_LU,he,hi,hr,hu,id,it,it_CH,ja,kk,ko,lt,lv,ms,nb,nl,nl_BE,nn,pl,pt,pt_PT,ro,ru,ru_UA,sk,sl,sr,sv,th,tr,uk,vi,zh_CN,zh_HK,zh_SG,zh_TW$');
Locale._coreI18nLocales = getDesigntimePropertyAsArray('$core-i18n-locales:,ar,bg,ca,cs,da,de,el,en,es,et,fi,fr,hi,hr,hu,it,iw,ja,ko,lt,lv,nl,no,pl,pt,ro,ru,sh,sk,sl,sv,th,tr,uk,vi,zh_CN,zh_TW$');
Locale._impliesRTL = function (vLanguage) {
    var oLocale = vLanguage instanceof Locale ? vLanguage : new Locale(vLanguage);
    var sLanguage = oLocale.getLanguage() || '';
    sLanguage = sLanguage && M_ISO639_OLD_TO_NEW[sLanguage] || sLanguage;
    var sRegion = oLocale.getRegion() || '';
    if (sRegion && A_RTL_LOCALES.indexOf(sLanguage + '_' + sRegion) >= 0) {
        return true;
    }
    return A_RTL_LOCALES.indexOf(sLanguage) >= 0;
};

(function (root, factory) {
  root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
})(window, function (punycode, IPv6, SLD, root) {
  var _URI = root && root.URI;
  function URI(url, base) {
    var _urlSupplied = arguments.length >= 1;
    var _baseSupplied = arguments.length >= 2;
    if (!(this instanceof URI)) {
      if (_urlSupplied) {
        if (_baseSupplied) {
          return new URI(url, base);
        }
        return new URI(url);
      }
      return new URI();
    }
    if (url === undefined) {
      if (_urlSupplied) {
        throw new TypeError("undefined is not a valid argument for URI");
      }
      if (typeof location !== "undefined") {
        url = location.href + "";
      } else {
        url = "";
      }
    }
    if (url === null) {
      if (_urlSupplied) {
        throw new TypeError("null is not a valid argument for URI");
      }
    }
    this.href(url);
    if (base !== undefined) {
      return this.absoluteTo(base);
    }
    return this;
  }
  function isInteger(value) {
    return (/^[0-9]+$/).test(value);
  }
  URI.version = "1.19.1";
  var p = URI.prototype;
  var hasOwn = Object.prototype.hasOwnProperty;
  function escapeRegEx(string) {
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  function getType(value) {
    if (value === undefined) {
      return "Undefined";
    }
    return String(Object.prototype.toString.call(value)).slice(8, -1);
  }
  function isArray(obj) {
    return getType(obj) === "Array";
  }
  function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;
    if (getType(value) === "RegExp") {
      lookup = null;
    } else if (isArray(value)) {
      for ((i = 0, length = value.length); i < length; i++) {
        lookup[value[i]] = true;
      }
    } else {
      lookup[value] = true;
    }
    for ((i = 0, length = data.length); i < length; i++) {
      var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);
      if (_match) {
        data.splice(i, 1);
        length--;
        i--;
      }
    }
    return data;
  }
  function arrayContains(list, value) {
    var i, length;
    if (isArray(value)) {
      for ((i = 0, length = value.length); i < length; i++) {
        if (!arrayContains(list, value[i])) {
          return false;
        }
      }
      return true;
    }
    var _type = getType(value);
    for ((i = 0, length = list.length); i < length; i++) {
      if (_type === "RegExp") {
        if (typeof list[i] === "string" && list[i].match(value)) {
          return true;
        }
      } else if (list[i] === value) {
        return true;
      }
    }
    return false;
  }
  function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
      return false;
    }
    if (one.length !== two.length) {
      return false;
    }
    one.sort();
    two.sort();
    for (var i = 0, l = one.length; i < l; i++) {
      if (one[i] !== two[i]) {
        return false;
      }
    }
    return true;
  }
  function trimSlashes(text) {
    var trim_expression = /^\/+|\/+$/g;
    return text.replace(trim_expression, "");
  }
  URI._parts = function () {
    return {
      protocol: null,
      username: null,
      password: null,
      hostname: null,
      urn: null,
      port: null,
      path: null,
      query: null,
      fragment: null,
      preventInvalidHostname: URI.preventInvalidHostname,
      duplicateQueryParameters: URI.duplicateQueryParameters,
      escapeQuerySpace: URI.escapeQuerySpace
    };
  };
  URI.preventInvalidHostname = false;
  URI.duplicateQueryParameters = false;
  URI.escapeQuerySpace = true;
  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
  URI.idn_expression = /[^a-z0-9\._-]/i;
  URI.punycode_expression = /(xn--)/i;
  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
  URI.findUri = {
    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
    end: /[\s\r\n]|$/,
    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
    parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
  };
  URI.defaultPorts = {
    http: "80",
    https: "443",
    ftp: "21",
    gopher: "70",
    ws: "80",
    wss: "443"
  };
  URI.hostProtocols = ["http", "https"];
  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
  URI.domAttributes = {
    "a": "href",
    "blockquote": "cite",
    "link": "href",
    "base": "href",
    "script": "src",
    "form": "action",
    "img": "src",
    "area": "href",
    "iframe": "src",
    "embed": "src",
    "source": "src",
    "track": "src",
    "input": "src",
    "audio": "src",
    "video": "src"
  };
  URI.getDomAttribute = function (node) {
    if (!node || !node.nodeName) {
      return undefined;
    }
    var nodeName = node.nodeName.toLowerCase();
    if (nodeName === "input" && node.type !== "image") {
      return undefined;
    }
    return URI.domAttributes[nodeName];
  };
  function escapeForDumbFirefox36(value) {
    return escape(value);
  }
  function strictEncodeURIComponent(string) {
    return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
  }
  URI.encode = strictEncodeURIComponent;
  URI.decode = decodeURIComponent;
  URI.iso8859 = function () {
    URI.encode = escape;
    URI.decode = unescape;
  };
  URI.unicode = function () {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
  };
  URI.characters = {
    pathname: {
      encode: {
        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
        map: {
          "%24": "$",
          "%26": "&",
          "%2B": "+",
          "%2C": ",",
          "%3B": ";",
          "%3D": "=",
          "%3A": ":",
          "%40": "@"
        }
      },
      decode: {
        expression: /[\/\?#]/g,
        map: {
          "/": "%2F",
          "?": "%3F",
          "#": "%23"
        }
      }
    },
    reserved: {
      encode: {
        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
        map: {
          "%3A": ":",
          "%2F": "/",
          "%3F": "?",
          "%23": "#",
          "%5B": "[",
          "%5D": "]",
          "%40": "@",
          "%21": "!",
          "%24": "$",
          "%26": "&",
          "%27": "'",
          "%28": "(",
          "%29": ")",
          "%2A": "*",
          "%2B": "+",
          "%2C": ",",
          "%3B": ";",
          "%3D": "="
        }
      }
    },
    urnpath: {
      encode: {
        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
        map: {
          "%21": "!",
          "%24": "$",
          "%27": "'",
          "%28": "(",
          "%29": ")",
          "%2A": "*",
          "%2B": "+",
          "%2C": ",",
          "%3B": ";",
          "%3D": "=",
          "%40": "@"
        }
      },
      decode: {
        expression: /[\/\?#:]/g,
        map: {
          "/": "%2F",
          "?": "%3F",
          "#": "%23",
          ":": "%3A"
        }
      }
    }
  };
  URI.encodeQuery = function (string, escapeQuerySpace) {
    var escaped = URI.encode(string + "");
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }
    return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
  };
  URI.decodeQuery = function (string, escapeQuerySpace) {
    string += "";
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }
    try {
      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
    } catch (e) {
      return string;
    }
  };
  var _parts = {
    "encode": "encode",
    "decode": "decode"
  };
  var _part;
  var generateAccessor = function (_group, _part) {
    return function (string) {
      try {
        return URI[_part](string + "").replace(URI.characters[_group][_part].expression, function (c) {
          return URI.characters[_group][_part].map[c];
        });
      } catch (e) {
        return string;
      }
    };
  };
  for (_part in _parts) {
    URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
    URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
  }
  var generateSegmentedPathFunction = function (_sep, _codingFuncName, _innerCodingFuncName) {
    return function (string) {
      var actualCodingFunc;
      if (!_innerCodingFuncName) {
        actualCodingFunc = URI[_codingFuncName];
      } else {
        actualCodingFunc = function (string) {
          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
        };
      }
      var segments = (string + "").split(_sep);
      for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = actualCodingFunc(segments[i]);
      }
      return segments.join(_sep);
    };
  };
  URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
  URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
  URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
  URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
  URI.encodeReserved = generateAccessor("reserved", "encode");
  URI.parse = function (string, parts) {
    var pos;
    if (!parts) {
      parts = {
        preventInvalidHostname: URI.preventInvalidHostname
      };
    }
    pos = string.indexOf("#");
    if (pos > -1) {
      parts.fragment = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }
    pos = string.indexOf("?");
    if (pos > -1) {
      parts.query = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }
    if (string.substring(0, 2) === "//") {
      parts.protocol = null;
      string = string.substring(2);
      string = URI.parseAuthority(string, parts);
    } else {
      pos = string.indexOf(":");
      if (pos > -1) {
        parts.protocol = string.substring(0, pos) || null;
        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
          parts.protocol = undefined;
        } else if (string.substring(pos + 1, pos + 3) === "//") {
          string = string.substring(pos + 3);
          string = URI.parseAuthority(string, parts);
        } else {
          string = string.substring(pos + 1);
          parts.urn = true;
        }
      }
    }
    parts.path = string;
    return parts;
  };
  URI.parseHost = function (string, parts) {
    if (!string) {
      string = "";
    }
    string = string.replace(/\\/g, "/");
    var pos = string.indexOf("/");
    var bracketPos;
    var t;
    if (pos === -1) {
      pos = string.length;
    }
    if (string.charAt(0) === "[") {
      bracketPos = string.indexOf("]");
      parts.hostname = string.substring(1, bracketPos) || null;
      parts.port = string.substring(bracketPos + 2, pos) || null;
      if (parts.port === "/") {
        parts.port = null;
      }
    } else {
      var firstColon = string.indexOf(":");
      var firstSlash = string.indexOf("/");
      var nextColon = string.indexOf(":", firstColon + 1);
      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
      } else {
        t = string.substring(0, pos).split(":");
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
      }
    }
    if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
      pos++;
      string = "/" + string;
    }
    if (parts.preventInvalidHostname) {
      URI.ensureValidHostname(parts.hostname, parts.protocol);
    }
    if (parts.port) {
      URI.ensureValidPort(parts.port);
    }
    return string.substring(pos) || "/";
  };
  URI.parseAuthority = function (string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
  };
  URI.parseUserinfo = function (string, parts) {
    var firstSlash = string.indexOf("/");
    var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
    var t;
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
      t = string.substring(0, pos).split(":");
      parts.username = t[0] ? URI.decode(t[0]) : null;
      t.shift();
      parts.password = t[0] ? URI.decode(t.join(":")) : null;
      string = string.substring(pos + 1);
    } else {
      parts.username = null;
      parts.password = null;
    }
    return string;
  };
  URI.parseQuery = function (string, escapeQuerySpace) {
    if (!string) {
      return {};
    }
    string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
    if (!string) {
      return {};
    }
    var items = {};
    var splits = string.split("&");
    var length = splits.length;
    var v, name, value;
    for (var i = 0; i < length; i++) {
      v = splits[i].split("=");
      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
      value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null;
      if (hasOwn.call(items, name)) {
        if (typeof items[name] === "string" || items[name] === null) {
          items[name] = [items[name]];
        }
        items[name].push(value);
      } else {
        items[name] = value;
      }
    }
    return items;
  };
  URI.build = function (parts) {
    var t = "";
    if (parts.protocol) {
      t += parts.protocol + ":";
    }
    if (!parts.urn && (t || parts.hostname)) {
      t += "//";
    }
    t += URI.buildAuthority(parts) || "";
    if (typeof parts.path === "string") {
      if (parts.path.charAt(0) !== "/" && typeof parts.hostname === "string") {
        t += "/";
      }
      t += parts.path;
    }
    if (typeof parts.query === "string" && parts.query) {
      t += "?" + parts.query;
    }
    if (typeof parts.fragment === "string" && parts.fragment) {
      t += "#" + parts.fragment;
    }
    return t;
  };
  URI.buildHost = function (parts) {
    var t = "";
    if (!parts.hostname) {
      return "";
    } else if (URI.ip6_expression.test(parts.hostname)) {
      t += "[" + parts.hostname + "]";
    } else {
      t += parts.hostname;
    }
    if (parts.port) {
      t += ":" + parts.port;
    }
    return t;
  };
  URI.buildAuthority = function (parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
  };
  URI.buildUserinfo = function (parts) {
    var t = "";
    if (parts.username) {
      t += URI.encode(parts.username);
    }
    if (parts.password) {
      t += ":" + URI.encode(parts.password);
    }
    if (t) {
      t += "@";
    }
    return t;
  };
  URI.buildQuery = function (data, duplicateQueryParameters, escapeQuerySpace) {
    var t = "";
    var unique, key, i, length;
    for (key in data) {
      if (hasOwn.call(data, key) && key) {
        if (isArray(data[key])) {
          unique = {};
          for ((i = 0, length = data[key].length); i < length; i++) {
            if (data[key][i] !== undefined && unique[data[key][i] + ""] === undefined) {
              t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
              if (duplicateQueryParameters !== true) {
                unique[data[key][i] + ""] = true;
              }
            }
          }
        } else if (data[key] !== undefined) {
          t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
        }
      }
    }
    return t.substring(1);
  };
  URI.buildQueryParameter = function (name, value, escapeQuerySpace) {
    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
  };
  URI.addQuery = function (data, name, value) {
    if (typeof name === "object") {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.addQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === "string") {
      if (data[name] === undefined) {
        data[name] = value;
        return;
      } else if (typeof data[name] === "string") {
        data[name] = [data[name]];
      }
      if (!isArray(value)) {
        value = [value];
      }
      data[name] = (data[name] || []).concat(value);
    } else {
      throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
    }
  };
  URI.setQuery = function (data, name, value) {
    if (typeof name === "object") {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.setQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === "string") {
      data[name] = value === undefined ? null : value;
    } else {
      throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
    }
  };
  URI.removeQuery = function (data, name, value) {
    var i, length, key;
    if (isArray(name)) {
      for ((i = 0, length = name.length); i < length; i++) {
        data[name[i]] = undefined;
      }
    } else if (getType(name) === "RegExp") {
      for (key in data) {
        if (name.test(key)) {
          data[key] = undefined;
        }
      }
    } else if (typeof name === "object") {
      for (key in name) {
        if (hasOwn.call(name, key)) {
          URI.removeQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === "string") {
      if (value !== undefined) {
        if (getType(value) === "RegExp") {
          if (!isArray(data[name]) && value.test(data[name])) {
            data[name] = undefined;
          } else {
            data[name] = filterArrayValues(data[name], value);
          }
        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
          data[name] = undefined;
        } else if (isArray(data[name])) {
          data[name] = filterArrayValues(data[name], value);
        }
      } else {
        data[name] = undefined;
      }
    } else {
      throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
    }
  };
  URI.hasQuery = function (data, name, value, withinArray) {
    switch (getType(name)) {
      case "String":
        break;
      case "RegExp":
        for (var key in data) {
          if (hasOwn.call(data, key)) {
            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
              return true;
            }
          }
        }
        return false;
      case "Object":
        for (var _key in name) {
          if (hasOwn.call(name, _key)) {
            if (!URI.hasQuery(data, _key, name[_key])) {
              return false;
            }
          }
        }
        return true;
      default:
        throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
    }
    switch (getType(value)) {
      case "Undefined":
        return (name in data);
      case "Boolean":
        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
        return value === _booly;
      case "Function":
        return !!value(data[name], name, data);
      case "Array":
        if (!isArray(data[name])) {
          return false;
        }
        var op = withinArray ? arrayContains : arraysEqual;
        return op(data[name], value);
      case "RegExp":
        if (!isArray(data[name])) {
          return Boolean(data[name] && data[name].match(value));
        }
        if (!withinArray) {
          return false;
        }
        return arrayContains(data[name], value);
      case "Number":
        value = String(value);
      case "String":
        if (!isArray(data[name])) {
          return data[name] === value;
        }
        if (!withinArray) {
          return false;
        }
        return arrayContains(data[name], value);
      default:
        throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
    }
  };
  URI.joinPaths = function () {
    var input = [];
    var segments = [];
    var nonEmptySegments = 0;
    for (var i = 0; i < arguments.length; i++) {
      var url = new URI(arguments[i]);
      input.push(url);
      var _segments = url.segment();
      for (var s = 0; s < _segments.length; s++) {
        if (typeof _segments[s] === "string") {
          segments.push(_segments[s]);
        }
        if (_segments[s]) {
          nonEmptySegments++;
        }
      }
    }
    if (!segments.length || !nonEmptySegments) {
      return new URI("");
    }
    var uri = new URI("").segment(segments);
    if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
      uri.path("/" + uri.path());
    }
    return uri.normalize();
  };
  URI.commonPath = function (one, two) {
    var length = Math.min(one.length, two.length);
    var pos;
    for (pos = 0; pos < length; pos++) {
      if (one.charAt(pos) !== two.charAt(pos)) {
        pos--;
        break;
      }
    }
    if (pos < 1) {
      return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
    }
    if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
      pos = one.substring(0, pos).lastIndexOf("/");
    }
    return one.substring(0, pos + 1);
  };
  URI.withinString = function (string, callback, options) {
    options || (options = {});
    var _start = options.start || URI.findUri.start;
    var _end = options.end || URI.findUri.end;
    var _trim = options.trim || URI.findUri.trim;
    var _parens = options.parens || URI.findUri.parens;
    var _attributeOpen = /[a-z0-9-]=["']?$/i;
    _start.lastIndex = 0;
    while (true) {
      var match = _start.exec(string);
      if (!match) {
        break;
      }
      var start = match.index;
      if (options.ignoreHtml) {
        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
          continue;
        }
      }
      var end = start + string.slice(start).search(_end);
      var slice = string.slice(start, end);
      var parensEnd = -1;
      while (true) {
        var parensMatch = _parens.exec(slice);
        if (!parensMatch) {
          break;
        }
        var parensMatchEnd = parensMatch.index + parensMatch[0].length;
        parensEnd = Math.max(parensEnd, parensMatchEnd);
      }
      if (parensEnd > -1) {
        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
      } else {
        slice = slice.replace(_trim, "");
      }
      if (slice.length <= match[0].length) {
        continue;
      }
      if (options.ignore && options.ignore.test(slice)) {
        continue;
      }
      end = start + slice.length;
      var result = callback(slice, start, end, string);
      if (result === undefined) {
        _start.lastIndex = end;
        continue;
      }
      result = String(result);
      string = string.slice(0, start) + result + string.slice(end);
      _start.lastIndex = start + result.length;
    }
    _start.lastIndex = 0;
    return string;
  };
  URI.ensureValidHostname = function (v, protocol) {
    var hasHostname = !!v;
    var hasProtocol = !!protocol;
    var rejectEmptyHostname = false;
    if (hasProtocol) {
      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
    }
    if (rejectEmptyHostname && !hasHostname) {
      throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
    } else if (v && v.match(URI.invalid_hostname_characters)) {
      if (!punycode) {
        throw new TypeError("Hostname \"" + v + "\" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available");
      }
      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
        throw new TypeError("Hostname \"" + v + "\" contains characters other than [A-Z0-9.-:_]");
      }
    }
  };
  URI.ensureValidPort = function (v) {
    if (!v) {
      return;
    }
    var port = Number(v);
    if (isInteger(port) && port > 0 && port < 65536) {
      return;
    }
    throw new TypeError("Port \"" + v + "\" is not a valid port");
  };
  URI.noConflict = function (removeAll) {
    if (removeAll) {
      var unconflicted = {
        URI: this.noConflict()
      };
      if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
        unconflicted.URITemplate = root.URITemplate.noConflict();
      }
      if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
        unconflicted.IPv6 = root.IPv6.noConflict();
      }
      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
      }
      return unconflicted;
    } else if (root.URI === this) {
      root.URI = _URI;
    }
    return this;
  };
  p.build = function (deferBuild) {
    if (deferBuild === true) {
      this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
      this._string = URI.build(this._parts);
      this._deferred_build = false;
    }
    return this;
  };
  p.clone = function () {
    return new URI(this);
  };
  p.valueOf = p.toString = function () {
    return this.build(false)._string;
  };
  function generateSimpleAccessor(_part) {
    return function (v, build) {
      if (v === undefined) {
        return this._parts[_part] || "";
      } else {
        this._parts[_part] = v || null;
        this.build(!build);
        return this;
      }
    };
  }
  function generatePrefixAccessor(_part, _key) {
    return function (v, build) {
      if (v === undefined) {
        return this._parts[_part] || "";
      } else {
        if (v !== null) {
          v = v + "";
          if (v.charAt(0) === _key) {
            v = v.substring(1);
          }
        }
        this._parts[_part] = v;
        this.build(!build);
        return this;
      }
    };
  }
  p.protocol = generateSimpleAccessor("protocol");
  p.username = generateSimpleAccessor("username");
  p.password = generateSimpleAccessor("password");
  p.hostname = generateSimpleAccessor("hostname");
  p.port = generateSimpleAccessor("port");
  p.query = generatePrefixAccessor("query", "?");
  p.fragment = generatePrefixAccessor("fragment", "#");
  p.search = function (v, build) {
    var t = this.query(v, build);
    return typeof t === "string" && t.length ? "?" + t : t;
  };
  p.hash = function (v, build) {
    var t = this.fragment(v, build);
    return typeof t === "string" && t.length ? "#" + t : t;
  };
  p.pathname = function (v, build) {
    if (v === undefined || v === true) {
      var res = this._parts.path || (this._parts.hostname ? "/" : "");
      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
    } else {
      if (this._parts.urn) {
        this._parts.path = v ? URI.recodeUrnPath(v) : "";
      } else {
        this._parts.path = v ? URI.recodePath(v) : "/";
      }
      this.build(!build);
      return this;
    }
  };
  p.path = p.pathname;
  p.href = function (href, build) {
    var key;
    if (href === undefined) {
      return this.toString();
    }
    this._string = "";
    this._parts = URI._parts();
    var _URI = href instanceof URI;
    var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
    if (href.nodeName) {
      var attribute = URI.getDomAttribute(href);
      href = href[attribute] || "";
      _object = false;
    }
    if (!_URI && _object && href.pathname !== undefined) {
      href = href.toString();
    }
    if (typeof href === "string" || href instanceof String) {
      this._parts = URI.parse(String(href), this._parts);
    } else if (_URI || _object) {
      var src = _URI ? href._parts : href;
      for (key in src) {
        if (key === "query") {
          continue;
        }
        if (hasOwn.call(this._parts, key)) {
          this._parts[key] = src[key];
        }
      }
      if (src.query) {
        this.query(src.query, false);
      }
    } else {
      throw new TypeError("invalid input");
    }
    this.build(!build);
    return this;
  };
  p.is = function (what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;
    if (this._parts.hostname) {
      relative = false;
      ip4 = URI.ip4_expression.test(this._parts.hostname);
      ip6 = URI.ip6_expression.test(this._parts.hostname);
      ip = ip4 || ip6;
      name = !ip;
      sld = name && SLD && SLD.has(this._parts.hostname);
      idn = name && URI.idn_expression.test(this._parts.hostname);
      punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }
    switch (what.toLowerCase()) {
      case "relative":
        return relative;
      case "absolute":
        return !relative;
      case "domain":
      case "name":
        return name;
      case "sld":
        return sld;
      case "ip":
        return ip;
      case "ip4":
      case "ipv4":
      case "inet4":
        return ip4;
      case "ip6":
      case "ipv6":
      case "inet6":
        return ip6;
      case "idn":
        return idn;
      case "url":
        return !this._parts.urn;
      case "urn":
        return !!this._parts.urn;
      case "punycode":
        return punycode;
    }
    return null;
  };
  var _protocol = p.protocol;
  var _port = p.port;
  var _hostname = p.hostname;
  p.protocol = function (v, build) {
    if (v) {
      v = v.replace(/:(\/\/)?$/, "");
      if (!v.match(URI.protocol_expression)) {
        throw new TypeError("Protocol \"" + v + "\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]");
      }
    }
    return _protocol.call(this, v, build);
  };
  p.scheme = p.protocol;
  p.port = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v !== undefined) {
      if (v === 0) {
        v = null;
      }
      if (v) {
        v += "";
        if (v.charAt(0) === ":") {
          v = v.substring(1);
        }
        URI.ensureValidPort(v);
      }
    }
    return _port.call(this, v, build);
  };
  p.hostname = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v !== undefined) {
      var x = {
        preventInvalidHostname: this._parts.preventInvalidHostname
      };
      var res = URI.parseHost(v, x);
      if (res !== "/") {
        throw new TypeError("Hostname \"" + v + "\" contains characters other than [A-Z0-9.-]");
      }
      v = x.hostname;
      if (this._parts.preventInvalidHostname) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }
    }
    return _hostname.call(this, v, build);
  };
  p.origin = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined) {
      var protocol = this.protocol();
      var authority = this.authority();
      if (!authority) {
        return "";
      }
      return (protocol ? protocol + "://" : "") + this.authority();
    } else {
      var origin = URI(v);
      this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
      return this;
    }
  };
  p.host = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined) {
      return this._parts.hostname ? URI.buildHost(this._parts) : "";
    } else {
      var res = URI.parseHost(v, this._parts);
      if (res !== "/") {
        throw new TypeError("Hostname \"" + v + "\" contains characters other than [A-Z0-9.-]");
      }
      this.build(!build);
      return this;
    }
  };
  p.authority = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined) {
      return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
    } else {
      var res = URI.parseAuthority(v, this._parts);
      if (res !== "/") {
        throw new TypeError("Hostname \"" + v + "\" contains characters other than [A-Z0-9.-]");
      }
      this.build(!build);
      return this;
    }
  };
  p.userinfo = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined) {
      var t = URI.buildUserinfo(this._parts);
      return t ? t.substring(0, t.length - 1) : t;
    } else {
      if (v[v.length - 1] !== "@") {
        v += "@";
      }
      URI.parseUserinfo(v, this._parts);
      this.build(!build);
      return this;
    }
  };
  p.resource = function (v, build) {
    var parts;
    if (v === undefined) {
      return this.path() + this.search() + this.hash();
    }
    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
  };
  p.subdomain = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined) {
      if (!this._parts.hostname || this.is("IP")) {
        return "";
      }
      var end = this._parts.hostname.length - this.domain().length - 1;
      return this._parts.hostname.substring(0, end) || "";
    } else {
      var e = this._parts.hostname.length - this.domain().length;
      var sub = this._parts.hostname.substring(0, e);
      var replace = new RegExp("^" + escapeRegEx(sub));
      if (v && v.charAt(v.length - 1) !== ".") {
        v += ".";
      }
      if (v.indexOf(":") !== -1) {
        throw new TypeError("Domains cannot contain colons");
      }
      if (v) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }
      this._parts.hostname = this._parts.hostname.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.domain = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (typeof v === "boolean") {
      build = v;
      v = undefined;
    }
    if (v === undefined) {
      if (!this._parts.hostname || this.is("IP")) {
        return "";
      }
      var t = this._parts.hostname.match(/\./g);
      if (t && t.length < 2) {
        return this._parts.hostname;
      }
      var end = this._parts.hostname.length - this.tld(build).length - 1;
      end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
      return this._parts.hostname.substring(end) || "";
    } else {
      if (!v) {
        throw new TypeError("cannot set domain empty");
      }
      if (v.indexOf(":") !== -1) {
        throw new TypeError("Domains cannot contain colons");
      }
      URI.ensureValidHostname(v, this._parts.protocol);
      if (!this._parts.hostname || this.is("IP")) {
        this._parts.hostname = v;
      } else {
        var replace = new RegExp(escapeRegEx(this.domain()) + "$");
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }
      this.build(!build);
      return this;
    }
  };
  p.tld = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (typeof v === "boolean") {
      build = v;
      v = undefined;
    }
    if (v === undefined) {
      if (!this._parts.hostname || this.is("IP")) {
        return "";
      }
      var pos = this._parts.hostname.lastIndexOf(".");
      var tld = this._parts.hostname.substring(pos + 1);
      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
        return SLD.get(this._parts.hostname) || tld;
      }
      return tld;
    } else {
      var replace;
      if (!v) {
        throw new TypeError("cannot set TLD empty");
      } else if (v.match(/[^a-zA-Z0-9-]/)) {
        if (SLD && SLD.is(v)) {
          replace = new RegExp(escapeRegEx(this.tld()) + "$");
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
          throw new TypeError("TLD \"" + v + "\" contains characters other than [A-Z0-9]");
        }
      } else if (!this._parts.hostname || this.is("IP")) {
        throw new ReferenceError("cannot set TLD on non-domain host");
      } else {
        replace = new RegExp(escapeRegEx(this.tld()) + "$");
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }
      this.build(!build);
      return this;
    }
  };
  p.directory = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined || v === true) {
      if (!this._parts.path && !this._parts.hostname) {
        return "";
      }
      if (this._parts.path === "/") {
        return "/";
      }
      var end = this._parts.path.length - this.filename().length - 1;
      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
      return v ? URI.decodePath(res) : res;
    } else {
      var e = this._parts.path.length - this.filename().length;
      var directory = this._parts.path.substring(0, e);
      var replace = new RegExp("^" + escapeRegEx(directory));
      if (!this.is("relative")) {
        if (!v) {
          v = "/";
        }
        if (v.charAt(0) !== "/") {
          v = "/" + v;
        }
      }
      if (v && v.charAt(v.length - 1) !== "/") {
        v += "/";
      }
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.filename = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (typeof v !== "string") {
      if (!this._parts.path || this._parts.path === "/") {
        return "";
      }
      var pos = this._parts.path.lastIndexOf("/");
      var res = this._parts.path.substring(pos + 1);
      return v ? URI.decodePathSegment(res) : res;
    } else {
      var mutatedDirectory = false;
      if (v.charAt(0) === "/") {
        v = v.substring(1);
      }
      if (v.match(/\.?\//)) {
        mutatedDirectory = true;
      }
      var replace = new RegExp(escapeRegEx(this.filename()) + "$");
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      if (mutatedDirectory) {
        this.normalizePath(build);
      } else {
        this.build(!build);
      }
      return this;
    }
  };
  p.suffix = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? "" : this;
    }
    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === "/") {
        return "";
      }
      var filename = this.filename();
      var pos = filename.lastIndexOf(".");
      var s, res;
      if (pos === -1) {
        return "";
      }
      s = filename.substring(pos + 1);
      res = (/^[a-z0-9%]+$/i).test(s) ? s : "";
      return v ? URI.decodePathSegment(res) : res;
    } else {
      if (v.charAt(0) === ".") {
        v = v.substring(1);
      }
      var suffix = this.suffix();
      var replace;
      if (!suffix) {
        if (!v) {
          return this;
        }
        this._parts.path += "." + URI.recodePath(v);
      } else if (!v) {
        replace = new RegExp(escapeRegEx("." + suffix) + "$");
      } else {
        replace = new RegExp(escapeRegEx(suffix) + "$");
      }
      if (replace) {
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
      }
      this.build(!build);
      return this;
    }
  };
  p.segment = function (segment, v, build) {
    var separator = this._parts.urn ? ":" : "/";
    var path = this.path();
    var absolute = path.substring(0, 1) === "/";
    var segments = path.split(separator);
    if (segment !== undefined && typeof segment !== "number") {
      build = v;
      v = segment;
      segment = undefined;
    }
    if (segment !== undefined && typeof segment !== "number") {
      throw new Error("Bad segment \"" + segment + "\", must be 0-based integer");
    }
    if (absolute) {
      segments.shift();
    }
    if (segment < 0) {
      segment = Math.max(segments.length + segment, 0);
    }
    if (v === undefined) {
      return segment === undefined ? segments : segments[segment];
    } else if (segment === null || segments[segment] === undefined) {
      if (isArray(v)) {
        segments = [];
        for (var i = 0, l = v.length; i < l; i++) {
          if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
            continue;
          }
          if (segments.length && !segments[segments.length - 1].length) {
            segments.pop();
          }
          segments.push(trimSlashes(v[i]));
        }
      } else if (v || typeof v === "string") {
        v = trimSlashes(v);
        if (segments[segments.length - 1] === "") {
          segments[segments.length - 1] = v;
        } else {
          segments.push(v);
        }
      }
    } else {
      if (v) {
        segments[segment] = trimSlashes(v);
      } else {
        segments.splice(segment, 1);
      }
    }
    if (absolute) {
      segments.unshift("");
    }
    return this.path(segments.join(separator), build);
  };
  p.segmentCoded = function (segment, v, build) {
    var segments, i, l;
    if (typeof segment !== "number") {
      build = v;
      v = segment;
      segment = undefined;
    }
    if (v === undefined) {
      segments = this.segment(segment, v, build);
      if (!isArray(segments)) {
        segments = segments !== undefined ? URI.decode(segments) : undefined;
      } else {
        for ((i = 0, l = segments.length); i < l; i++) {
          segments[i] = URI.decode(segments[i]);
        }
      }
      return segments;
    }
    if (!isArray(v)) {
      v = typeof v === "string" || v instanceof String ? URI.encode(v) : v;
    } else {
      for ((i = 0, l = v.length); i < l; i++) {
        v[i] = URI.encode(v[i]);
      }
    }
    return this.segment(segment, v, build);
  };
  var q = p.query;
  p.query = function (v, build) {
    if (v === true) {
      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    } else if (typeof v === "function") {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      var result = v.call(this, data);
      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else if (v !== undefined && typeof v !== "string") {
      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else {
      return q.call(this, v, build);
    }
  };
  p.setQuery = function (name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    if (typeof name === "string" || name instanceof String) {
      data[name] = value !== undefined ? value : null;
    } else if (typeof name === "object") {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          data[key] = name[key];
        }
      }
    } else {
      throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
    }
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== "string") {
      build = value;
    }
    this.build(!build);
    return this;
  };
  p.addQuery = function (name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== "string") {
      build = value;
    }
    this.build(!build);
    return this;
  };
  p.removeQuery = function (name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== "string") {
      build = value;
    }
    this.build(!build);
    return this;
  };
  p.hasQuery = function (name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    return URI.hasQuery(data, name, value, withinArray);
  };
  p.setSearch = p.setQuery;
  p.addSearch = p.addQuery;
  p.removeSearch = p.removeQuery;
  p.hasSearch = p.hasQuery;
  p.normalize = function () {
    if (this._parts.urn) {
      return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
    }
    return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
  };
  p.normalizeProtocol = function (build) {
    if (typeof this._parts.protocol === "string") {
      this._parts.protocol = this._parts.protocol.toLowerCase();
      this.build(!build);
    }
    return this;
  };
  p.normalizeHostname = function (build) {
    if (this._parts.hostname) {
      if (this.is("IDN") && punycode) {
        this._parts.hostname = punycode.toASCII(this._parts.hostname);
      } else if (this.is("IPv6") && IPv6) {
        this._parts.hostname = IPv6.best(this._parts.hostname);
      }
      this._parts.hostname = this._parts.hostname.toLowerCase();
      this.build(!build);
    }
    return this;
  };
  p.normalizePort = function (build) {
    if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
      this._parts.port = null;
      this.build(!build);
    }
    return this;
  };
  p.normalizePath = function (build) {
    var _path = this._parts.path;
    if (!_path) {
      return this;
    }
    if (this._parts.urn) {
      this._parts.path = URI.recodeUrnPath(this._parts.path);
      this.build(!build);
      return this;
    }
    if (this._parts.path === "/") {
      return this;
    }
    _path = URI.recodePath(_path);
    var _was_relative;
    var _leadingParents = "";
    var _parent, _pos;
    if (_path.charAt(0) !== "/") {
      _was_relative = true;
      _path = "/" + _path;
    }
    if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
      _path += "/";
    }
    _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
    if (_was_relative) {
      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
      if (_leadingParents) {
        _leadingParents = _leadingParents[0];
      }
    }
    while (true) {
      _parent = _path.search(/\/\.\.(\/|$)/);
      if (_parent === -1) {
        break;
      } else if (_parent === 0) {
        _path = _path.substring(3);
        continue;
      }
      _pos = _path.substring(0, _parent).lastIndexOf("/");
      if (_pos === -1) {
        _pos = _parent;
      }
      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }
    if (_was_relative && this.is("relative")) {
      _path = _leadingParents + _path.substring(1);
    }
    this._parts.path = _path;
    this.build(!build);
    return this;
  };
  p.normalizePathname = p.normalizePath;
  p.normalizeQuery = function (build) {
    if (typeof this._parts.query === "string") {
      if (!this._parts.query.length) {
        this._parts.query = null;
      } else {
        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
      }
      this.build(!build);
    }
    return this;
  };
  p.normalizeFragment = function (build) {
    if (!this._parts.fragment) {
      this._parts.fragment = null;
      this.build(!build);
    }
    return this;
  };
  p.normalizeSearch = p.normalizeQuery;
  p.normalizeHash = p.normalizeFragment;
  p.iso8859 = function () {
    var e = URI.encode;
    var d = URI.decode;
    URI.encode = escape;
    URI.decode = decodeURIComponent;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };
  p.unicode = function () {
    var e = URI.encode;
    var d = URI.decode;
    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };
  p.readable = function () {
    var uri = this.clone();
    uri.username("").password("").normalize();
    var t = "";
    if (uri._parts.protocol) {
      t += uri._parts.protocol + "://";
    }
    if (uri._parts.hostname) {
      if (uri.is("punycode") && punycode) {
        t += punycode.toUnicode(uri._parts.hostname);
        if (uri._parts.port) {
          t += ":" + uri._parts.port;
        }
      } else {
        t += uri.host();
      }
    }
    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
      t += "/";
    }
    t += uri.path(true);
    if (uri._parts.query) {
      var q = "";
      for (var i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
        var kv = (qp[i] || "").split("=");
        q += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
        if (kv[1] !== undefined) {
          q += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
        }
      }
      t += "?" + q.substring(1);
    }
    t += URI.decodeQuery(uri.hash(), true);
    return t;
  };
  p.absoluteTo = function (base) {
    var resolved = this.clone();
    var properties = ["protocol", "username", "password", "hostname", "port"];
    var basedir, i, p;
    if (this._parts.urn) {
      throw new Error("URNs do not have any generally defined hierarchical components");
    }
    if (!(base instanceof URI)) {
      base = new URI(base);
    }
    if (resolved._parts.protocol) {
      return resolved;
    } else {
      resolved._parts.protocol = base._parts.protocol;
    }
    if (this._parts.hostname) {
      return resolved;
    }
    for (i = 0; p = properties[i]; i++) {
      resolved._parts[p] = base._parts[p];
    }
    if (!resolved._parts.path) {
      resolved._parts.path = base._parts.path;
      if (!resolved._parts.query) {
        resolved._parts.query = base._parts.query;
      }
    } else {
      if (resolved._parts.path.substring(-2) === "..") {
        resolved._parts.path += "/";
      }
      if (resolved.path().charAt(0) !== "/") {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
        resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
        resolved.normalizePath();
      }
    }
    resolved.build();
    return resolved;
  };
  p.relativeTo = function (base) {
    var relative = this.clone().normalize();
    var relativeParts, baseParts, common, relativePath, basePath;
    if (relative._parts.urn) {
      throw new Error("URNs do not have any generally defined hierarchical components");
    }
    base = new URI(base).normalize();
    relativeParts = relative._parts;
    baseParts = base._parts;
    relativePath = relative.path();
    basePath = base.path();
    if (relativePath.charAt(0) !== "/") {
      throw new Error("URI is already relative");
    }
    if (basePath.charAt(0) !== "/") {
      throw new Error("Cannot calculate a URI relative to another relative URI");
    }
    if (relativeParts.protocol === baseParts.protocol) {
      relativeParts.protocol = null;
    }
    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
      return relative.build();
    }
    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
      return relative.build();
    }
    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
      relativeParts.hostname = null;
      relativeParts.port = null;
    } else {
      return relative.build();
    }
    if (relativePath === basePath) {
      relativeParts.path = "";
      return relative.build();
    }
    common = URI.commonPath(relativePath, basePath);
    if (!common) {
      return relative.build();
    }
    var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
    relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
    return relative.build();
  };
  p.equals = function (uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;
    one.normalize();
    two.normalize();
    if (one.toString() === two.toString()) {
      return true;
    }
    one_query = one.query();
    two_query = two.query();
    one.query("");
    two.query("");
    if (one.toString() !== two.toString()) {
      return false;
    }
    if (one_query.length !== two_query.length) {
      return false;
    }
    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
    for (key in one_map) {
      if (hasOwn.call(one_map, key)) {
        if (!isArray(one_map[key])) {
          if (one_map[key] !== two_map[key]) {
            return false;
          }
        } else if (!arraysEqual(one_map[key], two_map[key])) {
          return false;
        }
        checked[key] = true;
      }
    }
    for (key in two_map) {
      if (hasOwn.call(two_map, key)) {
        if (!checked[key]) {
          return false;
        }
      }
    }
    return true;
  };
  p.preventInvalidHostname = function (v) {
    this._parts.preventInvalidHostname = !!v;
    return this;
  };
  p.duplicateQueryParameters = function (v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
  };
  p.escapeQuerySpace = function (v) {
    this._parts.escapeQuerySpace = !!v;
    return this;
  };
  return URI;
});
var URI = window.URI;

var UriParameters = function (sUri) {
  this.mParams = {};
  var sQueryString = sUri;
  if (sQueryString) {
    if (sQueryString.indexOf("#") >= 0) {
      sQueryString = sQueryString.slice(0, sQueryString.indexOf("#"));
    }
    if (sQueryString.indexOf("?") >= 0) {
      sQueryString = sQueryString.slice(sQueryString.indexOf("?") + 1);
      var aParameters = sQueryString.split("&"), mParameters = {}, aParameter, sName, sValue;
      for (var i = 0; i < aParameters.length; i++) {
        aParameter = aParameters[i].split("=");
        sName = decodeURIComponent(aParameter[0]);
        sValue = aParameter.length > 1 ? decodeURIComponent(aParameter[1].replace(/\+/g, " ")) : "";
        if (sName) {
          if (!Object.prototype.hasOwnProperty.call(mParameters, sName)) {
            mParameters[sName] = [];
          }
          mParameters[sName].push(sValue);
        }
      }
      this.mParams = mParameters;
    }
  }
};
UriParameters.prototype = {};
UriParameters.prototype.get = function (sName, bAll) {
  var aValues = Object.prototype.hasOwnProperty.call(this.mParams, sName) ? this.mParams[sName] : [];
  return bAll === true ? aValues : aValues[0] || null;
};

var fnEqual = function (a, b, maxDepth, contains, depth) {
    if (typeof maxDepth == 'boolean') {
        contains = maxDepth;
        maxDepth = undefined;
    }
    if (!depth) {
        depth = 0;
    }
    if (!maxDepth) {
        maxDepth = 10;
    }
    if (depth > maxDepth) {
        Log.warning('deepEqual comparison exceeded maximum recursion depth of ' + maxDepth + '. Treating values as unequal');
        return false;
    }
    if (a === b) {
        return true;
    }
    var bIsReallyNaN = typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
    if (bIsReallyNaN) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (!contains && a.length !== b.length) {
            return false;
        }
        if (a.length > b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i++) {
            if (!fnEqual(a[i], b[i], maxDepth, contains, depth + 1)) {
                return false;
            }
        }
        return true;
    }
    if (typeof a == 'object' && typeof b == 'object') {
        if (!a || !b) {
            return false;
        }
        if (a.constructor !== b.constructor) {
            return false;
        }
        if (!contains && Object.keys(a).length !== Object.keys(b).length) {
            return false;
        }
        if (a instanceof Node) {
            return a.isEqualNode(b);
        }
        if (a instanceof Date) {
            return a.valueOf() === b.valueOf();
        }
        for (var i in a) {
            if (!fnEqual(a[i], b[i], maxDepth, contains, depth + 1)) {
                return false;
            }
        }
        return true;
    }
    return false;
};

var rVersion = /^[0-9]+(?:\.([0-9]+)(?:\.([0-9]+))?)?(.*)$/;
function Version(vMajor, iMinor, iPatch, sSuffix) {
  if (vMajor instanceof Version) {
    return vMajor;
  }
  if (!(this instanceof Version)) {
    return new Version(vMajor, iMinor, iPatch, sSuffix);
  }
  var m;
  if (typeof vMajor === "string") {
    m = rVersion.exec(vMajor);
  } else if (Array.isArray(vMajor)) {
    m = vMajor;
  } else {
    m = arguments;
  }
  m = m || [];
  function norm(v) {
    v = parseInt(v);
    return isNaN(v) ? 0 : v;
  }
  vMajor = norm(m[0]);
  iMinor = norm(m[1]);
  iPatch = norm(m[2]);
  sSuffix = String(m[3] || "");
  this.toString = function () {
    return vMajor + "." + iMinor + "." + iPatch + sSuffix;
  };
  this.getMajor = function () {
    return vMajor;
  };
  this.getMinor = function () {
    return iMinor;
  };
  this.getPatch = function () {
    return iPatch;
  };
  this.getSuffix = function () {
    return sSuffix;
  };
  this.compareTo = function () {
    var vOther = Version.apply(window, arguments);
    return vMajor - vOther.getMajor() || iMinor - vOther.getMinor() || iPatch - vOther.getPatch() || (sSuffix < vOther.getSuffix() ? -1 : sSuffix === vOther.getSuffix() ? 0 : 1);
  };
}
Version.prototype.inRange = function (vMin, vMax) {
  return this.compareTo(vMin) >= 0 && this.compareTo(vMax) < 0;
};

var LocaleData = BaseObject$1.extend('sap.ui.core.LocaleData', {
    constructor: function (oLocale) {
        this.oLocale = oLocale;
        BaseObject$1.apply(this);
        this.mData = getData(oLocale);
    },
    _get: function () {
        return this._getDeep(this.mData, arguments);
    },
    _getMerged: function () {
        return this._get.apply(this, arguments);
    },
    _getDeep: function (oObject, aPropertyNames) {
        var oResult = oObject;
        for (var i = 0; i < aPropertyNames.length; i++) {
            oResult = oResult[aPropertyNames[i]];
            if (oResult === undefined) {
                break;
            }
        }
        return oResult;
    },
    getOrientation: function () {
        return this._get('orientation');
    },
    getLanguages: function () {
        return this._get('languages');
    },
    getScripts: function () {
        return this._get('scripts');
    },
    getTerritories: function () {
        return this._get('territories');
    },
    getMonths: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        return this._get(getCLDRCalendarName(sCalendarType), 'months', 'format', sWidth);
    },
    getMonthsStandAlone: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        return this._get(getCLDRCalendarName(sCalendarType), 'months', 'stand-alone', sWidth);
    },
    getDays: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide' || sWidth == 'short', 'sWidth must be narrow, abbreviate, wide or short');
        return this._get(getCLDRCalendarName(sCalendarType), 'days', 'format', sWidth);
    },
    getDaysStandAlone: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide' || sWidth == 'short', 'sWidth must be narrow, abbreviated, wide or short');
        return this._get(getCLDRCalendarName(sCalendarType), 'days', 'stand-alone', sWidth);
    },
    getQuarters: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        return this._get(getCLDRCalendarName(sCalendarType), 'quarters', 'format', sWidth);
    },
    getQuartersStandAlone: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        return this._get(getCLDRCalendarName(sCalendarType), 'quarters', 'stand-alone', sWidth);
    },
    getDayPeriods: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        return this._get(getCLDRCalendarName(sCalendarType), 'dayPeriods', 'format', sWidth);
    },
    getDayPeriodsStandAlone: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        return this._get(getCLDRCalendarName(sCalendarType), 'dayPeriods', 'stand-alone', sWidth);
    },
    getDatePattern: function (sStyle, sCalendarType) {
        fnAssert(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        return this._get(getCLDRCalendarName(sCalendarType), 'dateFormats', sStyle);
    },
    getTimePattern: function (sStyle, sCalendarType) {
        fnAssert(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        return this._get(getCLDRCalendarName(sCalendarType), 'timeFormats', sStyle);
    },
    getDateTimePattern: function (sStyle, sCalendarType) {
        fnAssert(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        return this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', sStyle);
    },
    getCombinedDateTimePattern: function (sDateStyle, sTimeStyle, sCalendarType) {
        fnAssert(sDateStyle == 'short' || sDateStyle == 'medium' || sDateStyle == 'long' || sDateStyle == 'full', 'sStyle must be short, medium, long or full');
        fnAssert(sTimeStyle == 'short' || sTimeStyle == 'medium' || sTimeStyle == 'long' || sTimeStyle == 'full', 'sStyle must be short, medium, long or full');
        var sDateTimePattern = this.getDateTimePattern(sDateStyle, sCalendarType), sDatePattern = this.getDatePattern(sDateStyle, sCalendarType), sTimePattern = this.getTimePattern(sTimeStyle, sCalendarType);
        return sDateTimePattern.replace('{0}', sTimePattern).replace('{1}', sDatePattern);
    },
    getCustomDateTimePattern: function (sSkeleton, sCalendarType) {
        var oAvailableFormats = this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', 'availableFormats');
        return this._getFormatPattern(sSkeleton, oAvailableFormats, sCalendarType);
    },
    getIntervalPattern: function (sId, sCalendarType) {
        var oIntervalFormats = this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', 'intervalFormats'), aIdParts, sIntervalId, sDifference, oInterval, sPattern;
        if (sId) {
            aIdParts = sId.split('-');
            sIntervalId = aIdParts[0];
            sDifference = aIdParts[1];
            oInterval = oIntervalFormats[sIntervalId];
            if (oInterval) {
                sPattern = oInterval[sDifference];
                if (sPattern) {
                    return sPattern;
                }
            }
        }
        return oIntervalFormats.intervalFormatFallback;
    },
    getCombinedIntervalPattern: function (sPattern, sCalendarType) {
        var oIntervalFormats = this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', 'intervalFormats'), sFallbackPattern = oIntervalFormats.intervalFormatFallback;
        return sFallbackPattern.replace(/\{(0|1)\}/g, sPattern);
    },
    getCustomIntervalPattern: function (sSkeleton, vGreatestDiff, sCalendarType) {
        var oAvailableFormats = this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', 'intervalFormats');
        return this._getFormatPattern(sSkeleton, oAvailableFormats, sCalendarType, vGreatestDiff);
    },
    _getFormatPattern: function (sSkeleton, oAvailableFormats, sCalendarType, vDiff) {
        var vPattern, aPatterns, oIntervalFormats;
        if (!vDiff) {
            vPattern = oAvailableFormats[sSkeleton];
        } else if (typeof vDiff === 'string') {
            if (vDiff == 'j' || vDiff == 'J') {
                vDiff = this.getPreferredHourSymbol();
            }
            oIntervalFormats = oAvailableFormats[sSkeleton];
            vPattern = oIntervalFormats && oIntervalFormats[vDiff];
        }
        if (vPattern) {
            if (typeof vPattern === 'object') {
                aPatterns = Object.keys(vPattern).map(function (sKey) {
                    return vPattern[sKey];
                });
            } else {
                return vPattern;
            }
        }
        if (!aPatterns) {
            aPatterns = this._createFormatPattern(sSkeleton, oAvailableFormats, sCalendarType, vDiff);
        }
        if (aPatterns && aPatterns.length === 1) {
            return aPatterns[0];
        }
        return aPatterns;
    },
    _createFormatPattern: function (sSkeleton, oAvailableFormats, sCalendarType, vDiff) {
        var aTokens = this._parseSkeletonFormat(sSkeleton), aPatterns, oBestMatch = this._findBestMatch(aTokens, sSkeleton, oAvailableFormats), oToken, oAvailableDateTimeFormats, sPattern, sSinglePattern, sDiffSymbol, sDiffGroup, rMixedSkeleton = /^([GyYqQMLwWEecdD]+)([hHkKjJmszZvVOXx]+)$/, bSingleDate, i;
        if (vDiff) {
            if (typeof vDiff === 'string') {
                sDiffGroup = mCLDRSymbols[vDiff] ? mCLDRSymbols[vDiff].group : '';
                if (sDiffGroup) {
                    bSingleDate = mCLDRSymbolGroups[sDiffGroup].index > aTokens[aTokens.length - 1].index;
                }
                sDiffSymbol = vDiff;
            } else {
                bSingleDate = true;
                for (i = aTokens.length - 1; i >= 0; i--) {
                    oToken = aTokens[i];
                    if (vDiff[oToken.group]) {
                        bSingleDate = false;
                        break;
                    }
                }
                for (i = 0; i < aTokens.length; i++) {
                    oToken = aTokens[i];
                    if (vDiff[oToken.group]) {
                        sDiffSymbol = oToken.symbol;
                        break;
                    }
                }
                if ((sDiffSymbol == 'h' || sDiffSymbol == 'K') && vDiff.DayPeriod) {
                    sDiffSymbol = 'a';
                }
            }
            if (bSingleDate) {
                return [this.getCustomDateTimePattern(sSkeleton, sCalendarType)];
            }
            if (oBestMatch && oBestMatch.missingTokens.length === 0) {
                sPattern = oBestMatch.pattern[sDiffSymbol];
                if (sPattern && oBestMatch.distance > 0) {
                    sPattern = this._expandFields(sPattern, oBestMatch.patternTokens, aTokens);
                }
            }
            if (!sPattern) {
                oAvailableDateTimeFormats = this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', 'availableFormats');
                if (rMixedSkeleton.test(sSkeleton) && 'ahHkKjJms'.indexOf(sDiffSymbol) >= 0) {
                    sPattern = this._getMixedFormatPattern(sSkeleton, oAvailableDateTimeFormats, sCalendarType, vDiff);
                } else {
                    sSinglePattern = this._getFormatPattern(sSkeleton, oAvailableDateTimeFormats, sCalendarType);
                    sPattern = this.getCombinedIntervalPattern(sSinglePattern, sCalendarType);
                }
            }
            aPatterns = [sPattern];
        } else if (!oBestMatch) {
            sPattern = sSkeleton;
            aPatterns = [sPattern];
        } else {
            if (typeof oBestMatch.pattern === 'string') {
                aPatterns = [oBestMatch.pattern];
            } else if (typeof oBestMatch.pattern === 'object') {
                aPatterns = [];
                for (var sKey in oBestMatch.pattern) {
                    sPattern = oBestMatch.pattern[sKey];
                    aPatterns.push(sPattern);
                }
            }
            if (oBestMatch.distance > 0) {
                if (oBestMatch.missingTokens.length > 0) {
                    if (rMixedSkeleton.test(sSkeleton)) {
                        aPatterns = [this._getMixedFormatPattern(sSkeleton, oAvailableFormats, sCalendarType)];
                    } else {
                        aPatterns = this._expandFields(aPatterns, oBestMatch.patternTokens, aTokens);
                        aPatterns = this._appendItems(aPatterns, oBestMatch.missingTokens, sCalendarType);
                    }
                } else {
                    aPatterns = this._expandFields(aPatterns, oBestMatch.patternTokens, aTokens);
                }
            }
        }
        if (sSkeleton.indexOf('J') >= 0) {
            aPatterns.forEach(function (sPattern, iIndex) {
                aPatterns[iIndex] = sPattern.replace(/ ?[abB](?=([^']*'[^']*')*[^']*)$/g, '');
            });
        }
        return aPatterns;
    },
    _parseSkeletonFormat: function (sSkeleton) {
        var aTokens = [], oToken = { index: -1 }, sSymbol, oSymbol, oGroup;
        for (var i = 0; i < sSkeleton.length; i++) {
            sSymbol = sSkeleton.charAt(i);
            if (sSymbol == 'j' || sSymbol == 'J') {
                sSymbol = this.getPreferredHourSymbol();
            }
            if (sSymbol == oToken.symbol) {
                oToken.length++;
                continue;
            }
            oSymbol = mCLDRSymbols[sSymbol];
            oGroup = mCLDRSymbolGroups[oSymbol.group];
            if (oSymbol.group == 'Other' || oGroup.diffOnly) {
                throw new Error('Symbol \'' + sSymbol + '\' is not allowed in skeleton format \'' + sSkeleton + '\'');
            }
            if (oGroup.index <= oToken.index) {
                throw new Error('Symbol \'' + sSymbol + '\' at wrong position or duplicate in skeleton format \'' + sSkeleton + '\'');
            }
            oToken = {
                symbol: sSymbol,
                group: oSymbol.group,
                match: oSymbol.match,
                index: oGroup.index,
                field: oGroup.field,
                length: 1
            };
            aTokens.push(oToken);
        }
        return aTokens;
    },
    _findBestMatch: function (aTokens, sSkeleton, oAvailableFormats) {
        var aTestTokens, aMissingTokens, oToken, oTestToken, iTest, iDistance, bMatch, iFirstDiffPos, oTokenSymbol, oTestTokenSymbol, oBestMatch = {
                distance: 10000,
                firstDiffPos: -1
            };
        for (var sTestSkeleton in oAvailableFormats) {
            if (sTestSkeleton === 'intervalFormatFallback' || sTestSkeleton.indexOf('B') > -1) {
                continue;
            }
            aTestTokens = this._parseSkeletonFormat(sTestSkeleton);
            iDistance = 0;
            aMissingTokens = [];
            bMatch = true;
            if (aTokens.length < aTestTokens.length) {
                continue;
            }
            iTest = 0;
            iFirstDiffPos = aTokens.length;
            for (var i = 0; i < aTokens.length; i++) {
                oToken = aTokens[i];
                oTestToken = aTestTokens[iTest];
                if (iFirstDiffPos === aTokens.length) {
                    iFirstDiffPos = i;
                }
                if (oTestToken) {
                    oTokenSymbol = mCLDRSymbols[oToken.symbol];
                    oTestTokenSymbol = mCLDRSymbols[oTestToken.symbol];
                    if (oToken.symbol === oTestToken.symbol) {
                        if (oToken.length === oTestToken.length) {
                            if (iFirstDiffPos === i) {
                                iFirstDiffPos = aTokens.length;
                            }
                        } else {
                            if (oToken.length < oTokenSymbol.numericCeiling ? oTestToken.length < oTestTokenSymbol.numericCeiling : oTestToken.length >= oTestTokenSymbol.numericCeiling) {
                                iDistance += Math.abs(oToken.length - oTestToken.length);
                            } else {
                                iDistance += 5;
                            }
                        }
                        iTest++;
                        continue;
                    } else {
                        if (oToken.match == oTestToken.match) {
                            iDistance += Math.abs(oToken.length - oTestToken.length) + 10;
                            iTest++;
                            continue;
                        }
                    }
                }
                aMissingTokens.push(oToken);
                iDistance += 50 - i;
            }
            if (iTest < aTestTokens.length) {
                bMatch = false;
            }
            if (bMatch && (iDistance < oBestMatch.distance || iDistance === oBestMatch.distance && iFirstDiffPos > oBestMatch.firstDiffPos)) {
                oBestMatch.distance = iDistance;
                oBestMatch.firstDiffPos = iFirstDiffPos;
                oBestMatch.missingTokens = aMissingTokens;
                oBestMatch.pattern = oAvailableFormats[sTestSkeleton];
                oBestMatch.patternTokens = aTestTokens;
            }
        }
        if (oBestMatch.pattern) {
            return oBestMatch;
        }
    },
    _expandFields: function (vPattern, aPatternTokens, aTokens) {
        var bSinglePattern = typeof vPattern === 'string';
        var aPatterns;
        if (bSinglePattern) {
            aPatterns = [vPattern];
        } else {
            aPatterns = vPattern;
        }
        var aResult = aPatterns.map(function (sPattern) {
            var mGroups = {}, mPatternGroups = {}, sResultPatterm = '', bQuoted = false, i = 0, iSkeletonLength, iPatternLength, iOldLength, iNewLength, oSkeletonToken, oBestToken, oSymbol, oSkeletonSymbol, oBestSymbol, sChar;
            aTokens.forEach(function (oToken) {
                mGroups[oToken.group] = oToken;
            });
            aPatternTokens.forEach(function (oToken) {
                mPatternGroups[oToken.group] = oToken;
            });
            while (i < sPattern.length) {
                sChar = sPattern.charAt(i);
                if (bQuoted) {
                    sResultPatterm += sChar;
                    if (sChar == '\'') {
                        bQuoted = false;
                    }
                } else {
                    oSymbol = mCLDRSymbols[sChar];
                    if (oSymbol && mGroups[oSymbol.group] && mPatternGroups[oSymbol.group]) {
                        oSkeletonToken = mGroups[oSymbol.group];
                        oBestToken = mPatternGroups[oSymbol.group];
                        oSkeletonSymbol = mCLDRSymbols[oSkeletonToken.symbol];
                        oBestSymbol = mCLDRSymbols[oBestToken.symbol];
                        iSkeletonLength = oSkeletonToken.length;
                        iPatternLength = oBestToken.length;
                        iOldLength = 1;
                        while (sPattern.charAt(i + 1) == sChar) {
                            i++;
                            iOldLength++;
                        }
                        if (iSkeletonLength === iPatternLength || (iSkeletonLength < oSkeletonSymbol.numericCeiling ? iPatternLength >= oBestSymbol.numericCeiling : iPatternLength < oBestSymbol.numericCeiling)) {
                            iNewLength = iOldLength;
                        } else {
                            iNewLength = Math.max(iOldLength, iSkeletonLength);
                        }
                        for (var j = 0; j < iNewLength; j++) {
                            sResultPatterm += sChar;
                        }
                    } else {
                        sResultPatterm += sChar;
                        if (sChar == '\'') {
                            bQuoted = true;
                        }
                    }
                }
                i++;
            }
            return sResultPatterm;
        });
        return bSinglePattern ? aResult[0] : aResult;
    },
    _appendItems: function (aPatterns, aMissingTokens, sCalendarType) {
        var oAppendItems = this._get(getCLDRCalendarName(sCalendarType), 'dateTimeFormats', 'appendItems');
        aPatterns.forEach(function (sPattern, iIndex) {
            var sDisplayName, sAppendPattern, sAppendField;
            aMissingTokens.forEach(function (oToken) {
                sAppendPattern = oAppendItems[oToken.group];
                sDisplayName = '\'' + this.getDisplayName(oToken.field) + '\'';
                sAppendField = '';
                for (var i = 0; i < oToken.length; i++) {
                    sAppendField += oToken.symbol;
                }
                aPatterns[iIndex] = sAppendPattern.replace(/\{0\}/, sPattern).replace(/\{1\}/, sAppendField).replace(/\{2\}/, sDisplayName);
            }.bind(this));
        }.bind(this));
        return aPatterns;
    },
    _getMixedFormatPattern: function (sSkeleton, oAvailableFormats, sCalendarType, vDiff) {
        var rMixedSkeleton = /^([GyYqQMLwWEecdD]+)([hHkKjJmszZvVOXx]+)$/, rWideMonth = /MMMM|LLLL/, rAbbrevMonth = /MMM|LLL/, rWeekDay = /E|e|c/, oResult, sDateSkeleton, sTimeSkeleton, sStyle, sDatePattern, sTimePattern, sDateTimePattern, sResultPattern;
        oResult = rMixedSkeleton.exec(sSkeleton);
        sDateSkeleton = oResult[1];
        sTimeSkeleton = oResult[2];
        sDatePattern = this._getFormatPattern(sDateSkeleton, oAvailableFormats, sCalendarType);
        if (vDiff) {
            sTimePattern = this.getCustomIntervalPattern(sTimeSkeleton, vDiff, sCalendarType);
        } else {
            sTimePattern = this._getFormatPattern(sTimeSkeleton, oAvailableFormats, sCalendarType);
        }
        if (rWideMonth.test(sDateSkeleton)) {
            sStyle = rWeekDay.test(sDateSkeleton) ? 'full' : 'long';
        } else if (rAbbrevMonth.test(sDateSkeleton)) {
            sStyle = 'medium';
        } else {
            sStyle = 'short';
        }
        sDateTimePattern = this.getDateTimePattern(sStyle, sCalendarType);
        sResultPattern = sDateTimePattern.replace(/\{1\}/, sDatePattern).replace(/\{0\}/, sTimePattern);
        return sResultPattern;
    },
    getNumberSymbol: function (sType) {
        fnAssert(sType == 'decimal' || sType == 'group' || sType == 'plusSign' || sType == 'minusSign' || sType == 'percentSign', 'sType must be decimal, group, plusSign, minusSign or percentSign');
        return this._get('symbols-latn-' + sType);
    },
    getDecimalPattern: function () {
        return this._get('decimalFormat').standard;
    },
    getCurrencyPattern: function (sContext) {
        return this._get('currencyFormat')[sContext] || this._get('currencyFormat').standard;
    },
    getCurrencySpacing: function (sPosition) {
        return this._get('currencyFormat', 'currencySpacing', sPosition === 'after' ? 'afterCurrency' : 'beforeCurrency');
    },
    getPercentPattern: function () {
        return this._get('percentFormat').standard;
    },
    getMinimalDaysInFirstWeek: function () {
        return this._get('weekData-minDays');
    },
    getFirstDayOfWeek: function () {
        return this._get('weekData-firstDay');
    },
    getWeekendStart: function () {
        return this._get('weekData-weekendStart');
    },
    getWeekendEnd: function () {
        return this._get('weekData-weekendEnd');
    },
    getCurrencyDigits: function (sCurrency) {
        var mCustomCurrencies = this._get('currency');
        if (mCustomCurrencies) {
            if (mCustomCurrencies[sCurrency] && mCustomCurrencies[sCurrency].hasOwnProperty('digits')) {
                return mCustomCurrencies[sCurrency].digits;
            } else if (mCustomCurrencies['DEFAULT'] && mCustomCurrencies['DEFAULT'].hasOwnProperty('digits')) {
                return mCustomCurrencies['DEFAULT'].digits;
            }
        }
        var iDigits = this._get('currencyDigits', sCurrency);
        if (iDigits == null) {
            iDigits = this._get('currencyDigits', 'DEFAULT');
            if (iDigits == null) {
                iDigits = 2;
            }
        }
        return iDigits;
    },
    getCurrencySymbol: function (sCurrency) {
        var oCurrencySymbols = this._get('currencySymbols');
        return oCurrencySymbols && oCurrencySymbols[sCurrency] || sCurrency;
    },
    getCurrencyCodeBySymbol: function (sCurrencySymbol) {
        var oCurrencySymbols = this._get('currencySymbols'), sCurrencyCode;
        for (sCurrencyCode in oCurrencySymbols) {
            if (oCurrencySymbols[sCurrencyCode] === sCurrencySymbol) {
                return sCurrencyCode;
            }
        }
        return sCurrencySymbol;
    },
    getUnitDisplayName: function (sUnit) {
        var mUnitFormat = this.getUnitFormat(sUnit);
        return mUnitFormat && mUnitFormat['displayName'] || '';
    },
    getRelativePatterns: function (aScales, sStyle) {
        if (sStyle === undefined) {
            sStyle = 'wide';
        }
        fnAssert(sStyle === 'wide' || sStyle === 'short' || sStyle === 'narrow', 'sStyle is only allowed to be set with \'wide\', \'short\' or \'narrow\'');
        var aPatterns = [], aPluralCategories = this.getPluralCategories(), oScale, oTimeEntry, iValue, iSign;
        if (!aScales) {
            aScales = [
                'year',
                'month',
                'week',
                'day',
                'hour',
                'minute',
                'second'
            ];
        }
        aScales.forEach(function (sScale) {
            oScale = this._get('dateFields', sScale + '-' + sStyle);
            for (var sEntry in oScale) {
                if (sEntry.indexOf('relative-type-') === 0) {
                    iValue = parseInt(sEntry.substr(14));
                    aPatterns.push({
                        scale: sScale,
                        value: iValue,
                        pattern: oScale[sEntry]
                    });
                } else if (sEntry.indexOf('relativeTime-type-') == 0) {
                    oTimeEntry = oScale[sEntry];
                    iSign = sEntry.substr(18) === 'past' ? -1 : 1;
                    aPluralCategories.forEach(function (sKey) {
                        aPatterns.push({
                            scale: sScale,
                            sign: iSign,
                            pattern: oTimeEntry['relativeTimePattern-count-' + sKey]
                        });
                    });
                }
            }
        }.bind(this));
        return aPatterns;
    },
    getRelativePattern: function (sScale, iDiff, bFuture, sStyle) {
        var sPattern, oTypes, sKey, sPluralCategory;
        if (typeof bFuture === 'string') {
            sStyle = bFuture;
            bFuture = undefined;
        }
        if (bFuture === undefined) {
            bFuture = iDiff > 0;
        }
        if (sStyle === undefined) {
            sStyle = 'wide';
        }
        fnAssert(sStyle === 'wide' || sStyle === 'short' || sStyle === 'narrow', 'sStyle is only allowed to be set with \'wide\', \'short\' or \'narrow\'');
        sKey = sScale + '-' + sStyle;
        if (iDiff === 0 || iDiff === -2 || iDiff === 2) {
            sPattern = this._get('dateFields', sKey, 'relative-type-' + iDiff);
        }
        if (!sPattern) {
            oTypes = this._get('dateFields', sKey, 'relativeTime-type-' + (bFuture ? 'future' : 'past'));
            sPluralCategory = this.getPluralCategory(Math.abs(iDiff).toString());
            sPattern = oTypes['relativeTimePattern-count-' + sPluralCategory];
        }
        return sPattern;
    },
    getRelativeSecond: function (iDiff, sStyle) {
        return this.getRelativePattern('second', iDiff, sStyle);
    },
    getRelativeMinute: function (iDiff, sStyle) {
        if (iDiff == 0) {
            return null;
        }
        return this.getRelativePattern('minute', iDiff, sStyle);
    },
    getRelativeHour: function (iDiff, sStyle) {
        if (iDiff == 0) {
            return null;
        }
        return this.getRelativePattern('hour', iDiff, sStyle);
    },
    getRelativeDay: function (iDiff, sStyle) {
        return this.getRelativePattern('day', iDiff, sStyle);
    },
    getRelativeWeek: function (iDiff, sStyle) {
        return this.getRelativePattern('week', iDiff, sStyle);
    },
    getRelativeMonth: function (iDiff, sStyle) {
        return this.getRelativePattern('month', iDiff, sStyle);
    },
    getDisplayName: function (sType, sStyle) {
        fnAssert(sType == 'second' || sType == 'minute' || sType == 'hour' || sType == 'zone' || sType == 'day' || sType == 'weekday' || sType == 'week' || sType == 'month' || sType == 'quarter' || sType == 'year' || sType == 'era', 'sType must be second, minute, hour, zone, day, weekday, week, month, quarter, year, era');
        if (sStyle === undefined) {
            sStyle = 'wide';
        }
        fnAssert(sStyle === 'wide' || sStyle === 'short' || sStyle === 'narrow', 'sStyle is only allowed to be set with \'wide\', \'short\' or \'narrow\'');
        var aSingleFormFields = [
                'era',
                'weekday',
                'zone'
            ], sKey = aSingleFormFields.indexOf(sType) === -1 ? sType + '-' + sStyle : sType;
        return this._get('dateFields', sKey, 'displayName');
    },
    getRelativeYear: function (iDiff, sStyle) {
        return this.getRelativePattern('year', iDiff, sStyle);
    },
    getDecimalFormat: function (sStyle, sNumber, sPlural) {
        var sFormat;
        var oFormats;
        switch (sStyle) {
        case 'long':
            oFormats = this._get('decimalFormat-long');
            break;
        default:
            oFormats = this._get('decimalFormat-short');
            break;
        }
        if (oFormats) {
            var sName = sNumber + '-' + sPlural;
            sFormat = oFormats[sName];
            if (!sFormat) {
                sName = sNumber + '-other';
                sFormat = oFormats[sName];
            }
        }
        return sFormat;
    },
    getCurrencyFormat: function (sStyle, sNumber, sPlural) {
        var sFormat;
        var oFormats;
        switch (sStyle) {
        default:
            oFormats = this._get('currencyFormat-short');
            break;
        }
        if (oFormats) {
            var sName = sNumber + '-' + sPlural;
            sFormat = oFormats[sName];
            if (!sFormat) {
                sName = sNumber + '-other';
                sFormat = oFormats[sName];
            }
        }
        return sFormat;
    },
    getListFormat: function (sType, sStyle) {
        var oFormats = this._get('listPattern-' + (sType || 'standard') + '-' + (sStyle || 'wide'));
        if (oFormats) {
            return oFormats;
        }
        return {};
    },
    getResolvedUnitFormat: function (sUnit) {
        sUnit = this.getUnitFromMapping(sUnit) || sUnit;
        return this.getUnitFormat(sUnit);
    },
    getUnitFormat: function (sUnit) {
        return this._get('units', 'short', sUnit);
    },
    getUnitFormats: function () {
        return this._getMerged('units', 'short');
    },
    getUnitFromMapping: function (sMapping) {
        return this._get('unitMappings', sMapping);
    },
    getEras: function (sWidth, sCalendarType) {
        fnAssert(sWidth == 'wide' || sWidth == 'abbreviated' || sWidth == 'narrow', 'sWidth must be wide, abbreviate or narrow');
        var oEras = this._get(getCLDRCalendarName(sCalendarType), 'era-' + sWidth), aEras = [];
        for (var i in oEras) {
            aEras[parseInt(i)] = oEras[i];
        }
        return aEras;
    },
    getEraDates: function (sCalendarType) {
        var oEraDates = this._get('eras-' + sCalendarType.toLowerCase()), aEraDates = [];
        for (var i in oEraDates) {
            aEraDates[parseInt(i)] = oEraDates[i];
        }
        return aEraDates;
    },
    getCalendarWeek: function (sStyle, iWeekNumber) {
        fnAssert(sStyle == 'wide' || sStyle == 'narrow', 'sStyle must be wide or narrow');
        var oMessageBundle = sap.ui.getCore().getLibraryResourceBundle('sap.ui.core', this.oLocale.toString()), sKey = 'date.week.calendarweek.' + sStyle;
        return oMessageBundle.getText(sKey, iWeekNumber);
    },
    getPreferredCalendarType: function () {
        var sCalendarPreference = this._get('calendarPreference'), aCalendars = sCalendarPreference ? sCalendarPreference.split(' ') : [], sCalendarName, sType, i;
        for (i = 0; i < aCalendars.length; i++) {
            sCalendarName = aCalendars[i].split('-')[0];
            for (sType in CalendarType) {
                if (sCalendarName === sType.toLowerCase()) {
                    return sType;
                }
            }
        }
        return CalendarType.Gregorian;
    },
    getPreferredHourSymbol: function () {
        return this._get('timeData', '_preferred');
    },
    getPluralCategories: function () {
        var oPlurals = this._get('plurals'), aCategories = Object.keys(oPlurals);
        aCategories.push('other');
        return aCategories;
    },
    getPluralCategory: function (sNumber) {
        var oPlurals = this._get('plurals');
        if (typeof sNumber === 'number') {
            sNumber = sNumber.toString();
        }
        if (!this._pluralTest) {
            this._pluralTest = {};
        }
        for (var sCategory in oPlurals) {
            var fnTest = this._pluralTest[sCategory];
            if (!fnTest) {
                fnTest = this._parsePluralRule(oPlurals[sCategory]);
                this._pluralTest[sCategory] = fnTest;
            }
            if (fnTest(sNumber)) {
                return sCategory;
            }
        }
        return 'other';
    },
    _parsePluralRule: function (sRule) {
        var OP_OR = 'or', OP_AND = 'and', OP_MOD = '%', OP_EQ = '=', OP_NEQ = '!=', OPD_N = 'n', OPD_I = 'i', OPD_F = 'f', OPD_T = 't', OPD_V = 'v', OPD_W = 'w', RANGE = '..', SEP = ',';
        var i = 0, aTokens;
        aTokens = sRule.split(' ');
        function accept(sToken) {
            if (aTokens[i] === sToken) {
                i++;
                return true;
            }
            return false;
        }
        function consume() {
            var sToken = aTokens[i];
            i++;
            return sToken;
        }
        function or_condition() {
            var fnAnd, fnOr;
            fnAnd = and_condition();
            if (accept(OP_OR)) {
                fnOr = or_condition();
                return function (o) {
                    return fnAnd(o) || fnOr(o);
                };
            }
            return fnAnd;
        }
        function and_condition() {
            var fnRelation, fnAnd;
            fnRelation = relation();
            if (accept(OP_AND)) {
                fnAnd = and_condition();
                return function (o) {
                    return fnRelation(o) && fnAnd(o);
                };
            }
            return fnRelation;
        }
        function relation() {
            var fnExpr, fnRangeList, bEq;
            fnExpr = expr();
            if (accept(OP_EQ)) {
                bEq = true;
            } else if (accept(OP_NEQ)) {
                bEq = false;
            } else {
                throw new Error('Expected \'=\' or \'!=\'');
            }
            fnRangeList = range_list();
            if (bEq) {
                return function (o) {
                    return fnRangeList(o).indexOf(fnExpr(o)) >= 0;
                };
            } else {
                return function (o) {
                    return fnRangeList(o).indexOf(fnExpr(o)) === -1;
                };
            }
        }
        function expr() {
            var fnOperand;
            fnOperand = operand();
            if (accept(OP_MOD)) {
                var iDivisor = parseInt(consume());
                return function (o) {
                    return fnOperand(o) % iDivisor;
                };
            }
            return fnOperand;
        }
        function operand() {
            if (accept(OPD_N)) {
                return function (o) {
                    return o.n;
                };
            } else if (accept(OPD_I)) {
                return function (o) {
                    return o.i;
                };
            } else if (accept(OPD_F)) {
                return function (o) {
                    return o.f;
                };
            } else if (accept(OPD_T)) {
                return function (o) {
                    return o.t;
                };
            } else if (accept(OPD_V)) {
                return function (o) {
                    return o.v;
                };
            } else if (accept(OPD_W)) {
                return function (o) {
                    return o.w;
                };
            } else {
                throw new Error('Unknown operand: ' + consume());
            }
        }
        function range_list() {
            var aValues = [], sRangeList = consume(), aParts = sRangeList.split(SEP), aRange, iFrom, iTo;
            aParts.forEach(function (sPart) {
                aRange = sPart.split(RANGE);
                if (aRange.length === 1) {
                    aValues.push(parseInt(sPart));
                } else {
                    iFrom = parseInt(aRange[0]);
                    iTo = parseInt(aRange[1]);
                    for (var i = iFrom; i <= iTo; i++) {
                        aValues.push(i);
                    }
                }
            });
            return function (o) {
                return aValues;
            };
        }
        var fnOr = or_condition();
        if (i != aTokens.length) {
            throw new Error('Not completely parsed');
        }
        return function (sValue) {
            var iDotPos = sValue.indexOf('.'), sDecimal, sFraction, sFractionNoZeros, o;
            if (iDotPos === -1) {
                sDecimal = sValue;
                sFraction = '';
                sFractionNoZeros = '';
            } else {
                sDecimal = sValue.substr(0, iDotPos);
                sFraction = sValue.substr(iDotPos + 1);
                sFractionNoZeros = sFraction.replace(/0+$/, '');
            }
            o = {
                n: parseFloat(sValue),
                i: parseInt(sDecimal),
                v: sFraction.length,
                w: sFractionNoZeros.length,
                f: parseInt(sFraction),
                t: parseInt(sFractionNoZeros)
            };
            return fnOr(o);
        };
    }
});
var mCLDRSymbolGroups = {
    'Era': {
        field: 'era',
        index: 0
    },
    'Year': {
        field: 'year',
        index: 1
    },
    'Quarter': {
        field: 'quarter',
        index: 2
    },
    'Month': {
        field: 'month',
        index: 3
    },
    'Week': {
        field: 'week',
        index: 4
    },
    'Day-Of-Week': {
        field: 'weekday',
        index: 5
    },
    'Day': {
        field: 'day',
        index: 6
    },
    'DayPeriod': {
        field: 'hour',
        index: 7,
        diffOnly: true
    },
    'Hour': {
        field: 'hour',
        index: 8
    },
    'Minute': {
        field: 'minute',
        index: 9
    },
    'Second': {
        field: 'second',
        index: 10
    },
    'Timezone': {
        field: 'zone',
        index: 11
    }
};
var mCLDRSymbols = {
    'G': {
        group: 'Era',
        match: 'Era',
        numericCeiling: 1
    },
    'y': {
        group: 'Year',
        match: 'Year',
        numericCeiling: 100
    },
    'Y': {
        group: 'Year',
        match: 'Year',
        numericCeiling: 100
    },
    'Q': {
        group: 'Quarter',
        match: 'Quarter',
        numericCeiling: 3
    },
    'q': {
        group: 'Quarter',
        match: 'Quarter',
        numericCeiling: 3
    },
    'M': {
        group: 'Month',
        match: 'Month',
        numericCeiling: 3
    },
    'L': {
        group: 'Month',
        match: 'Month',
        numericCeiling: 3
    },
    'w': {
        group: 'Week',
        match: 'Week',
        numericCeiling: 100
    },
    'W': {
        group: 'Week',
        match: 'Week',
        numericCeiling: 100
    },
    'd': {
        group: 'Day',
        match: 'Day',
        numericCeiling: 100
    },
    'D': {
        group: 'Day',
        match: 'Day',
        numericCeiling: 100
    },
    'E': {
        group: 'Day-Of-Week',
        match: 'Day-Of-Week',
        numericCeiling: 1
    },
    'e': {
        group: 'Day-Of-Week',
        match: 'Day-Of-Week',
        numericCeiling: 3
    },
    'c': {
        group: 'Day-Of-Week',
        match: 'Day-Of-Week',
        numericCeiling: 2
    },
    'h': {
        group: 'Hour',
        match: 'Hour12',
        numericCeiling: 100
    },
    'H': {
        group: 'Hour',
        match: 'Hour24',
        numericCeiling: 100
    },
    'k': {
        group: 'Hour',
        match: 'Hour24',
        numericCeiling: 100
    },
    'K': {
        group: 'Hour',
        match: 'Hour12',
        numericCeiling: 100
    },
    'm': {
        group: 'Minute',
        match: 'Minute',
        numericCeiling: 100
    },
    's': {
        group: 'Second',
        match: 'Second',
        numericCeiling: 100
    },
    'z': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'Z': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'O': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'v': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'V': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'X': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'x': {
        group: 'Timezone',
        match: 'Timezone',
        numericCeiling: 1
    },
    'S': {
        group: 'Other',
        numericCeiling: 100
    },
    'u': {
        group: 'Other',
        numericCeiling: 100
    },
    'U': {
        group: 'Other',
        numericCeiling: 1
    },
    'r': {
        group: 'Other',
        numericCeiling: 100
    },
    'F': {
        group: 'Other',
        numericCeiling: 100
    },
    'g': {
        group: 'Other',
        numericCeiling: 100
    },
    'a': {
        group: 'DayPeriod',
        numericCeiling: 1
    },
    'b': {
        group: 'Other',
        numericCeiling: 1
    },
    'B': {
        group: 'Other',
        numericCeiling: 1
    },
    'A': {
        group: 'Other',
        numericCeiling: 100
    }
};
var M_DEFAULT_DATA = {
    'orientation': 'left-to-right',
    'languages': {},
    'scripts': {},
    'territories': {},
    'ca-gregorian': {
        'dateFormats': {
            'full': 'EEEE, MMMM d, y',
            'long': 'MMMM d, y',
            'medium': 'MMM d, y',
            'short': 'M/d/yy'
        },
        'timeFormats': {
            'full': 'h:mm:ss a zzzz',
            'long': 'h:mm:ss a z',
            'medium': 'h:mm:ss a',
            'short': 'h:mm a'
        },
        'dateTimeFormats': {
            'full': '{1} \'at\' {0}',
            'long': '{1} \'at\' {0}',
            'medium': '{1}, {0}',
            'short': '{1}, {0}',
            'availableFormats': {
                'd': 'd',
                'E': 'ccc',
                'Ed': 'd E',
                'Ehm': 'E h:mm a',
                'EHm': 'E HH:mm',
                'Ehms': 'E h:mm:ss a',
                'EHms': 'E HH:mm:ss',
                'Gy': 'y G',
                'GyMMM': 'MMM y G',
                'GyMMMd': 'MMM d, y G',
                'GyMMMEd': 'E, MMM d, y G',
                'h': 'h a',
                'H': 'HH',
                'hm': 'h:mm a',
                'Hm': 'HH:mm',
                'hms': 'h:mm:ss a',
                'Hms': 'HH:mm:ss',
                'hmsv': 'h:mm:ss a v',
                'Hmsv': 'HH:mm:ss v',
                'hmv': 'h:mm a v',
                'Hmv': 'HH:mm v',
                'M': 'L',
                'Md': 'M/d',
                'MEd': 'E, M/d',
                'MMM': 'LLL',
                'MMMd': 'MMM d',
                'MMMEd': 'E, MMM d',
                'MMMMd': 'MMMM d',
                'ms': 'mm:ss',
                'y': 'y',
                'yM': 'M/y',
                'yMd': 'M/d/y',
                'yMEd': 'E, M/d/y',
                'yMMM': 'MMM y',
                'yMMMd': 'MMM d, y',
                'yMMMEd': 'E, MMM d, y',
                'yMMMM': 'MMMM y',
                'yQQQ': 'QQQ y',
                'yQQQQ': 'QQQQ y'
            },
            'appendItems': {
                'Day': '{0} ({2}: {1})',
                'Day-Of-Week': '{0} {1}',
                'Era': '{0} {1}',
                'Hour': '{0} ({2}: {1})',
                'Minute': '{0} ({2}: {1})',
                'Month': '{0} ({2}: {1})',
                'Quarter': '{0} ({2}: {1})',
                'Second': '{0} ({2}: {1})',
                'Timezone': '{0} {1}',
                'Week': '{0} ({2}: {1})',
                'Year': '{0} {1}'
            },
            'intervalFormats': {
                'intervalFormatFallback': '{0} \u2013 {1}',
                'd': { 'd': 'd \u2013 d' },
                'h': {
                    'a': 'h a \u2013 h a',
                    'h': 'h \u2013 h a'
                },
                'H': { 'H': 'HH \u2013 HH' },
                'hm': {
                    'a': 'h:mm a \u2013 h:mm a',
                    'h': 'h:mm \u2013 h:mm a',
                    'm': 'h:mm \u2013 h:mm a'
                },
                'Hm': {
                    'H': 'HH:mm \u2013 HH:mm',
                    'm': 'HH:mm \u2013 HH:mm'
                },
                'hmv': {
                    'a': 'h:mm a \u2013 h:mm a v',
                    'h': 'h:mm \u2013 h:mm a v',
                    'm': 'h:mm \u2013 h:mm a v'
                },
                'Hmv': {
                    'H': 'HH:mm \u2013 HH:mm v',
                    'm': 'HH:mm \u2013 HH:mm v'
                },
                'hv': {
                    'a': 'h a \u2013 h a v',
                    'h': 'h \u2013 h a v'
                },
                'Hv': { 'H': 'HH \u2013 HH v' },
                'M': { 'M': 'M \u2013 M' },
                'Md': {
                    'd': 'M/d \u2013 M/d',
                    'M': 'M/d \u2013 M/d'
                },
                'MEd': {
                    'd': 'E, M/d \u2013 E, M/d',
                    'M': 'E, M/d \u2013 E, M/d'
                },
                'MMM': { 'M': 'MMM \u2013 MMM' },
                'MMMd': {
                    'd': 'MMM d \u2013 d',
                    'M': 'MMM d \u2013 MMM d'
                },
                'MMMEd': {
                    'd': 'E, MMM d \u2013 E, MMM d',
                    'M': 'E, MMM d \u2013 E, MMM d'
                },
                'y': { 'y': 'y \u2013 y' },
                'yM': {
                    'M': 'M/y \u2013 M/y',
                    'y': 'M/y \u2013 M/y'
                },
                'yMd': {
                    'd': 'M/d/y \u2013 M/d/y',
                    'M': 'M/d/y \u2013 M/d/y',
                    'y': 'M/d/y \u2013 M/d/y'
                },
                'yMEd': {
                    'd': 'E, M/d/y \u2013 E, M/d/y',
                    'M': 'E, M/d/y \u2013 E, M/d/y',
                    'y': 'E, M/d/y \u2013 E, M/d/y'
                },
                'yMMM': {
                    'M': 'MMM \u2013 MMM y',
                    'y': 'MMM y \u2013 MMM y'
                },
                'yMMMd': {
                    'd': 'MMM d \u2013 d, y',
                    'M': 'MMM d \u2013 MMM d, y',
                    'y': 'MMM d, y \u2013 MMM d, y'
                },
                'yMMMEd': {
                    'd': 'E, MMM d \u2013 E, MMM d, y',
                    'M': 'E, MMM d \u2013 E, MMM d, y',
                    'y': 'E, MMM d, y \u2013 E, MMM d, y'
                },
                'yMMMM': {
                    'M': 'MMMM \u2013 MMMM y',
                    'y': 'MMMM y \u2013 MMMM y'
                }
            }
        },
        'months': {
            'format': {
                'abbreviated': [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ],
                'narrow': [
                    'J',
                    'F',
                    'M',
                    'A',
                    'M',
                    'J',
                    'J',
                    'A',
                    'S',
                    'O',
                    'N',
                    'D'
                ],
                'wide': [
                    'January',
                    'February',
                    'March',
                    'April',
                    'May',
                    'June',
                    'July',
                    'August',
                    'September',
                    'October',
                    'November',
                    'December'
                ]
            },
            'stand-alone': {
                'abbreviated': [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ],
                'narrow': [
                    'J',
                    'F',
                    'M',
                    'A',
                    'M',
                    'J',
                    'J',
                    'A',
                    'S',
                    'O',
                    'N',
                    'D'
                ],
                'wide': [
                    'January',
                    'February',
                    'March',
                    'April',
                    'May',
                    'June',
                    'July',
                    'August',
                    'September',
                    'October',
                    'November',
                    'December'
                ]
            }
        },
        'days': {
            'format': {
                'abbreviated': [
                    'Sun',
                    'Mon',
                    'Tue',
                    'Wed',
                    'Thu',
                    'Fri',
                    'Sat'
                ],
                'narrow': [
                    'S',
                    'M',
                    'T',
                    'W',
                    'T',
                    'F',
                    'S'
                ],
                'short': [
                    'Su',
                    'Mo',
                    'Tu',
                    'We',
                    'Th',
                    'Fr',
                    'Sa'
                ],
                'wide': [
                    'Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday'
                ]
            },
            'stand-alone': {
                'abbreviated': [
                    'Sun',
                    'Mon',
                    'Tue',
                    'Wed',
                    'Thu',
                    'Fri',
                    'Sat'
                ],
                'narrow': [
                    'S',
                    'M',
                    'T',
                    'W',
                    'T',
                    'F',
                    'S'
                ],
                'short': [
                    'Su',
                    'Mo',
                    'Tu',
                    'We',
                    'Th',
                    'Fr',
                    'Sa'
                ],
                'wide': [
                    'Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday'
                ]
            }
        },
        'quarters': {
            'format': {
                'abbreviated': [
                    'Q1',
                    'Q2',
                    'Q3',
                    'Q4'
                ],
                'narrow': [
                    '1',
                    '2',
                    '3',
                    '4'
                ],
                'wide': [
                    '1st quarter',
                    '2nd quarter',
                    '3rd quarter',
                    '4th quarter'
                ]
            },
            'stand-alone': {
                'abbreviated': [
                    'Q1',
                    'Q2',
                    'Q3',
                    'Q4'
                ],
                'narrow': [
                    '1',
                    '2',
                    '3',
                    '4'
                ],
                'wide': [
                    '1st quarter',
                    '2nd quarter',
                    '3rd quarter',
                    '4th quarter'
                ]
            }
        },
        'dayPeriods': {
            'format': {
                'abbreviated': [
                    'AM',
                    'PM'
                ],
                'narrow': [
                    'a',
                    'p'
                ],
                'wide': [
                    'AM',
                    'PM'
                ]
            },
            'stand-alone': {
                'abbreviated': [
                    'AM',
                    'PM'
                ],
                'narrow': [
                    'AM',
                    'PM'
                ],
                'wide': [
                    'AM',
                    'PM'
                ]
            }
        },
        'era-wide': {
            '0': 'Before Christ',
            '1': 'Anno Domini'
        },
        'era-abbreviated': {
            '0': 'BC',
            '1': 'AD'
        },
        'era-narrow': {
            '0': 'B',
            '1': 'A'
        }
    },
    'eras-gregorian': {
        '0': { '_end': '0-12-31' },
        '1': { '_start': '1-01-01' }
    },
    'dateFields': {
        'era': { 'displayName': 'era' },
        'year-wide': {
            'displayName': 'year',
            'relative-type--1': 'last year',
            'relative-type-0': 'this year',
            'relative-type-1': 'next year',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} year',
                'relativeTimePattern-count-other': 'in {0} years'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} year ago',
                'relativeTimePattern-count-other': '{0} years ago'
            }
        },
        'year-short': {
            'displayName': 'yr.',
            'relative-type--1': 'last yr.',
            'relative-type-0': 'this yr.',
            'relative-type-1': 'next yr.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} yr.',
                'relativeTimePattern-count-other': 'in {0} yr.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} yr. ago',
                'relativeTimePattern-count-other': '{0} yr. ago'
            }
        },
        'year-narrow': {
            'displayName': 'yr.',
            'relative-type--1': 'last yr.',
            'relative-type-0': 'this yr.',
            'relative-type-1': 'next yr.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} yr.',
                'relativeTimePattern-count-other': 'in {0} yr.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} yr. ago',
                'relativeTimePattern-count-other': '{0} yr. ago'
            }
        },
        'quarter-wide': {
            'displayName': 'quarter',
            'relative-type--1': 'last quarter',
            'relative-type-0': 'this quarter',
            'relative-type-1': 'next quarter',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} quarter',
                'relativeTimePattern-count-other': 'in {0} quarters'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} quarter ago',
                'relativeTimePattern-count-other': '{0} quarters ago'
            }
        },
        'quarter-short': {
            'displayName': 'qtr.',
            'relative-type--1': 'last qtr.',
            'relative-type-0': 'this qtr.',
            'relative-type-1': 'next qtr.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} qtr.',
                'relativeTimePattern-count-other': 'in {0} qtrs.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} qtr. ago',
                'relativeTimePattern-count-other': '{0} qtrs. ago'
            }
        },
        'quarter-narrow': {
            'displayName': 'qtr.',
            'relative-type--1': 'last qtr.',
            'relative-type-0': 'this qtr.',
            'relative-type-1': 'next qtr.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} qtr.',
                'relativeTimePattern-count-other': 'in {0} qtrs.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} qtr. ago',
                'relativeTimePattern-count-other': '{0} qtrs. ago'
            }
        },
        'month-wide': {
            'displayName': 'month',
            'relative-type--1': 'last month',
            'relative-type-0': 'this month',
            'relative-type-1': 'next month',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} month',
                'relativeTimePattern-count-other': 'in {0} months'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} month ago',
                'relativeTimePattern-count-other': '{0} months ago'
            }
        },
        'month-short': {
            'displayName': 'mo.',
            'relative-type--1': 'last mo.',
            'relative-type-0': 'this mo.',
            'relative-type-1': 'next mo.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} mo.',
                'relativeTimePattern-count-other': 'in {0} mo.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} mo. ago',
                'relativeTimePattern-count-other': '{0} mo. ago'
            }
        },
        'month-narrow': {
            'displayName': 'mo.',
            'relative-type--1': 'last mo.',
            'relative-type-0': 'this mo.',
            'relative-type-1': 'next mo.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} mo.',
                'relativeTimePattern-count-other': 'in {0} mo.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} mo. ago',
                'relativeTimePattern-count-other': '{0} mo. ago'
            }
        },
        'week-wide': {
            'displayName': 'week',
            'relative-type--1': 'last week',
            'relative-type-0': 'this week',
            'relative-type-1': 'next week',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} week',
                'relativeTimePattern-count-other': 'in {0} weeks'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} week ago',
                'relativeTimePattern-count-other': '{0} weeks ago'
            },
            'relativePeriod': 'the week of {0}'
        },
        'week-short': {
            'displayName': 'wk.',
            'relative-type--1': 'last wk.',
            'relative-type-0': 'this wk.',
            'relative-type-1': 'next wk.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} wk.',
                'relativeTimePattern-count-other': 'in {0} wk.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} wk. ago',
                'relativeTimePattern-count-other': '{0} wk. ago'
            },
            'relativePeriod': 'the week of {0}'
        },
        'week-narrow': {
            'displayName': 'wk.',
            'relative-type--1': 'last wk.',
            'relative-type-0': 'this wk.',
            'relative-type-1': 'next wk.',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} wk.',
                'relativeTimePattern-count-other': 'in {0} wk.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} wk. ago',
                'relativeTimePattern-count-other': '{0} wk. ago'
            },
            'relativePeriod': 'the week of {0}'
        },
        'day-wide': {
            'displayName': 'day',
            'relative-type--1': 'yesterday',
            'relative-type-0': 'today',
            'relative-type-1': 'tomorrow',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} day',
                'relativeTimePattern-count-other': 'in {0} days'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} day ago',
                'relativeTimePattern-count-other': '{0} days ago'
            }
        },
        'day-short': {
            'displayName': 'day',
            'relative-type--1': 'yesterday',
            'relative-type-0': 'today',
            'relative-type-1': 'tomorrow',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} day',
                'relativeTimePattern-count-other': 'in {0} days'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} day ago',
                'relativeTimePattern-count-other': '{0} days ago'
            }
        },
        'day-narrow': {
            'displayName': 'day',
            'relative-type--1': 'yesterday',
            'relative-type-0': 'today',
            'relative-type-1': 'tomorrow',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} day',
                'relativeTimePattern-count-other': 'in {0} days'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} day ago',
                'relativeTimePattern-count-other': '{0} days ago'
            }
        },
        'weekday': { 'displayName': 'day of the week' },
        'hour-wide': {
            'displayName': 'hour',
            'relative-type-0': 'this hour',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} hour',
                'relativeTimePattern-count-other': 'in {0} hours'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} hour ago',
                'relativeTimePattern-count-other': '{0} hours ago'
            }
        },
        'hour-short': {
            'displayName': 'hr.',
            'relative-type-0': 'this hour',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} hr.',
                'relativeTimePattern-count-other': 'in {0} hr.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} hr. ago',
                'relativeTimePattern-count-other': '{0} hr. ago'
            }
        },
        'hour-narrow': {
            'displayName': 'hr.',
            'relative-type-0': 'this hour',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} hr.',
                'relativeTimePattern-count-other': 'in {0} hr.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} hr. ago',
                'relativeTimePattern-count-other': '{0} hr. ago'
            }
        },
        'minute-wide': {
            'displayName': 'minute',
            'relative-type-0': 'this minute',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} minute',
                'relativeTimePattern-count-other': 'in {0} minutes'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} minute ago',
                'relativeTimePattern-count-other': '{0} minutes ago'
            }
        },
        'minute-short': {
            'displayName': 'min.',
            'relative-type-0': 'this minute',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} min.',
                'relativeTimePattern-count-other': 'in {0} min.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} min. ago',
                'relativeTimePattern-count-other': '{0} min. ago'
            }
        },
        'minute-narrow': {
            'displayName': 'min.',
            'relative-type-0': 'this minute',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} min.',
                'relativeTimePattern-count-other': 'in {0} min.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} min. ago',
                'relativeTimePattern-count-other': '{0} min. ago'
            }
        },
        'second-wide': {
            'displayName': 'second',
            'relative-type-0': 'now',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} second',
                'relativeTimePattern-count-other': 'in {0} seconds'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} second ago',
                'relativeTimePattern-count-other': '{0} seconds ago'
            }
        },
        'second-short': {
            'displayName': 'sec.',
            'relative-type-0': 'now',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} sec.',
                'relativeTimePattern-count-other': 'in {0} sec.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} sec. ago',
                'relativeTimePattern-count-other': '{0} sec. ago'
            }
        },
        'second-narrow': {
            'displayName': 'sec.',
            'relative-type-0': 'now',
            'relativeTime-type-future': {
                'relativeTimePattern-count-one': 'in {0} sec.',
                'relativeTimePattern-count-other': 'in {0} sec.'
            },
            'relativeTime-type-past': {
                'relativeTimePattern-count-one': '{0} sec. ago',
                'relativeTimePattern-count-other': '{0} sec. ago'
            }
        },
        'zone': { 'displayName': 'time zone' }
    },
    'decimalFormat': { 'standard': '#,##0.###' },
    'currencyFormat': {
        'standard': '\xA4#,##0.00',
        'currencySpacing': {
            'beforeCurrency': {
                'currencyMatch': '[:^S:]',
                'surroundingMatch': '[:digit:]',
                'insertBetween': '\xA0'
            },
            'afterCurrency': {
                'currencyMatch': '[:^S:]',
                'surroundingMatch': '[:digit:]',
                'insertBetween': '\xA0'
            }
        }
    },
    'percentFormat': { 'standard': '#,##0%' },
    'symbols-latn-decimal': '.',
    'symbols-latn-group': ',',
    'symbols-latn-plusSign': '+',
    'symbols-latn-minusSign': '-',
    'symbols-latn-percentSign': '%',
    'weekData-minDays': 4,
    'weekData-firstDay': 1,
    'weekData-weekendStart': 6,
    'weekData-weekendEnd': 0,
    'timeData': {
        _allowed: 'H h',
        _preferred: 'H'
    },
    'plurals': {},
    'units': {
        'short': {
            'per': { 'compoundUnitPattern': '{0}/{1}' },
            'acceleration-g-force': {
                'displayName': 'g-force',
                'unitPattern-count-one': '{0} G',
                'unitPattern-count-other': '{0} G'
            },
            'acceleration-meter-per-second-squared': {
                'displayName': 'meters/sec\xB2',
                'unitPattern-count-one': '{0} m/s\xB2',
                'unitPattern-count-other': '{0} m/s\xB2'
            },
            'angle-revolution': {
                'displayName': 'rev',
                'unitPattern-count-one': '{0} rev',
                'unitPattern-count-other': '{0} rev'
            },
            'angle-radian': {
                'displayName': 'radians',
                'unitPattern-count-one': '{0} rad',
                'unitPattern-count-other': '{0} rad'
            },
            'angle-degree': {
                'displayName': 'degrees',
                'unitPattern-count-one': '{0} deg',
                'unitPattern-count-other': '{0} deg'
            },
            'angle-arc-minute': {
                'displayName': 'arcmins',
                'unitPattern-count-one': '{0} arcmin',
                'unitPattern-count-other': '{0} arcmins'
            },
            'angle-arc-second': {
                'displayName': 'arcsecs',
                'unitPattern-count-one': '{0} arcsec',
                'unitPattern-count-other': '{0} arcsecs'
            },
            'area-square-kilometer': {
                'displayName': 'km\xB2',
                'unitPattern-count-one': '{0} km\xB2',
                'unitPattern-count-other': '{0} km\xB2',
                'perUnitPattern': '{0}/km\xB2'
            },
            'area-hectare': {
                'displayName': 'hectares',
                'unitPattern-count-one': '{0} ha',
                'unitPattern-count-other': '{0} ha'
            },
            'area-square-meter': {
                'displayName': 'meters\xB2',
                'unitPattern-count-one': '{0} m\xB2',
                'unitPattern-count-other': '{0} m\xB2',
                'perUnitPattern': '{0}/m\xB2'
            },
            'area-square-centimeter': {
                'displayName': 'cm\xB2',
                'unitPattern-count-one': '{0} cm\xB2',
                'unitPattern-count-other': '{0} cm\xB2',
                'perUnitPattern': '{0}/cm\xB2'
            },
            'area-square-mile': {
                'displayName': 'sq miles',
                'unitPattern-count-one': '{0} sq mi',
                'unitPattern-count-other': '{0} sq mi',
                'perUnitPattern': '{0}/mi\xB2'
            },
            'area-acre': {
                'displayName': 'acres',
                'unitPattern-count-one': '{0} ac',
                'unitPattern-count-other': '{0} ac'
            },
            'area-square-yard': {
                'displayName': 'yards\xB2',
                'unitPattern-count-one': '{0} yd\xB2',
                'unitPattern-count-other': '{0} yd\xB2'
            },
            'area-square-foot': {
                'displayName': 'sq feet',
                'unitPattern-count-one': '{0} sq ft',
                'unitPattern-count-other': '{0} sq ft'
            },
            'area-square-inch': {
                'displayName': 'inches\xB2',
                'unitPattern-count-one': '{0} in\xB2',
                'unitPattern-count-other': '{0} in\xB2',
                'perUnitPattern': '{0}/in\xB2'
            },
            'concentr-karat': {
                'displayName': 'karats',
                'unitPattern-count-one': '{0} kt',
                'unitPattern-count-other': '{0} kt'
            },
            'concentr-milligram-per-deciliter': {
                'displayName': 'mg/dL',
                'unitPattern-count-one': '{0} mg/dL',
                'unitPattern-count-other': '{0} mg/dL'
            },
            'concentr-millimole-per-liter': {
                'displayName': 'millimol/liter',
                'unitPattern-count-one': '{0} mmol/L',
                'unitPattern-count-other': '{0} mmol/L'
            },
            'concentr-part-per-million': {
                'displayName': 'parts/million',
                'unitPattern-count-one': '{0} ppm',
                'unitPattern-count-other': '{0} ppm'
            },
            'consumption-liter-per-kilometer': {
                'displayName': 'liters/km',
                'unitPattern-count-one': '{0} L/km',
                'unitPattern-count-other': '{0} L/km'
            },
            'consumption-liter-per-100kilometers': {
                'displayName': 'L/100 km',
                'unitPattern-count-one': '{0} L/100 km',
                'unitPattern-count-other': '{0} L/100 km'
            },
            'consumption-mile-per-gallon': {
                'displayName': 'miles/gal',
                'unitPattern-count-one': '{0} mpg',
                'unitPattern-count-other': '{0} mpg'
            },
            'consumption-mile-per-gallon-imperial': {
                'displayName': 'miles/gal Imp.',
                'unitPattern-count-one': '{0} mpg Imp.',
                'unitPattern-count-other': '{0} mpg Imp.'
            },
            'digital-terabyte': {
                'displayName': 'TByte',
                'unitPattern-count-one': '{0} TB',
                'unitPattern-count-other': '{0} TB'
            },
            'digital-terabit': {
                'displayName': 'Tbit',
                'unitPattern-count-one': '{0} Tb',
                'unitPattern-count-other': '{0} Tb'
            },
            'digital-gigabyte': {
                'displayName': 'GByte',
                'unitPattern-count-one': '{0} GB',
                'unitPattern-count-other': '{0} GB'
            },
            'digital-gigabit': {
                'displayName': 'Gbit',
                'unitPattern-count-one': '{0} Gb',
                'unitPattern-count-other': '{0} Gb'
            },
            'digital-megabyte': {
                'displayName': 'MByte',
                'unitPattern-count-one': '{0} MB',
                'unitPattern-count-other': '{0} MB'
            },
            'digital-megabit': {
                'displayName': 'Mbit',
                'unitPattern-count-one': '{0} Mb',
                'unitPattern-count-other': '{0} Mb'
            },
            'digital-kilobyte': {
                'displayName': 'kByte',
                'unitPattern-count-one': '{0} kB',
                'unitPattern-count-other': '{0} kB'
            },
            'digital-kilobit': {
                'displayName': 'kbit',
                'unitPattern-count-one': '{0} kb',
                'unitPattern-count-other': '{0} kb'
            },
            'digital-byte': {
                'displayName': 'byte',
                'unitPattern-count-one': '{0} byte',
                'unitPattern-count-other': '{0} byte'
            },
            'digital-bit': {
                'displayName': 'bit',
                'unitPattern-count-one': '{0} bit',
                'unitPattern-count-other': '{0} bit'
            },
            'duration-century': {
                'displayName': 'c',
                'unitPattern-count-one': '{0} c',
                'unitPattern-count-other': '{0} c'
            },
            'duration-year': {
                'displayName': 'years',
                'unitPattern-count-one': '{0} yr',
                'unitPattern-count-other': '{0} yrs',
                'perUnitPattern': '{0}/y'
            },
            'duration-month': {
                'displayName': 'months',
                'unitPattern-count-one': '{0} mth',
                'unitPattern-count-other': '{0} mths',
                'perUnitPattern': '{0}/m'
            },
            'duration-week': {
                'displayName': 'weeks',
                'unitPattern-count-one': '{0} wk',
                'unitPattern-count-other': '{0} wks',
                'perUnitPattern': '{0}/w'
            },
            'duration-day': {
                'displayName': 'days',
                'unitPattern-count-one': '{0} day',
                'unitPattern-count-other': '{0} days',
                'perUnitPattern': '{0}/d'
            },
            'duration-hour': {
                'displayName': 'hours',
                'unitPattern-count-one': '{0} hr',
                'unitPattern-count-other': '{0} hr',
                'perUnitPattern': '{0}/h'
            },
            'duration-minute': {
                'displayName': 'mins',
                'unitPattern-count-one': '{0} min',
                'unitPattern-count-other': '{0} min',
                'perUnitPattern': '{0}/min'
            },
            'duration-second': {
                'displayName': 'secs',
                'unitPattern-count-one': '{0} sec',
                'unitPattern-count-other': '{0} sec',
                'perUnitPattern': '{0}/s'
            },
            'duration-millisecond': {
                'displayName': 'millisecs',
                'unitPattern-count-one': '{0} ms',
                'unitPattern-count-other': '{0} ms'
            },
            'duration-microsecond': {
                'displayName': 'μsecs',
                'unitPattern-count-one': '{0} μs',
                'unitPattern-count-other': '{0} μs'
            },
            'duration-nanosecond': {
                'displayName': 'nanosecs',
                'unitPattern-count-one': '{0} ns',
                'unitPattern-count-other': '{0} ns'
            },
            'electric-ampere': {
                'displayName': 'amps',
                'unitPattern-count-one': '{0} A',
                'unitPattern-count-other': '{0} A'
            },
            'electric-milliampere': {
                'displayName': 'milliamps',
                'unitPattern-count-one': '{0} mA',
                'unitPattern-count-other': '{0} mA'
            },
            'electric-ohm': {
                'displayName': 'ohms',
                'unitPattern-count-one': '{0} Ω',
                'unitPattern-count-other': '{0} Ω'
            },
            'electric-volt': {
                'displayName': 'volts',
                'unitPattern-count-one': '{0} V',
                'unitPattern-count-other': '{0} V'
            },
            'energy-kilocalorie': {
                'displayName': 'kcal',
                'unitPattern-count-one': '{0} kcal',
                'unitPattern-count-other': '{0} kcal'
            },
            'energy-calorie': {
                'displayName': 'cal',
                'unitPattern-count-one': '{0} cal',
                'unitPattern-count-other': '{0} cal'
            },
            'energy-foodcalorie': {
                'displayName': 'Cal',
                'unitPattern-count-one': '{0} Cal',
                'unitPattern-count-other': '{0} Cal'
            },
            'energy-kilojoule': {
                'displayName': 'kilojoule',
                'unitPattern-count-one': '{0} kJ',
                'unitPattern-count-other': '{0} kJ'
            },
            'energy-joule': {
                'displayName': 'joules',
                'unitPattern-count-one': '{0} J',
                'unitPattern-count-other': '{0} J'
            },
            'energy-kilowatt-hour': {
                'displayName': 'kW-hour',
                'unitPattern-count-one': '{0} kWh',
                'unitPattern-count-other': '{0} kWh'
            },
            'frequency-gigahertz': {
                'displayName': 'GHz',
                'unitPattern-count-one': '{0} GHz',
                'unitPattern-count-other': '{0} GHz'
            },
            'frequency-megahertz': {
                'displayName': 'MHz',
                'unitPattern-count-one': '{0} MHz',
                'unitPattern-count-other': '{0} MHz'
            },
            'frequency-kilohertz': {
                'displayName': 'kHz',
                'unitPattern-count-one': '{0} kHz',
                'unitPattern-count-other': '{0} kHz'
            },
            'frequency-hertz': {
                'displayName': 'Hz',
                'unitPattern-count-one': '{0} Hz',
                'unitPattern-count-other': '{0} Hz'
            },
            'length-kilometer': {
                'displayName': 'km',
                'unitPattern-count-one': '{0} km',
                'unitPattern-count-other': '{0} km',
                'perUnitPattern': '{0}/km'
            },
            'length-meter': {
                'displayName': 'm',
                'unitPattern-count-one': '{0} m',
                'unitPattern-count-other': '{0} m',
                'perUnitPattern': '{0}/m'
            },
            'length-decimeter': {
                'displayName': 'dm',
                'unitPattern-count-one': '{0} dm',
                'unitPattern-count-other': '{0} dm'
            },
            'length-centimeter': {
                'displayName': 'cm',
                'unitPattern-count-one': '{0} cm',
                'unitPattern-count-other': '{0} cm',
                'perUnitPattern': '{0}/cm'
            },
            'length-millimeter': {
                'displayName': 'mm',
                'unitPattern-count-one': '{0} mm',
                'unitPattern-count-other': '{0} mm'
            },
            'length-micrometer': {
                'displayName': 'µmeters',
                'unitPattern-count-one': '{0} µm',
                'unitPattern-count-other': '{0} µm'
            },
            'length-nanometer': {
                'displayName': 'nm',
                'unitPattern-count-one': '{0} nm',
                'unitPattern-count-other': '{0} nm'
            },
            'length-picometer': {
                'displayName': 'pm',
                'unitPattern-count-one': '{0} pm',
                'unitPattern-count-other': '{0} pm'
            },
            'length-mile': {
                'displayName': 'miles',
                'unitPattern-count-one': '{0} mi',
                'unitPattern-count-other': '{0} mi'
            },
            'length-yard': {
                'displayName': 'yards',
                'unitPattern-count-one': '{0} yd',
                'unitPattern-count-other': '{0} yd'
            },
            'length-foot': {
                'displayName': 'feet',
                'unitPattern-count-one': '{0} ft',
                'unitPattern-count-other': '{0} ft',
                'perUnitPattern': '{0}/ft'
            },
            'length-inch': {
                'displayName': 'inches',
                'unitPattern-count-one': '{0} in',
                'unitPattern-count-other': '{0} in',
                'perUnitPattern': '{0}/in'
            },
            'length-parsec': {
                'displayName': 'parsecs',
                'unitPattern-count-one': '{0} pc',
                'unitPattern-count-other': '{0} pc'
            },
            'length-light-year': {
                'displayName': 'light yrs',
                'unitPattern-count-one': '{0} ly',
                'unitPattern-count-other': '{0} ly'
            },
            'length-astronomical-unit': {
                'displayName': 'au',
                'unitPattern-count-one': '{0} au',
                'unitPattern-count-other': '{0} au'
            },
            'length-furlong': {
                'displayName': 'furlongs',
                'unitPattern-count-one': '{0} fur',
                'unitPattern-count-other': '{0} fur'
            },
            'length-fathom': {
                'displayName': 'fathoms',
                'unitPattern-count-one': '{0} ftm',
                'unitPattern-count-other': '{0} ftm'
            },
            'length-nautical-mile': {
                'displayName': 'nmi',
                'unitPattern-count-one': '{0} nmi',
                'unitPattern-count-other': '{0} nmi'
            },
            'length-mile-scandinavian': {
                'displayName': 'smi',
                'unitPattern-count-one': '{0} smi',
                'unitPattern-count-other': '{0} smi'
            },
            'length-point': {
                'displayName': 'points',
                'unitPattern-count-one': '{0} pt',
                'unitPattern-count-other': '{0} pt'
            },
            'light-lux': {
                'displayName': 'lux',
                'unitPattern-count-one': '{0} lx',
                'unitPattern-count-other': '{0} lx'
            },
            'mass-metric-ton': {
                'displayName': 't',
                'unitPattern-count-one': '{0} t',
                'unitPattern-count-other': '{0} t'
            },
            'mass-kilogram': {
                'displayName': 'kg',
                'unitPattern-count-one': '{0} kg',
                'unitPattern-count-other': '{0} kg',
                'perUnitPattern': '{0}/kg'
            },
            'mass-gram': {
                'displayName': 'grams',
                'unitPattern-count-one': '{0} g',
                'unitPattern-count-other': '{0} g',
                'perUnitPattern': '{0}/g'
            },
            'mass-milligram': {
                'displayName': 'mg',
                'unitPattern-count-one': '{0} mg',
                'unitPattern-count-other': '{0} mg'
            },
            'mass-microgram': {
                'displayName': 'µg',
                'unitPattern-count-one': '{0} µg',
                'unitPattern-count-other': '{0} µg'
            },
            'mass-ton': {
                'displayName': 'tons',
                'unitPattern-count-one': '{0} tn',
                'unitPattern-count-other': '{0} tn'
            },
            'mass-stone': {
                'displayName': 'stones',
                'unitPattern-count-one': '{0} st',
                'unitPattern-count-other': '{0} st'
            },
            'mass-pound': {
                'displayName': 'pounds',
                'unitPattern-count-one': '{0} lb',
                'unitPattern-count-other': '{0} lb',
                'perUnitPattern': '{0}/lb'
            },
            'mass-ounce': {
                'displayName': 'oz',
                'unitPattern-count-one': '{0} oz',
                'unitPattern-count-other': '{0} oz',
                'perUnitPattern': '{0}/oz'
            },
            'mass-ounce-troy': {
                'displayName': 'oz troy',
                'unitPattern-count-one': '{0} oz t',
                'unitPattern-count-other': '{0} oz t'
            },
            'mass-carat': {
                'displayName': 'carats',
                'unitPattern-count-one': '{0} CD',
                'unitPattern-count-other': '{0} CD'
            },
            'power-gigawatt': {
                'displayName': 'GW',
                'unitPattern-count-one': '{0} GW',
                'unitPattern-count-other': '{0} GW'
            },
            'power-megawatt': {
                'displayName': 'MW',
                'unitPattern-count-one': '{0} MW',
                'unitPattern-count-other': '{0} MW'
            },
            'power-kilowatt': {
                'displayName': 'kW',
                'unitPattern-count-one': '{0} kW',
                'unitPattern-count-other': '{0} kW'
            },
            'power-watt': {
                'displayName': 'watts',
                'unitPattern-count-one': '{0} W',
                'unitPattern-count-other': '{0} W'
            },
            'power-milliwatt': {
                'displayName': 'mW',
                'unitPattern-count-one': '{0} mW',
                'unitPattern-count-other': '{0} mW'
            },
            'power-horsepower': {
                'displayName': 'hp',
                'unitPattern-count-one': '{0} hp',
                'unitPattern-count-other': '{0} hp'
            },
            'pressure-hectopascal': {
                'displayName': 'hPa',
                'unitPattern-count-one': '{0} hPa',
                'unitPattern-count-other': '{0} hPa'
            },
            'pressure-millimeter-of-mercury': {
                'displayName': 'mmHg',
                'unitPattern-count-one': '{0} mmHg',
                'unitPattern-count-other': '{0} mmHg'
            },
            'pressure-pound-per-square-inch': {
                'displayName': 'psi',
                'unitPattern-count-one': '{0} psi',
                'unitPattern-count-other': '{0} psi'
            },
            'pressure-inch-hg': {
                'displayName': 'inHg',
                'unitPattern-count-one': '{0} inHg',
                'unitPattern-count-other': '{0} inHg'
            },
            'pressure-millibar': {
                'displayName': 'mbar',
                'unitPattern-count-one': '{0} mbar',
                'unitPattern-count-other': '{0} mbar'
            },
            'speed-kilometer-per-hour': {
                'displayName': 'km/hour',
                'unitPattern-count-one': '{0} kph',
                'unitPattern-count-other': '{0} kph'
            },
            'speed-meter-per-second': {
                'displayName': 'meters/sec',
                'unitPattern-count-one': '{0} m/s',
                'unitPattern-count-other': '{0} m/s'
            },
            'speed-mile-per-hour': {
                'displayName': 'miles/hour',
                'unitPattern-count-one': '{0} mph',
                'unitPattern-count-other': '{0} mph'
            },
            'speed-knot': {
                'displayName': 'kn',
                'unitPattern-count-one': '{0} kn',
                'unitPattern-count-other': '{0} kn'
            },
            'temperature-generic': {
                'displayName': '\xB0',
                'unitPattern-count-other': '{0}\xB0'
            },
            'temperature-celsius': {
                'displayName': 'deg. C',
                'unitPattern-count-one': '{0}\xB0C',
                'unitPattern-count-other': '{0}\xB0C'
            },
            'temperature-fahrenheit': {
                'displayName': 'deg. F',
                'unitPattern-count-one': '{0}\xB0F',
                'unitPattern-count-other': '{0}\xB0F'
            },
            'temperature-kelvin': {
                'displayName': 'K',
                'unitPattern-count-one': '{0} K',
                'unitPattern-count-other': '{0} K'
            },
            'volume-cubic-kilometer': {
                'displayName': 'km\xB3',
                'unitPattern-count-one': '{0} km\xB3',
                'unitPattern-count-other': '{0} km\xB3'
            },
            'volume-cubic-meter': {
                'displayName': 'm\xB3',
                'unitPattern-count-one': '{0} m\xB3',
                'unitPattern-count-other': '{0} m\xB3',
                'perUnitPattern': '{0}/m\xB3'
            },
            'volume-cubic-centimeter': {
                'displayName': 'cm\xB3',
                'unitPattern-count-one': '{0} cm\xB3',
                'unitPattern-count-other': '{0} cm\xB3',
                'perUnitPattern': '{0}/cm\xB3'
            },
            'volume-cubic-mile': {
                'displayName': 'mi\xB3',
                'unitPattern-count-one': '{0} mi\xB3',
                'unitPattern-count-other': '{0} mi\xB3'
            },
            'volume-cubic-yard': {
                'displayName': 'yards\xB3',
                'unitPattern-count-one': '{0} yd\xB3',
                'unitPattern-count-other': '{0} yd\xB3'
            },
            'volume-cubic-foot': {
                'displayName': 'feet\xB3',
                'unitPattern-count-one': '{0} ft\xB3',
                'unitPattern-count-other': '{0} ft\xB3'
            },
            'volume-cubic-inch': {
                'displayName': 'inches\xB3',
                'unitPattern-count-one': '{0} in\xB3',
                'unitPattern-count-other': '{0} in\xB3'
            },
            'volume-megaliter': {
                'displayName': 'ML',
                'unitPattern-count-one': '{0} ML',
                'unitPattern-count-other': '{0} ML'
            },
            'volume-hectoliter': {
                'displayName': 'hL',
                'unitPattern-count-one': '{0} hL',
                'unitPattern-count-other': '{0} hL'
            },
            'volume-liter': {
                'displayName': 'liters',
                'unitPattern-count-one': '{0} L',
                'unitPattern-count-other': '{0} L',
                'perUnitPattern': '{0}/L'
            },
            'volume-deciliter': {
                'displayName': 'dL',
                'unitPattern-count-one': '{0} dL',
                'unitPattern-count-other': '{0} dL'
            },
            'volume-centiliter': {
                'displayName': 'cL',
                'unitPattern-count-one': '{0} cL',
                'unitPattern-count-other': '{0} cL'
            },
            'volume-milliliter': {
                'displayName': 'mL',
                'unitPattern-count-one': '{0} mL',
                'unitPattern-count-other': '{0} mL'
            },
            'volume-pint-metric': {
                'displayName': 'mpt',
                'unitPattern-count-one': '{0} mpt',
                'unitPattern-count-other': '{0} mpt'
            },
            'volume-cup-metric': {
                'displayName': 'mcup',
                'unitPattern-count-one': '{0} mc',
                'unitPattern-count-other': '{0} mc'
            },
            'volume-acre-foot': {
                'displayName': 'acre ft',
                'unitPattern-count-one': '{0} ac ft',
                'unitPattern-count-other': '{0} ac ft'
            },
            'volume-bushel': {
                'displayName': 'bushels',
                'unitPattern-count-one': '{0} bu',
                'unitPattern-count-other': '{0} bu'
            },
            'volume-gallon': {
                'displayName': 'gal',
                'unitPattern-count-one': '{0} gal',
                'unitPattern-count-other': '{0} gal',
                'perUnitPattern': '{0}/gal US'
            },
            'volume-gallon-imperial': {
                'displayName': 'Imp. gal',
                'unitPattern-count-one': '{0} gal Imp.',
                'unitPattern-count-other': '{0} gal Imp.',
                'perUnitPattern': '{0}/gal Imp.'
            },
            'volume-quart': {
                'displayName': 'qts',
                'unitPattern-count-one': '{0} qt',
                'unitPattern-count-other': '{0} qt'
            },
            'volume-pint': {
                'displayName': 'pints',
                'unitPattern-count-one': '{0} pt',
                'unitPattern-count-other': '{0} pt'
            },
            'volume-cup': {
                'displayName': 'cups',
                'unitPattern-count-one': '{0} c',
                'unitPattern-count-other': '{0} c'
            },
            'volume-fluid-ounce': {
                'displayName': 'fl oz',
                'unitPattern-count-one': '{0} fl oz',
                'unitPattern-count-other': '{0} fl oz'
            },
            'volume-tablespoon': {
                'displayName': 'tbsp',
                'unitPattern-count-one': '{0} tbsp',
                'unitPattern-count-other': '{0} tbsp'
            },
            'volume-teaspoon': {
                'displayName': 'tsp',
                'unitPattern-count-one': '{0} tsp',
                'unitPattern-count-other': '{0} tsp'
            },
            'coordinateUnit': {
                'east': '{0} E',
                'north': '{0} N',
                'south': '{0} S',
                'west': '{0} W'
            }
        }
    }
};
var M_ISO639_OLD_TO_NEW$1 = {
    'iw': 'he',
    'ji': 'yi',
    'in': 'id',
    'sh': 'sr'
};
var M_SUPPORTED_LOCALES = function () {
    var LOCALES = Locale._cldrLocales, result = {}, i;
    if (LOCALES) {
        for (i = 0; i < LOCALES.length; i++) {
            result[LOCALES[i]] = true;
        }
    }
    return result;
}();
var mLocaleDatas = {};
function getCLDRCalendarName(sCalendarType) {
    if (!sCalendarType) {
        sCalendarType = sap.ui.getCore().getConfiguration().getCalendarType();
    }
    return 'ca-' + sCalendarType.toLowerCase();
}
function getData(oLocale) {
    var sLanguage = oLocale.getLanguage() || '', sScript = oLocale.getScript() || '', sRegion = oLocale.getRegion() || '', mData;
    function merge(obj, fallbackObj) {
        var name, value, fallbackValue;
        if (!fallbackObj) {
            return;
        }
        for (name in fallbackObj) {
            if (fallbackObj.hasOwnProperty(name)) {
                value = obj[name];
                fallbackValue = fallbackObj[name];
                if (value === undefined) {
                    obj[name] = fallbackValue;
                } else if (value === null) {
                    delete obj[name];
                } else if (typeof value === 'object' && typeof fallbackValue === 'object') {
                    merge(value, fallbackValue);
                }
            }
        }
    }
    function getOrLoad(sId) {
        if (!mLocaleDatas[sId] && (!M_SUPPORTED_LOCALES || M_SUPPORTED_LOCALES[sId] === true)) {
            var data = mLocaleDatas[sId] = LoaderExtensions.loadResource('sap/ui/core/cldr/' + sId + '.json', {
                dataType: 'json',
                failOnError: false
            });
            if (data && data.__fallbackLocale) {
                merge(data, getOrLoad(data.__fallbackLocale));
                delete data.__fallbackLocale;
            }
        }
        return mLocaleDatas[sId];
    }
    sLanguage = sLanguage && M_ISO639_OLD_TO_NEW$1[sLanguage] || sLanguage;
    if (sLanguage === 'no') {
        sLanguage = 'nb';
    }
    if (sLanguage === 'zh' && !sRegion) {
        if (sScript === 'Hans') {
            sRegion = 'CN';
        } else if (sScript === 'Hant') {
            sRegion = 'TW';
        }
    }
    var sId = sLanguage + '_' + sRegion;
    if (sLanguage && sRegion) {
        mData = getOrLoad(sId);
    }
    if (!mData && sLanguage) {
        mData = getOrLoad(sLanguage);
    }
    mLocaleDatas[sId] = mData || M_DEFAULT_DATA;
    return mLocaleDatas[sId];
}
var CustomLocaleData = LocaleData.extend('sap.ui.core.CustomLocaleData', {
    constructor: function (oLocale) {
        LocaleData.apply(this, arguments);
        this.mCustomData = sap.ui.getCore().getConfiguration().getFormatSettings().getCustomLocaleData();
    },
    _get: function () {
        var aArguments = Array.prototype.slice.call(arguments), sCalendar, sKey;
        if (aArguments[0].indexOf('ca-') == 0) {
            sCalendar = aArguments[0];
            if (sCalendar == getCLDRCalendarName()) {
                aArguments = aArguments.slice(1);
            }
        }
        sKey = aArguments.join('-');
        var vValue = this.mCustomData[sKey];
        if (vValue == null) {
            vValue = this._getDeep(this.mCustomData, arguments);
            if (vValue == null) {
                vValue = this._getDeep(this.mData, arguments);
            }
        }
        return vValue;
    },
    _getMerged: function () {
        var mData = this._getDeep(this.mData, arguments);
        var mCustomData = this._getDeep(this.mCustomData, arguments);
        return jQuery.extend({}, mData, mCustomData);
    }
});
LocaleData.getInstance = function (oLocale) {
    return oLocale.hasPrivateUseSubtag('sapufmt') ? new CustomLocaleData(oLocale) : new LocaleData(oLocale);
};

var Configuration = BaseObject$1.extend('sap.ui.core.Configuration', {
    constructor: function (oCore) {
        this._oCore = oCore;
        function detectLanguage() {
            function navigatorLanguage() {
                if (Device.os.android) {
                    var match = navigator.userAgent.match(/\s([a-z]{2}-[a-z]{2})[;)]/i);
                    if (match) {
                        return match[1];
                    }
                }
                return navigator.language;
            }
            return convertToLocaleOrNull(navigator.languages && navigator.languages[0] || navigatorLanguage() || navigator.userLanguage || navigator.browserLanguage) || new Locale('en');
        }
        var M_SETTINGS = {
            'theme': {
                type: 'string',
                defaultValue: 'base'
            },
            'language': {
                type: 'Locale',
                defaultValue: detectLanguage()
            },
            'formatLocale': {
                type: 'Locale',
                defaultValue: null
            },
            'calendarType': {
                type: 'string',
                defaultValue: null
            },
            'accessibility': {
                type: 'boolean',
                defaultValue: true
            },
            'autoAriaBodyRole': {
                type: 'boolean',
                defaultValue: true,
                noUrl: true
            },
            'animation': {
                type: 'boolean',
                defaultValue: true
            },
            'animationMode': {
                type: Configuration.AnimationMode,
                defaultValue: undefined
            },
            'rtl': {
                type: 'boolean',
                defaultValue: null
            },
            'debug': {
                type: 'boolean',
                defaultValue: false
            },
            'inspect': {
                type: 'boolean',
                defaultValue: false
            },
            'originInfo': {
                type: 'boolean',
                defaultValue: false
            },
            'noConflict': {
                type: 'boolean',
                defaultValue: false,
                noUrl: true
            },
            'noDuplicateIds': {
                type: 'boolean',
                defaultValue: true
            },
            'trace': {
                type: 'boolean',
                defaultValue: false,
                noUrl: true
            },
            'modules': {
                type: 'string[]',
                defaultValue: [],
                noUrl: true
            },
            'areas': {
                type: 'string[]',
                defaultValue: null,
                noUrl: true
            },
            'onInit': {
                type: 'code',
                defaultValue: undefined,
                noUrl: true
            },
            'uidPrefix': {
                type: 'string',
                defaultValue: '__',
                noUrl: true
            },
            'ignoreUrlParams': {
                type: 'boolean',
                defaultValue: false,
                noUrl: true
            },
            'preload': {
                type: 'string',
                defaultValue: 'auto'
            },
            'rootComponent': {
                type: 'string',
                defaultValue: '',
                noUrl: true
            },
            'preloadLibCss': {
                type: 'string[]',
                defaultValue: []
            },
            'application': {
                type: 'string',
                defaultValue: ''
            },
            'appCacheBuster': {
                type: 'string[]',
                defaultValue: []
            },
            'bindingSyntax': {
                type: 'string',
                defaultValue: 'default',
                noUrl: true
            },
            'versionedLibCss': {
                type: 'boolean',
                defaultValue: false
            },
            'manifestFirst': {
                type: 'boolean',
                defaultValue: false
            },
            'flexibilityServices': {
                type: 'string',
                defaultValue: '/sap/bc/lrep'
            },
            'whitelistService': {
                type: 'string',
                defaultValue: null,
                noUrl: true
            },
            'frameOptions': {
                type: 'string',
                defaultValue: 'default',
                noUrl: true
            },
            'frameOptionsConfig': {
                type: 'object',
                defaultValue: undefined,
                noUrl: true
            },
            'support': {
                type: 'string[]',
                defaultValue: null
            },
            'xx-wc-force-polyfill': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-wc-no-conflict': {
                type: 'string[]',
                defaultValue: [],
                noUrl: true
            },
            'xx-wc-size-compact': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-rootComponentNode': {
                type: 'string',
                defaultValue: '',
                noUrl: true
            },
            'xx-appCacheBusterMode': {
                type: 'string',
                defaultValue: 'sync'
            },
            'xx-appCacheBusterHooks': {
                type: 'object',
                defaultValue: undefined,
                noUrl: true
            },
            'xx-disableCustomizing': {
                type: 'boolean',
                defaultValue: false,
                noUrl: true
            },
            'xx-viewCache': {
                type: 'boolean',
                defaultValue: true
            },
            'xx-test-mobile': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-depCache': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-domPatching': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-libraryPreloadFiles': {
                type: 'string[]',
                defaultValue: []
            },
            'xx-componentPreload': {
                type: 'string',
                defaultValue: ''
            },
            'xx-designMode': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-supportedLanguages': {
                type: 'string[]',
                defaultValue: []
            },
            'xx-bootTask': {
                type: 'function',
                defaultValue: undefined,
                noUrl: true
            },
            'xx-suppressDeactivationOfControllerCode': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-lesssupport': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-handleValidation': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-fiori2Adaptation': {
                type: 'string[]',
                defaultValue: []
            },
            'xx-cache-use': {
                type: 'boolean',
                defaultValue: true
            },
            'xx-cache-excludedKeys': {
                type: 'string[]',
                defaultValue: []
            },
            'xx-cache-serialization': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-nosync': {
                type: 'string',
                defaultValue: ''
            },
            'xx-waitForTheme': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-xml-processing': {
                type: 'string',
                defaultValue: ''
            },
            'xx-avoidAriaApplicationRole': {
                type: 'boolean',
                defaultValue: false
            },
            'xx-hyphenation': {
                type: 'string',
                defaultValue: ''
            },
            'xx-flexBundleRequestForced': {
                type: 'boolean',
                defaultValue: false
            },
            'statistics': {
                type: 'boolean',
                defaultValue: false
            }
        };
        var M_COMPAT_FEATURES = {
            'xx-test': '1.15',
            'flexBoxPolyfill': '1.14',
            'sapMeTabContainer': '1.14',
            'sapMeProgessIndicator': '1.14',
            'sapMGrowingList': '1.14',
            'sapMListAsTable': '1.14',
            'sapMDialogWithPadding': '1.14',
            'sapCoreBindingSyntax': '1.24'
        };
        this.oFormatSettings = new Configuration.FormatSettings(this);
        var config = this;
        function setValue(sName, sValue) {
            if (typeof sValue === 'undefined' || sValue === null) {
                return;
            }
            switch (M_SETTINGS[sName].type) {
            case 'boolean':
                if (typeof sValue === 'string') {
                    if (M_SETTINGS[sName].defaultValue) {
                        config[sName] = sValue.toLowerCase() != 'false';
                    } else {
                        config[sName] = sValue.toLowerCase() === 'true' || sValue.toLowerCase() === 'x';
                    }
                } else {
                    config[sName] = !!sValue;
                }
                break;
            case 'string':
                config[sName] = '' + sValue;
                break;
            case 'code':
                config[sName] = typeof sValue === 'function' ? sValue : String(sValue);
                break;
            case 'function':
                if (typeof sValue !== 'function') {
                    throw new Error('unsupported value');
                }
                config[sName] = sValue;
                break;
            case 'string[]':
                if (Array.isArray(sValue)) {
                    config[sName] = sValue;
                } else if (typeof sValue === 'string') {
                    config[sName] = sValue.split(/[ ,;]/).map(function (s) {
                        return s.trim();
                    });
                } else {
                    throw new Error('unsupported value');
                }
                break;
            case 'object':
                if (typeof sValue !== 'object') {
                    throw new Error('unsupported value');
                }
                config[sName] = sValue;
                break;
            case 'Locale':
                var oLocale = convertToLocaleOrNull(sValue);
                if (oLocale || M_SETTINGS[sName].defaultValue == null) {
                    config[sName] = oLocale;
                } else {
                    throw new Error('unsupported value');
                }
                break;
            default:
                var vType = M_SETTINGS[sName].type;
                if (typeof vType === 'object') {
                    checkEnum(vType, sValue, sName);
                    config[sName] = sValue;
                } else {
                    throw new Error('illegal state');
                }
            }
        }
        function validateThemeRoot(sThemeRoot) {
            var oThemeRoot, sPath;
            try {
                oThemeRoot = new URI(sThemeRoot, window.location.href).normalize();
                sPath = oThemeRoot.path();
                return sPath + (sPath.slice(-1) === '/' ? '' : '/') + 'UI5/';
            } catch (e) {
            }
        }
        for (var n in M_SETTINGS) {
            config[n] = M_SETTINGS[n].defaultValue;
        }
        var oCfg = window['sap-ui-config'] || {};
        oCfg.oninit = oCfg.oninit || oCfg['evt-oninit'];
        for (var n in M_SETTINGS) {
            if (oCfg.hasOwnProperty(n.toLowerCase())) {
                setValue(n, oCfg[n.toLowerCase()]);
            } else if (!/^xx-/.test(n) && oCfg.hasOwnProperty('xx-' + n.toLowerCase())) {
                setValue(n, oCfg['xx-' + n.toLowerCase()]);
            }
        }
        if (oCfg.libs) {
            config.modules = oCfg.libs.split(',').map(function (lib) {
                return lib.trim() + '.library';
            }).concat(config.modules);
        }
        var PARAM_CVERS = 'compatversion';
        var DEFAULT_CVERS = oCfg[PARAM_CVERS];
        var BASE_CVERS = Version('1.14');
        this._compatversion = {};
        function _getCVers(key) {
            var v = !key ? DEFAULT_CVERS || BASE_CVERS.toString() : oCfg[PARAM_CVERS + '-' + key.toLowerCase()] || DEFAULT_CVERS || M_COMPAT_FEATURES[key] || BASE_CVERS.toString();
            v = Version(v.toLowerCase() === 'edge' ? Global.version : v);
            return Version(v.getMajor(), v.getMinor());
        }
        this._compatversion._default = _getCVers();
        for (var n in M_COMPAT_FEATURES) {
            this._compatversion[n] = _getCVers(n);
        }
        function getMetaTagValue(sName) {
            var oMetaTag = document.querySelector('META[name=\'' + sName + '\']'), sMetaContent = oMetaTag && oMetaTag.getAttribute('content');
            if (sMetaContent) {
                return sMetaContent;
            }
        }
        if (!config.ignoreUrlParams) {
            var sUrlPrefix = 'sap-ui-';
            var oUriParams = new UriParameters(window.location.href);
            if (oUriParams.mParams['sap-language']) {
                var sValue = config.sapLogonLanguage = oUriParams.get('sap-language');
                var oLocale = sValue && convertToLocaleOrNull(M_ABAP_LANGUAGE_TO_LOCALE[sValue.toUpperCase()] || sValue);
                if (oLocale) {
                    config.language = oLocale;
                } else if (sValue && !oUriParams.get('sap-locale') && !oUriParams.get('sap-ui-language')) {
                    Log.warning('sap-language \'' + sValue + '\' is not a valid BCP47 language tag and will only be used as SAP logon language');
                }
            }
            if (oUriParams.mParams['sap-locale']) {
                setValue('language', oUriParams.get('sap-locale'));
            }
            if (oUriParams.mParams['sap-rtl']) {
                var sValue = oUriParams.get('sap-rtl');
                if (sValue === 'X' || sValue === 'x') {
                    setValue('rtl', true);
                } else {
                    setValue('rtl', false);
                }
            }
            if (oUriParams.mParams['sap-theme']) {
                var sValue = oUriParams.get('sap-theme');
                if (sValue === '') {
                    config['theme'] = M_SETTINGS['theme'].defaultValue;
                } else {
                    setValue('theme', sValue);
                }
            }
            if (oUriParams.mParams['sap-statistics']) {
                var sValue = oUriParams.get('sap-statistics');
                setValue('statistics', sValue);
            }
            for (var n in M_SETTINGS) {
                if (M_SETTINGS[n].noUrl) {
                    continue;
                }
                var sValue = oUriParams.get(sUrlPrefix + n);
                if (sValue == null && !/^xx-/.test(n)) {
                    sValue = oUriParams.get(sUrlPrefix + 'xx-' + n);
                }
                if (sValue === '') {
                    config[n] = M_SETTINGS[n].defaultValue;
                } else {
                    setValue(n, sValue);
                }
            }
            if (oUriParams.mParams['sap-ui-legacy-date-format']) {
                this.oFormatSettings.setLegacyDateFormat(oUriParams.get('sap-ui-legacy-date-format'));
            }
            if (oUriParams.mParams['sap-ui-legacy-time-format']) {
                this.oFormatSettings.setLegacyTimeFormat(oUriParams.get('sap-ui-legacy-time-format'));
            }
            if (oUriParams.mParams['sap-ui-legacy-number-format']) {
                this.oFormatSettings.setLegacyNumberFormat(oUriParams.get('sap-ui-legacy-number-format'));
            }
        }
        config.sapparams = config.sapparams || {};
        config.sapparams['sap-language'] = this.getSAPLogonLanguage();
        [
            'sap-client',
            'sap-server',
            'sap-system'
        ].forEach(function (sName) {
            if (!config.ignoreUrlParams && oUriParams.get(sName)) {
                config.sapparams[sName] = oUriParams.get(sName);
            } else {
                config.sapparams[sName] = getMetaTagValue(sName);
            }
        });
        this.derivedRTL = Locale._impliesRTL(config.language);
        var sTheme = config.theme;
        var sThemeRoot;
        var iIndex = sTheme.indexOf('@');
        if (iIndex >= 0) {
            sThemeRoot = validateThemeRoot(sTheme.slice(iIndex + 1));
            if (sThemeRoot) {
                config.theme = sTheme.slice(0, iIndex);
                config.themeRoot = sThemeRoot;
            } else {
                config.theme = oCfg.theme && oCfg.theme !== sTheme ? oCfg.theme : 'base';
                iIndex = -1;
            }
        }
        config.theme = this._normalizeTheme(config.theme, sThemeRoot);
        var aCoreLangs = config['languagesDeliveredWithCore'] = Locale._coreI18nLocales;
        var aLangs = config['xx-supportedLanguages'];
        if (aLangs.length === 0 || aLangs.length === 1 && aLangs[0] === '*') {
            aLangs = [];
        } else if (aLangs.length === 1 && aLangs[0] === 'default') {
            aLangs = aCoreLangs || [];
        }
        config['xx-supportedLanguages'] = aLangs;
        var vAdaptations = config['xx-fiori2Adaptation'];
        if (vAdaptations.length === 0 || vAdaptations.length === 1 && vAdaptations[0] === 'false') {
            vAdaptations = false;
        } else if (vAdaptations.length === 1 && vAdaptations[0] === 'true') {
            vAdaptations = true;
        }
        config['xx-fiori2Adaptation'] = vAdaptations;
        var vWCNoConflict = config['xx-wc-no-conflict'];
        if (Array.isArray(vWCNoConflict)) {
            vWCNoConflict = vWCNoConflict.filter(function (item) {
                return item !== '';
            });
        }
        if (vWCNoConflict.length === 0 || vWCNoConflict.length === 1 && vWCNoConflict[0] === 'false') {
            vWCNoConflict = false;
        } else if (vWCNoConflict.length === 1 && vWCNoConflict[0] === 'true') {
            vWCNoConflict = true;
        }
        config['xx-wc-no-conflict'] = vWCNoConflict;
        if (config['bindingSyntax'] === 'default') {
            config['bindingSyntax'] = config.getCompatibilityVersion('sapCoreBindingSyntax').compareTo('1.26') < 0 ? 'simple' : 'complex';
        }
        if (!config['whitelistService']) {
            var sMetaTagValue = getMetaTagValue('sap.whitelistService');
            if (sMetaTagValue) {
                config['whitelistService'] = sMetaTagValue;
                if (config['frameOptions'] === 'default') {
                    config['frameOptions'] = 'trusted';
                }
            }
        }
        if (config['frameOptions'] === 'default' || config['frameOptions'] !== 'allow' && config['frameOptions'] !== 'deny' && config['frameOptions'] !== 'trusted') {
            config['frameOptions'] = 'allow';
        }
        var aCSSLibs = config['preloadLibCss'];
        if (aCSSLibs.length > 0) {
            aCSSLibs.appManaged = aCSSLibs[0].slice(0, 1) === '!';
            if (aCSSLibs.appManaged) {
                aCSSLibs[0] = aCSSLibs[0].slice(1);
            }
            if (aCSSLibs[0] === '*') {
                aCSSLibs.shift();
                config.modules.forEach(function (mod) {
                    var m = mod.match(/^(.*)\.library$/);
                    if (m) {
                        aCSSLibs.unshift(m[1]);
                    }
                });
            }
        }
        for (var n in M_SETTINGS) {
            if (config[n] !== M_SETTINGS[n].defaultValue) {
                Log.info('  ' + n + ' = ' + config[n]);
            }
        }
        if (this.getAnimationMode() === undefined) {
            if (this.animation) {
                this.setAnimationMode(Configuration.AnimationMode.full);
            } else {
                this.setAnimationMode(Configuration.AnimationMode.minimal);
            }
        } else {
            this.setAnimationMode(this.getAnimationMode());
        }
    },
    getVersion: function () {
        if (this._version) {
            return this._version;
        }
        this._version = new Version(Global.version);
        return this._version;
    },
    getCompatibilityVersion: function (sFeature) {
        if (typeof sFeature === 'string' && this._compatversion[sFeature]) {
            return this._compatversion[sFeature];
        }
        return this._compatversion._default;
    },
    getTheme: function () {
        return this.theme;
    },
    _setTheme: function (sTheme) {
        this.theme = sTheme;
        return this;
    },
    _normalizeTheme: function (sTheme, sThemeBaseUrl) {
        if (sTheme && sThemeBaseUrl == null && sTheme.match(/^sap_corbu$/i)) {
            return 'sap_goldreflection';
        }
        return sTheme;
    },
    getLanguage: function () {
        return this.language.sLocaleId;
    },
    getLanguageTag: function () {
        return this.language.toString();
    },
    getSAPLogonLanguage: function () {
        return this.sapLogonLanguage || this.language.getSAPLogonLanguage();
    },
    setLanguage: function (sLanguage, sSAPLogonLanguage) {
        var oLocale = convertToLocaleOrNull(sLanguage), bOldRTL = this.getRTL(), mChanges;
        check(oLocale, 'Configuration.setLanguage: sLanguage must be a valid BCP47 language tag');
        check(sSAPLogonLanguage == null || typeof sSAPLogonLanguage === 'string' && /[A-Z0-9]{2,2}/i.test(sSAPLogonLanguage), 'Configuration.setLanguage: sSAPLogonLanguage must be null or be a string of length 2, consisting of digits and latin characters only', true);
        if (oLocale.toString() != this.getLanguageTag() || sSAPLogonLanguage !== this.sapLogonLanguage) {
            this.language = oLocale;
            this.sapLogonLanguage = sSAPLogonLanguage || undefined;
            this.sapparams['sap-language'] = this.getSAPLogonLanguage();
            mChanges = this._collect();
            mChanges.language = this.getLanguageTag();
            this.derivedRTL = Locale._impliesRTL(oLocale);
            if (bOldRTL != this.getRTL()) {
                mChanges.rtl = this.getRTL();
            }
            this._endCollect();
        }
        return this;
    },
    getLocale: function () {
        return this.language;
    },
    getSAPParam: function (sName) {
        return this.sapparams && this.sapparams[sName];
    },
    getXMLProcessingMode: function () {
        return this['xx-xml-processing'];
    },
    setXMLProcessingMode: function (sMode) {
        this['xx-xml-processing'] = sMode;
        return this;
    },
    isUI5CacheOn: function () {
        return this['xx-cache-use'];
    },
    setUI5CacheOn: function (on) {
        this['xx-cache-use'] = on;
        return this;
    },
    isUI5CacheSerializationSupportOn: function () {
        return this['xx-cache-serialization'];
    },
    setUI5CacheSerializationSupport: function (on) {
        this['xx-cache-serialization'] = on;
        return this;
    },
    getUI5CacheExcludedKeys: function () {
        return this['xx-cache-excludedKeys'];
    },
    getCalendarType: function () {
        var sName;
        if (!CalendarType) {
            Global.getCore().loadLibrary('sap.ui.core');
        }
        if (this.calendarType) {
            for (sName in CalendarType) {
                if (sName.toLowerCase() === this.calendarType.toLowerCase()) {
                    this.calendarType = sName;
                    return this.calendarType;
                }
            }
            Log.warning('Parameter \'calendarType\' is set to ' + this.calendarType + ' which isn\'t a valid value and therefore ignored. The calendar type is determined from format setting and current locale');
        }
        var sLegacyDateFormat = this.oFormatSettings.getLegacyDateFormat();
        switch (sLegacyDateFormat) {
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
            return CalendarType.Gregorian;
        case '7':
        case '8':
        case '9':
            return CalendarType.Japanese;
        case 'A':
        case 'B':
            return CalendarType.Islamic;
        case 'C':
            return CalendarType.Persian;
        }
        return LocaleData.getInstance(this.getLocale()).getPreferredCalendarType();
    },
    setCalendarType: function (sCalendarType) {
        var mChanges;
        if (this.calendarType !== sCalendarType) {
            mChanges = this._collect();
            this.calendarType = mChanges.calendarType = sCalendarType;
            this._endCollect();
        }
        return this;
    },
    getFormatLocale: function () {
        return (this.formatLocale || this.language).toString();
    },
    setFormatLocale: function (sFormatLocale) {
        var oFormatLocale = convertToLocaleOrNull(sFormatLocale), mChanges;
        check(sFormatLocale == null || typeof sFormatLocale === 'string' && oFormatLocale, 'sFormatLocale must be a BCP47 language tag or Java Locale id or null');
        if (toLanguageTag(oFormatLocale) !== toLanguageTag(this.formatLocale)) {
            this.formatLocale = oFormatLocale;
            mChanges = this._collect();
            mChanges.formatLocale = toLanguageTag(oFormatLocale);
            this._endCollect();
        }
        return this;
    },
    getLanguagesDeliveredWithCore: function () {
        return this['languagesDeliveredWithCore'];
    },
    getSupportedLanguages: function () {
        return this['xx-supportedLanguages'];
    },
    getAccessibility: function () {
        return this.accessibility;
    },
    getAutoAriaBodyRole: function () {
        return this.autoAriaBodyRole;
    },
    getAvoidAriaApplicationRole: function () {
        return this.getAutoAriaBodyRole() && this['xx-avoidAriaApplicationRole'];
    },
    getAnimation: function () {
        return this.animation;
    },
    getAnimationMode: function () {
        return this.animationMode;
    },
    setAnimationMode: function (sAnimationMode) {
        checkEnum(Configuration.AnimationMode, sAnimationMode, 'animationMode');
        this.animation = sAnimationMode !== Configuration.AnimationMode.minimal && sAnimationMode !== Configuration.AnimationMode.none;
        this.animationMode = sAnimationMode;
        if (this._oCore && this._oCore._setupAnimation) {
            this._oCore._setupAnimation();
        }
    },
    getRTL: function () {
        return this.rtl === null ? this.derivedRTL : this.rtl;
    },
    getFiori2Adaptation: function () {
        return this['xx-fiori2Adaptation'];
    },
    getWCForcePolyfill: function () {
        return this['xx-wc-force-polyfill'];
    },
    getWCNoConflict: function () {
        return this['xx-wc-no-conflict'];
    },
    getWCSizeCompact: function () {
        return this['xx-wc-size-compact'];
    },
    setRTL: function (bRTL) {
        check(bRTL === null || typeof bRTL === 'boolean', 'bRTL must be null or a boolean');
        var oldRTL = this.getRTL(), mChanges;
        this.rtl = bRTL;
        if (oldRTL != this.getRTL()) {
            mChanges = this._collect();
            mChanges.rtl = this.getRTL();
            this._endCollect();
        }
        return this;
    },
    getDebug: function () {
        return this.debug;
    },
    getInspect: function () {
        return this.inspect;
    },
    getOriginInfo: function () {
        return this.originInfo;
    },
    getNoDuplicateIds: function () {
        return this.noDuplicateIds;
    },
    getTrace: function () {
        return this.trace;
    },
    getUIDPrefix: function () {
        return this.uidPrefix;
    },
    getDesignMode: function () {
        return this['xx-designMode'];
    },
    getSuppressDeactivationOfControllerCode: function () {
        return this['xx-suppressDeactivationOfControllerCode'];
    },
    getControllerCodeDeactivated: function () {
        return this.getDesignMode() && !this.getSuppressDeactivationOfControllerCode();
    },
    getApplication: function () {
        return this.application;
    },
    getRootComponent: function () {
        return this.rootComponent;
    },
    getAppCacheBuster: function () {
        return this.appCacheBuster;
    },
    getAppCacheBusterMode: function () {
        return this['xx-appCacheBusterMode'];
    },
    getAppCacheBusterHooks: function () {
        return this['xx-appCacheBusterHooks'];
    },
    getDisableCustomizing: function () {
        return this['xx-disableCustomizing'];
    },
    getViewCache: function () {
        return this['xx-viewCache'];
    },
    getDomPatching: function () {
        return this['xx-domPatching'];
    },
    getPreload: function () {
        return this.preload;
    },
    getDepCache: function () {
        return this['xx-depCache'];
    },
    getManifestFirst: function () {
        return this.manifestFirst;
    },
    isFlexBundleRequestForced: function () {
        return this['xx-flexBundleRequestForced'];
    },
    getFlexibilityServices: function () {
        return this.flexibilityServices;
    },
    getComponentPreload: function () {
        return this['xx-componentPreload'] || this.preload;
    },
    getFormatSettings: function () {
        return this.oFormatSettings;
    },
    getFrameOptions: function () {
        return this.frameOptions;
    },
    getWhitelistService: function () {
        return this.whitelistService;
    },
    getSupportMode: function () {
        return this.support;
    },
    _collect: function () {
        var mChanges = this.mChanges || (this.mChanges = { __count: 0 });
        mChanges.__count++;
        return mChanges;
    },
    _endCollect: function () {
        var mChanges = this.mChanges;
        if (mChanges && --mChanges.__count === 0) {
            delete mChanges.__count;
            this._oCore && this._oCore.fireLocalizationChanged(mChanges);
            delete this.mChanges;
        }
    },
    getStatistics: function () {
        var result = this.statistics;
        try {
            result = result || window.localStorage.getItem('sap-ui-statistics') == 'X';
        } catch (e) {
        }
        return result;
    },
    getNoNativeScroll: function () {
        return false;
    },
    getHandleValidation: function () {
        return this['xx-handleValidation'];
    },
    getHyphenation: function () {
        return this['xx-hyphenation'];
    },
    applySettings: function (mSettings) {
        function applyAll(ctx, m) {
            var sName, sMethod;
            for (sName in m) {
                sMethod = 'set' + sName.slice(0, 1).toUpperCase() + sName.slice(1);
                if (sName === 'formatSettings' && ctx.oFormatSettings) {
                    applyAll(ctx.oFormatSettings, m[sName]);
                } else if (typeof ctx[sMethod] === 'function') {
                    ctx[sMethod](m[sName]);
                } else {
                    Log.warning('Configuration.applySettings: unknown setting \'' + sName + '\' ignored');
                }
            }
        }
        fnAssert(typeof mSettings === 'object', 'mSettings must be an object');
        this._collect();
        applyAll(this, mSettings);
        this._endCollect();
        return this;
    }
});
Configuration.AnimationMode = {
    full: 'full',
    basic: 'basic',
    minimal: 'minimal',
    none: 'none'
};
function convertToLocaleOrNull(sLanguage) {
    try {
        if (sLanguage && typeof sLanguage === 'string') {
            return new Locale(sLanguage);
        }
    } catch (e) {
    }
}
function toLanguageTag(oLocale) {
    return oLocale ? oLocale.toString() : null;
}
var M_ABAP_LANGUAGE_TO_LOCALE = {
    'ZH': 'zh-Hans',
    'ZF': 'zh-Hant',
    '1Q': 'en-US-x-saptrc',
    '2Q': 'en-US-x-sappsd'
};
var M_ABAP_DATE_FORMAT_PATTERN = {
    '': { pattern: null },
    '1': { pattern: 'dd.MM.yyyy' },
    '2': { pattern: 'MM/dd/yyyy' },
    '3': { pattern: 'MM-dd-yyyy' },
    '4': { pattern: 'yyyy.MM.dd' },
    '5': { pattern: 'yyyy/MM/dd' },
    '6': { pattern: 'yyyy-MM-dd' },
    '7': { pattern: 'Gyy.MM.dd' },
    '8': { pattern: 'Gyy/MM/dd' },
    '9': { pattern: 'Gyy-MM-dd' },
    'A': { pattern: 'yyyy/MM/dd' },
    'B': { pattern: 'yyyy/MM/dd' },
    'C': { pattern: 'yyyy/MM/dd' }
};
var M_ABAP_TIME_FORMAT_PATTERN = {
    '': {
        'short': null,
        medium: null,
        dayPeriods: null
    },
    '0': {
        'short': 'HH:mm',
        medium: 'HH:mm:ss',
        dayPeriods: null
    },
    '1': {
        'short': 'hh:mm a',
        medium: 'hh:mm:ss a',
        dayPeriods: [
            'AM',
            'PM'
        ]
    },
    '2': {
        'short': 'hh:mm a',
        medium: 'hh:mm:ss a',
        dayPeriods: [
            'am',
            'pm'
        ]
    },
    '3': {
        'short': 'KK:mm a',
        medium: 'KK:mm:ss a',
        dayPeriods: [
            'AM',
            'PM'
        ]
    },
    '4': {
        'short': 'KK:mm a',
        medium: 'KK:mm:ss a',
        dayPeriods: [
            'am',
            'pm'
        ]
    }
};
var M_ABAP_NUMBER_FORMAT_SYMBOLS = {
    '': {
        groupingSeparator: null,
        decimalSeparator: null
    },
    ' ': {
        groupingSeparator: '.',
        decimalSeparator: ','
    },
    'X': {
        groupingSeparator: ',',
        decimalSeparator: '.'
    },
    'Y': {
        groupingSeparator: ' ',
        decimalSeparator: ','
    }
};
function check(bCondition, sMessage) {
    if (!bCondition) {
        throw new Error(sMessage);
    }
}
function checkEnum(oEnum, sValue, sPropertyName) {
    var aValidValues = [];
    for (var sKey in oEnum) {
        if (oEnum.hasOwnProperty(sKey)) {
            if (oEnum[sKey] === sValue) {
                return;
            }
            aValidValues.push(oEnum[sKey]);
        }
    }
    throw new Error('Unsupported Enumeration value for ' + sPropertyName + ', valid values are: ' + aValidValues.join(', '));
}
BaseObject$1.extend('sap.ui.core.Configuration.FormatSettings', {
    constructor: function (oConfiguration) {
        this.oConfiguration = oConfiguration;
        this.mSettings = {};
        this.sLegacyDateFormat = undefined;
        this.sLegacyTimeFormat = undefined;
        this.sLegacyNumberFormatSymbolSet = undefined;
    },
    getFormatLocale: function () {
        function fallback(that) {
            var oLocale = that.oConfiguration.language;
            if (!jQuery.isEmptyObject(that.mSettings)) {
                var l = oLocale.toString();
                if (l.indexOf('-x-') < 0) {
                    l = l + '-x-sapufmt';
                } else if (l.indexOf('-sapufmt') <= l.indexOf('-x-')) {
                    l = l + '-sapufmt';
                }
                oLocale = new Locale(l);
            }
            return oLocale;
        }
        return this.oConfiguration.formatLocale || fallback(this);
    },
    _set: function (sKey, oValue) {
        var oOldValue = this.mSettings[sKey];
        if (oValue != null) {
            this.mSettings[sKey] = oValue;
        } else {
            delete this.mSettings[sKey];
        }
        if ((oOldValue != null || oValue != null) && !fnEqual(oOldValue, oValue)) {
            var mChanges = this.oConfiguration._collect();
            mChanges[sKey] = oValue;
            this.oConfiguration._endCollect();
        }
    },
    getCustomUnits: function () {
        return this.mSettings['units'] ? this.mSettings['units']['short'] : undefined;
    },
    setCustomUnits: function (mUnits) {
        var mUnitsshort = null;
        if (mUnits) {
            mUnitsshort = { 'short': mUnits };
        }
        this._set('units', mUnitsshort);
        return this;
    },
    addCustomUnits: function (mUnits) {
        var mExistingUnits = this.getCustomUnits();
        if (mExistingUnits) {
            mUnits = jQuery.extend({}, mExistingUnits, mUnits);
        }
        this.setCustomUnits(mUnits);
        return this;
    },
    setUnitMappings: function (mUnitMappings) {
        this._set('unitMappings', mUnitMappings);
        return this;
    },
    addUnitMappings: function (mUnitMappings) {
        var mExistingUnits = this.getUnitMappings();
        if (mExistingUnits) {
            mUnitMappings = jQuery.extend({}, mExistingUnits, mUnitMappings);
        }
        this.setUnitMappings(mUnitMappings);
        return this;
    },
    getUnitMappings: function () {
        return this.mSettings['unitMappings'];
    },
    getDatePattern: function (sStyle) {
        fnAssert(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        return this.mSettings['dateFormats-' + sStyle];
    },
    setDatePattern: function (sStyle, sPattern) {
        check(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        this._set('dateFormats-' + sStyle, sPattern);
        return this;
    },
    getTimePattern: function (sStyle) {
        fnAssert(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        return this.mSettings['timeFormats-' + sStyle];
    },
    setTimePattern: function (sStyle, sPattern) {
        check(sStyle == 'short' || sStyle == 'medium' || sStyle == 'long' || sStyle == 'full', 'sStyle must be short, medium, long or full');
        this._set('timeFormats-' + sStyle, sPattern);
        return this;
    },
    getNumberSymbol: function (sType) {
        fnAssert(sType == 'decimal' || sType == 'group' || sType == 'plusSign' || sType == 'minusSign', 'sType must be decimal, group, plusSign or minusSign');
        return this.mSettings['symbols-latn-' + sType];
    },
    setNumberSymbol: function (sType, sSymbol) {
        check(sType == 'decimal' || sType == 'group' || sType == 'plusSign' || sType == 'minusSign', 'sType must be decimal, group, plusSign or minusSign');
        this._set('symbols-latn-' + sType, sSymbol);
        return this;
    },
    getCustomCurrencies: function () {
        return this.mSettings['currency'];
    },
    setCustomCurrencies: function (mCurrencies) {
        check(typeof mCurrencies === 'object' || mCurrencies == null, 'mCurrencyDigits must be an object');
        Object.keys(mCurrencies || {}).forEach(function (sCurrencyDigit) {
            check(typeof sCurrencyDigit === 'string');
            check(typeof mCurrencies[sCurrencyDigit] === 'object');
        });
        this._set('currency', mCurrencies);
        return this;
    },
    addCustomCurrencies: function (mCurrencies) {
        var mExistingCurrencies = this.getCustomCurrencies();
        if (mExistingCurrencies) {
            mCurrencies = jQuery.extend({}, mExistingCurrencies, mCurrencies);
        }
        this.setCustomCurrencies(mCurrencies);
        return this;
    },
    setFirstDayOfWeek: function (iValue) {
        check(typeof iValue == 'number' && iValue >= 0 && iValue <= 6, 'iValue must be an integer value between 0 and 6');
        this._set('weekData-firstDay', iValue);
        return this;
    },
    _setDayPeriods: function (sWidth, aTexts) {
        fnAssert(sWidth == 'narrow' || sWidth == 'abbreviated' || sWidth == 'wide', 'sWidth must be narrow, abbreviated or wide');
        this._set('dayPeriods-format-' + sWidth, aTexts);
        return this;
    },
    getLegacyDateFormat: function () {
        return this.sLegacyDateFormat || undefined;
    },
    setLegacyDateFormat: function (sFormatId) {
        sFormatId = sFormatId ? String(sFormatId).toUpperCase() : '';
        check(!sFormatId || M_ABAP_DATE_FORMAT_PATTERN.hasOwnProperty(sFormatId), 'sFormatId must be one of [\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'A\',\'B\',\'C\'] or empty');
        var mChanges = this.oConfiguration._collect();
        this.sLegacyDateFormat = mChanges.legacyDateFormat = sFormatId;
        this.setDatePattern('short', M_ABAP_DATE_FORMAT_PATTERN[sFormatId].pattern);
        this.setDatePattern('medium', M_ABAP_DATE_FORMAT_PATTERN[sFormatId].pattern);
        this.oConfiguration._endCollect();
        return this;
    },
    getLegacyTimeFormat: function () {
        return this.sLegacyTimeFormat || undefined;
    },
    setLegacyTimeFormat: function (sFormatId) {
        check(!sFormatId || M_ABAP_TIME_FORMAT_PATTERN.hasOwnProperty(sFormatId), 'sFormatId must be one of [\'0\',\'1\',\'2\',\'3\',\'4\'] or empty');
        var mChanges = this.oConfiguration._collect();
        this.sLegacyTimeFormat = mChanges.legacyTimeFormat = sFormatId = sFormatId || '';
        this.setTimePattern('short', M_ABAP_TIME_FORMAT_PATTERN[sFormatId]['short']);
        this.setTimePattern('medium', M_ABAP_TIME_FORMAT_PATTERN[sFormatId]['medium']);
        this._setDayPeriods('abbreviated', M_ABAP_TIME_FORMAT_PATTERN[sFormatId].dayPeriods);
        this.oConfiguration._endCollect();
        return this;
    },
    getLegacyNumberFormat: function () {
        return this.sLegacyNumberFormat || undefined;
    },
    setLegacyNumberFormat: function (sFormatId) {
        sFormatId = sFormatId ? sFormatId.toUpperCase() : '';
        check(!sFormatId || M_ABAP_NUMBER_FORMAT_SYMBOLS.hasOwnProperty(sFormatId), 'sFormatId must be one of [\' \',\'X\',\'Y\'] or empty');
        var mChanges = this.oConfiguration._collect();
        this.sLegacyNumberFormat = mChanges.legacyNumberFormat = sFormatId;
        this.setNumberSymbol('group', M_ABAP_NUMBER_FORMAT_SYMBOLS[sFormatId].groupingSeparator);
        this.setNumberSymbol('decimal', M_ABAP_NUMBER_FORMAT_SYMBOLS[sFormatId].decimalSeparator);
        this.oConfiguration._endCollect();
        return this;
    },
    setLegacyDateCalendarCustomizing: function (aMappings) {
        check(Array.isArray(aMappings), 'aMappings must be an Array');
        var mChanges = this.oConfiguration._collect();
        this.aLegacyDateCalendarCustomizing = mChanges.legacyDateCalendarCustomizing = aMappings;
        this.oConfiguration._endCollect();
        return this;
    },
    getLegacyDateCalendarCustomizing: function () {
        return this.aLegacyDateCalendarCustomizing;
    },
    getCustomLocaleData: function () {
        return this.mSettings;
    }
});

// temp fallback, this is the import.meta.url polyfill
// currentScript = (typeof document !== 'undefined' ? document.currentScript && document.currentScript.src || document.baseURI : new (typeof URL !== 'undefined' ? URL : require('ur'+'l').URL)('file:' + __filename).href)
// TODO: what happens when apps encounter this line?
// is top level as it needs to be executed while the script is processed (for the polyfill to work)
let currentScript;

function domReady() {
	return new Promise(function(resolve, reject) {
		if (document.body) {
			resolve();
		} else {
			document.addEventListener("DOMContentLoaded", function() {
				resolve();
			});
		}
	});
}

function readConfiguration() {
	function normalize(o) {
		for (var i in o) {
			var v = o[i];
			var il = i.toLowerCase();
			if ( !o.hasOwnProperty(il) ) {
				o[il] = v;
				delete o[i];
			}
		}
		return o;
	}

	var jsonConfig = document.getElementById("sap-ui-config");
	if (jsonConfig && jsonConfig.type === "application/json") {
		window['sap-ui-config'] = normalize(JSON.parse(jsonConfig.innerHTML));
	}
}

let bootPromise;

readConfiguration();
const configuration = new Configuration();

if (configuration.getTheme() === "base") {
	configuration._setTheme("sap_belize");
}

const setupBrowser = () => {
	var html = document.documentElement;

	var b = Device.browser;
	var id = b.name;

	if (id) {
		if (id === b.BROWSER.SAFARI && b.mobile) {
			id = "m" + id;
		}
		id = id + (b.version === -1 ? "" : Math.floor(b.version));
		html.dataset.sapUiBrowser = id;
	}
};

const setupOS = () => {
	var html = document.documentElement;

	html.dataset.sapUiOs = Device.os.name + Device.os.versionStr;

	var osCSS = null;
	switch (Device.os.name) {
		case Device.os.OS.IOS:
			osCSS = "sap-ios";
			break;
		case Device.os.OS.ANDROID:
			osCSS = "sap-android";
			break;
		case Device.os.OS.BLACKBERRY:
			osCSS = "sap-bb";
			break;
		case Device.os.OS.WINDOWS_PHONE:
			osCSS = "sap-winphone";
			break;
	}
	if (osCSS) {
		html.classList.add(osCSS);
	}
};

var Core$1 = {

	getConfiguration: function() {
		return configuration;
	},

	getLibraryResourceBundle: function () {
		// TODO make this work
		return {
			getText: function() {
				return "";
			}
		}
	},

	getAssetPath: function () {
		let bootScript = document.getElementById("sap-ui-bootstrap");
		if (bootScript) {
			// use the id if it is provided instead of the module variable populated by import.meta.url
			currentScript = bootScript.src;
		} else {
			// assume assets and bundle urls are relative
			return "";
		}
		return currentScript.slice(0, currentScript.lastIndexOf("/") + 1);
	},

	boot: function() {
		if (bootPromise) {
			return bootPromise;
		}

		bootPromise = new Promise(function (resolve, reject) {
			domReady().then(function() {

				setupBrowser();
				setupOS();

				EventEnrichment.run();
				ResizeHandler.initialize();

				if (window.ShadyDOM) {
					document.documentElement.setAttribute("data-sap-ui-wc-root", "");
					patchNodeValue();
				}

				IconFonts.load();
				DOMEventHandler.start();
				resolve();

			});
		});

		return bootPromise;

	},

	initLibrary: function() {

	}

};

window.sap.ui.getCore = function() {
	return Core$1;
};

inject$1(Core$1);

// Shorthands
const w = window;

// Map of observer objects per dom node
const observers = new WeakMap();

/**
 * Implements universal DOM node observation methods.
 */
class DOMObserver {
	constructor() {
		throw new Error("Static class");
	}

	/**
	 * This function abstracts out mutation observer usage inside shadow DOM.
	 * For native shadow DOM the native mutation observer is used.
	 * When the polyfill is used, the observeChildren ShadyDOM method is used instead.
	 *
	 * @throws Exception
	 * Note: does not allow several mutation observers per node. If there is a valid use-case, this behavior can be changed.
	 *
	 * @param node
	 * @param callback
	 * @param options - Only used for the native mutation observer
	 */
	static observeDOMNode(node, callback, options) {
		let observerObject = observers.get(node);
		if (observerObject) {
			throw new Error("A mutation/ShadyDOM observer is already assigned to this node.");
		}

		if (w.ShadyDOM) {
			observerObject = w.ShadyDOM.observeChildren(node, callback);
		} else {
			observerObject = new MutationObserver(callback);
			observerObject.observe(node, options);
		}

		observers.set(node, observerObject);
	}

	/**
	 * De-registers the mutation observer, depending on its type
	 * @param node
	 */
	static unobserveDOMNode(node) {
		const observerObject = observers.get(node);
		if (!observerObject) {
			return;
		}

		if (observerObject instanceof MutationObserver) {
			observerObject.disconnect();
		} else {
			w.ShadyDOM.unobserveChildren(observerObject);
		}
		observers.delete(node);
	}
}

// Shorthands
const d = document;

// Flags telling which styles were created in the <head> already (without checking the DOM directly)
const globalStyles = new Set();

// shadow DOM templates per tag
const shadowDOMTemplates = new Map();

let fetchThemePromise, jsonThemePromise;

const styles = new Map();

/**
 * Prepares the shadow DOM for a custom element, depending on the usage of the polyfill
 */
class ShadowDOM {
	constructor() {
		throw new Error("Static class");
	}

	static registerStyle(theme, styleName, styleObj) {
		if (typeof(styleObj) === "object" && styleObj._) {
			if (!styles.has(theme)) {
				styles.set(theme, {});
			}
			styles.get(theme)[styleName] = styleObj._;
		}
	}

	static prepareShadowDOM(ElementClass) {
		const stylesUrls = ElementClass.getMetadata().getStyleUrl();
		const tag = ElementClass.getMetadata().getTag();

		const cssFetchedPromise = ShadowDOM._fetchStyleUrls(stylesUrls);

		return cssFetchedPromise.then(cssResults => {
			let shadowDOM, rootSpan;
			if (window.ShadyDOM) {
				// Create styles in the <head> for each css file
				cssResults.forEach((css, i) => {
					ShadowDOM._createStyleTag(stylesUrls[i], css);
				});

				// Create the shadow DOM root span
				rootSpan = d.createElement("span");
				rootSpan.setAttribute("data-sap-ui-wc-placeholder", "");
				shadowDOM = rootSpan;
			} else {
				let template = this._getTemplateFor(tag);
				if (!template) {
					const cssText = cssResults.join(" ");
					template = this._createTemplateFor(tag, cssText);
				}
				shadowDOM = template.content.cloneNode(true);

				rootSpan = shadowDOM.querySelector("span[data-sap-ui-wc-placeholder]");
				rootSpan.setAttribute("data-sap-ui-browser", document.documentElement.getAttribute("data-sap-ui-browser"));
				rootSpan.setAttribute("data-sap-ui-os", document.documentElement.getAttribute("data-sap-ui-os"));

				// Copy all relevant attributes from the <html> to the <span>
				// TODO some are dynamic (theme) and some are not needed (sapUiMediaStd*)
				["class", "dir", "data-sap-ui-os", "lang", "data-sap-ui-animation", "data-sap-ui-animation-mode"].forEach(attr => {
					const isCompact = Core$1.getConfiguration().getWCSizeCompact();

					if (attr === "class") {
						rootSpan.setAttribute(attr, d.documentElement.getAttribute(attr) + (isCompact ? " sapUiSizeCompact" : ""));
					}
				});
			}

			return shadowDOM;
		});
	}

	static _getTemplateFor(tag) {
		return shadowDOMTemplates.get(tag);
	}

	static _createTemplateFor(tag, css) {
		const template = d.createElement("template");

		// Create a local <style> tag for the real shadow DOM
		let style = d.createElement("style");
		style.innerHTML = css;
		template.content.appendChild(style);

		// Create a root span
		let root = d.createElement("span");
		root.setAttribute("data-sap-ui-wc-placeholder", "");
		root.setAttribute("data-sap-ui-wc-root", "");

		template.content.appendChild(root);

		shadowDOMTemplates.set(tag, template);
		return template;
	}

	static _fetchStyleUrls(urls) {
		const requests = urls.map(ShadowDOM._fetchStyleUrl);
		return Promise.all(requests);
	}

	static async _fetchStyleUrl(styleName) {
		const theme = sap.ui.getCore().getConfiguration().getTheme();

		if (!styles.has(theme)) {
			styles.set(theme, {});
		}

		const themeMap = styles.get(theme);
		if (themeMap[styleName]) {
			return themeMap[styleName];
		}

		// requested style not present
		const themeData = await ShadowDOM.fetchTheme(theme);

		Object.keys(themeData).forEach(key => {
			themeMap[key] = themeData[key];
		});

		return themeMap[styleName];
	}

	static async fetchTheme(theme) {
		const assetPath = Core$1.getAssetPath();
		const themeURL = assetPath + `themes/${theme}/theme.json`;

		if (!fetchThemePromise) {
			fetchThemePromise = fetch(themeURL);
		}
		const response = await fetchThemePromise;

		if (!jsonThemePromise) {
			jsonThemePromise = response.json();
		}

		return jsonThemePromise;
	}

	static _createStyleTag(url, cssText) {
		if (globalStyles.has(url)) {
			return;
		}

		const style = d.createElement("style");
		style.type = "text/css";
		style.setAttribute("data-sap-source", url);
		style.innerHTML = cssText;
		d.head.appendChild(style);

		globalStyles.add(url);
	}
}

class DataType {

	static isValid(value) {
	}

	static generataTypeAcessors(types) {
		Object.keys(types).forEach(type => {
			Object.defineProperty(this, type, {
				get: function () {
					return types[type];
				}
			});
		});
	}
}

class ControlType {

	static isValid(type) {
		return this.isDescendantOf(type, this);
	}

	static isDescendantOf(klass, baseKlass) {
		if (typeof klass !== "function" || typeof baseKlass !== "function") {
			return false;
		}
		if (klass === baseKlass) {
			return true;
		}

		let parent = klass;
		do {
			parent = Object.getPrototypeOf(parent);
		} while (parent !== null && parent !== baseKlass);

		return parent === baseKlass;
	}
}

class WebComponentMetadata {
	constructor(metadata) {
		this.metadata = metadata;
	}
	getTag() {
		return this.metadata.tag;
	}
	getNoShadowDOM() {
		return this.metadata.noShadowDOM;
	}
	isLazy() {
		return !!this.metadata.lazy;
	}
	getStyleUrl() {
		return this.metadata.styleUrl || [];
	}
	usesNodeText() {
		return this.metadata.usesNodeText;
	}
	getDefaultSlot() {
		return this.metadata.defaultSlot || 'content';
	}
	getObservedProps() {
		const properties = this.getProperties();
		const allProps = Object.keys(properties);
		const observedProps = allProps.filter(prop => this.shouldAttributeBeObserved(prop));
		return observedProps;
	}
	shouldAttributeBeObserved(prop) {
		const childrenMap = this.getSlots();
		const isPrivateProperty = WebComponentMetadata.isPrivateProperty(prop);
		if (childrenMap[prop] || isPrivateProperty) {
			return false;
		}
		return true;
	}
	getSlots() {
		return this.metadata.slots || {};
	}
	hasSlots() {
		return !!Object.entries(this.getSlots()).length;
	}
	getProperties() {
		return this.metadata.properties || {};
	}
	getEvents() {
		return this.metadata.events || {};
	}

	static isPrivateProperty(prop) {
		return prop.charAt(0) === '_';
	}
	static validatePropertyValue(value, propData) {
		const isMultiple = propData.multiple;
		if (isMultiple) {
			return value.map(propValue => validateSingleProperty(propValue, propData));
		}
		return validateSingleProperty(value, propData);
	}
	static validateSlotValue(value, slotData) {
		const isMultiple = slotData.multiple;
		if (isMultiple) {
			return value.map(propValue => validateSingleSlot(propValue, slotData));
		}
		return validateSingleSlot(value, slotData);
	}

}

const validateSingleProperty = (value, propData) => {
	const propertyType = propData.type;

	// Association handling
	if (propData.association) {
		return value;
	}

	if (propertyType === Boolean) {
		return typeof value === "boolean" ? value : false;
	}
	if (propertyType === String) {
		return typeof value === "string" ? value : propData.defaultValue;
	}
	if (propertyType === Object) {
		return typeof value === "object" ? value : propData.defaultValue;
	}
	if (isDescendantOf(propertyType, DataType)) {
		return propertyType.isValid(value) ? value : propData.defaultValue;
	}
	if (isDescendantOf(propertyType, ControlType, true)) {
		if (value !== null && !propertyType.isValid(value.constructor.metadata.T)) {
			throw new Error(`${value.constructor.name} is not of type ${propertyType.name}`);
		}

		return value;
	}
};

const validateSingleSlot = (value, propData) => {
	const propertyType = propData.type;

	if (value !== null && !(value instanceof propertyType)) {
		throw new Error(`${ value } is not of type ${ propertyType }`);
	}

	return value;
};

const isDescendantOf = (klass, baseKlass, inclusive = false) => {
	if (typeof klass !== 'function' || typeof baseKlass !== 'function') {
		return false;
	}
	if (inclusive && klass === baseKlass) {
		return true;
	}
	let parent = klass;
	do {
		parent = Object.getPrototypeOf(parent);
	} while (parent !== null && parent !== baseKlass);
	return parent === baseKlass;
};

class Integer extends DataType {
	static isValid(value) {
		return Number.isInteger(value);
	}
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = new WeakMap();
const directive = (f) => {
    directives.set(f, true);
    return f;
};
const isDirective = (o) => typeof o === 'function' && directives.has(o);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isCEPolyfill = window.customElements !== undefined &&
    window.customElements.polyfillWrapFlushCallback !== undefined;
/**
 * Reparents nodes, starting from `startNode` (inclusive) to `endNode`
 * (exclusive), into another container (could be the same container), before
 * `beforeNode`. If `beforeNode` is null, it appends the nodes to the
 * container.
 */
const reparentNodes = (container, start, end = null, before = null) => {
    let node = start;
    while (node !== end) {
        const n = node.nextSibling;
        container.insertBefore(node, before);
        node = n;
    }
};
/**
 * Removes nodes, starting from `startNode` (inclusive) to `endNode`
 * (exclusive), from `container`.
 */
const removeNodes = (container, startNode, endNode = null) => {
    let node = startNode;
    while (node !== endNode) {
        const n = node.nextSibling;
        container.removeChild(node);
        node = n;
    }
};

/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = {};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
/**
 * An expression marker used text-positions, not attribute positions,
 * in template.
 */
const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
const rewritesStyleAttribute = (() => {
    const el = document.createElement('div');
    el.setAttribute('style', '{{bad value}}');
    return el.getAttribute('style') !== '{{bad value}}';
})();
/**
 * An updateable Template that tracks the location of dynamic parts.
 */
class Template {
    constructor(result, element) {
        this.parts = [];
        this.element = element;
        let index = -1;
        let partIndex = 0;
        const nodesToRemove = [];
        const _prepareTemplate = (template) => {
            const content = template.content;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
            // null
            const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                   NodeFilter.SHOW_TEXT */, null, false);
            // The actual previous node, accounting for removals: if a node is removed
            // it will never be the previousNode.
            let previousNode;
            // Used to set previousNode at the top of the loop.
            let currentNode;
            while (walker.nextNode()) {
                index++;
                previousNode = currentNode;
                const node = currentNode = walker.currentNode;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        // Per
                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                        // attributes are not guaranteed to be returned in document order.
                        // In particular, Edge/IE can return them out of order, so we cannot
                        // assume a correspondance between part index and attribute index.
                        let count = 0;
                        for (let i = 0; i < attributes.length; i++) {
                            if (attributes[i].value.indexOf(marker) >= 0) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            // Get the template literal section leading up to the first
                            // expression in this attribute
                            const stringForPart = result.strings[partIndex];
                            // Find the attribute name
                            const name = lastAttributeNameRegex.exec(stringForPart)[2];
                            // Find the corresponding attribute
                            // If the attribute name contains special characters, lower-case
                            // it so that on XML nodes with case-sensitive getAttribute() we
                            // can still find the attribute, which will have been lower-cased
                            // by the parser.
                            //
                            // If the attribute name doesn't contain special character, it's
                            // important to _not_ lower-case it, in case the name is
                            // case-sensitive, like with XML attributes like "viewBox".
                            const attributeLookupName = (rewritesStyleAttribute && name === 'style') ?
                                'style$' :
                                /^[a-zA-Z-]*$/.test(name) ? name : name.toLowerCase();
                            const attributeValue = node.getAttribute(attributeLookupName);
                            const strings = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name, strings });
                            node.removeAttribute(attributeLookupName);
                            partIndex += strings.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        _prepareTemplate(node);
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const nodeValue = node.nodeValue;
                    if (nodeValue.indexOf(marker) < 0) {
                        continue;
                    }
                    const parent = node.parentNode;
                    const strings = nodeValue.split(markerRegex);
                    const lastIndex = strings.length - 1;
                    // We have a part for each match found
                    partIndex += lastIndex;
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        parent.insertBefore((strings[i] === '') ? createMarker() :
                            document.createTextNode(strings[i]), node);
                        this.parts.push({ type: 'node', index: index++ });
                    }
                    parent.insertBefore(strings[lastIndex] === '' ?
                        createMarker() :
                        document.createTextNode(strings[lastIndex]), node);
                    nodesToRemove.push(node);
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                    if (node.nodeValue === marker) {
                        const parent = node.parentNode;
                        // Add a new marker node to be the startNode of the Part if any of
                        // the following are true:
                        //  * We don't have a previousSibling
                        //  * previousSibling is being removed (thus it's not the
                        //    `previousNode`)
                        //  * previousSibling is not a Text node
                        //
                        // TODO(justinfagnani): We should be able to use the previousNode
                        // here as the marker node and reduce the number of extra nodes we
                        // add to a template. See
                        // https://github.com/PolymerLabs/lit-html/issues/147
                        const previousSibling = node.previousSibling;
                        if (previousSibling === null || previousSibling !== previousNode ||
                            previousSibling.nodeType !== Node.TEXT_NODE) {
                            parent.insertBefore(createMarker(), node);
                        }
                        else {
                            index--;
                        }
                        this.parts.push({ type: 'node', index: index++ });
                        nodesToRemove.push(node);
                        // If we don't have a nextSibling add a marker node.
                        // We don't have to check if the next node is going to be removed,
                        // because that node will induce a new marker if so.
                        if (node.nextSibling === null) {
                            parent.insertBefore(createMarker(), node);
                        }
                        else {
                            index--;
                        }
                        currentNode = previousNode;
                        partIndex++;
                    }
                    else {
                        let i = -1;
                        while ((i = node.nodeValue.indexOf(marker, i + 1)) !== -1) {
                            // Comment node has a binding marker inside, make an inactive part
                            // The binding won't work, but subsequent bindings will
                            // TODO (justinfagnani): consider whether it's even worth it to
                            // make bindings in comments work
                            this.parts.push({ type: 'node', index: -1 });
                        }
                    }
                }
            }
        };
        _prepareTemplate(element);
        // Remove text binding nodes after the walk to not disturb the TreeWalker
        for (const n of nodesToRemove) {
            n.parentNode.removeChild(n);
        }
    }
}
const isTemplatePartActive = (part) => part.index !== -1;
// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
const createMarker = () => document.createComment('');
/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#attributes-0
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-character
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */
const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */
class TemplateInstance {
    constructor(template, processor, getTemplate) {
        this._parts = [];
        this.template = template;
        this.processor = processor;
        this._getTemplate = getTemplate;
    }
    update(values) {
        let i = 0;
        for (const part of this._parts) {
            if (part !== undefined) {
                part.setValue(values[i]);
            }
            i++;
        }
        for (const part of this._parts) {
            if (part !== undefined) {
                part.commit();
            }
        }
    }
    _clone() {
        // When using the Custom Elements polyfill, clone the node, rather than
        // importing it, to keep the fragment in the template's document. This
        // leaves the fragment inert so custom elements won't upgrade and
        // potentially modify their contents by creating a polyfilled ShadowRoot
        // while we traverse the tree.
        const fragment = isCEPolyfill ?
            this.template.element.content.cloneNode(true) :
            document.importNode(this.template.element.content, true);
        const parts = this.template.parts;
        let partIndex = 0;
        let nodeIndex = 0;
        const _prepareInstance = (fragment) => {
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
            // null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            let node = walker.nextNode();
            // Loop through all the nodes and parts of a template
            while (partIndex < parts.length && node !== null) {
                const part = parts[partIndex];
                // Consecutive Parts may have the same node index, in the case of
                // multiple bound attributes on an element. So each iteration we either
                // increment the nodeIndex, if we aren't on a node with a part, or the
                // partIndex if we are. By not incrementing the nodeIndex when we find a
                // part, we allow for the next part to be associated with the current
                // node if neccessasry.
                if (!isTemplatePartActive(part)) {
                    this._parts.push(undefined);
                    partIndex++;
                }
                else if (nodeIndex === part.index) {
                    if (part.type === 'node') {
                        const part = this.processor.handleTextExpression(this._getTemplate);
                        part.insertAfterNode(node);
                        this._parts.push(part);
                    }
                    else {
                        this._parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings));
                    }
                    partIndex++;
                }
                else {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        _prepareInstance(node.content);
                    }
                    node = walker.nextNode();
                }
            }
        };
        _prepareInstance(fragment);
        if (isCEPolyfill) {
            document.adoptNode(fragment);
            customElements.upgrade(fragment);
        }
        return fragment;
    }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
class TemplateResult {
    constructor(strings, values, type, processor) {
        this.strings = strings;
        this.values = values;
        this.type = type;
        this.processor = processor;
    }
    /**
     * Returns a string of HTML used to create a <template> element.
     */
    getHTML() {
        const l = this.strings.length - 1;
        let html = '';
        let isTextBinding = true;
        for (let i = 0; i < l; i++) {
            const s = this.strings[i];
            html += s;
            const close = s.lastIndexOf('>');
            // We're in a text position if the previous string closed its last tag, an
            // attribute position if the string opened an unclosed tag, and unchanged
            // if the string had no brackets at all:
            //
            // "...>...": text position. open === -1, close > -1
            // "...<...": attribute position. open > -1
            // "...": no change. open === -1, close === -1
            isTextBinding =
                (close > -1 || isTextBinding) && s.indexOf('<', close + 1) === -1;
            if (!isTextBinding && rewritesStyleAttribute) {
                html = html.replace(lastAttributeNameRegex, (match, p1, p2, p3) => {
                    return (p2 === 'style') ? `${p1}style$${p3}` : match;
                });
            }
            html += isTextBinding ? nodeMarker : marker;
        }
        html += this.strings[l];
        return html;
    }
    getTemplateElement() {
        const template = document.createElement('template');
        template.innerHTML = this.getHTML();
        return template;
    }
}
/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTMl in an <svg> tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the <svg> tag so that
 * clones only container the original fragment.
 */
class SVGTemplateResult extends TemplateResult {
    getHTML() {
        return `<svg>${super.getHTML()}</svg>`;
    }
    getTemplateElement() {
        const template = super.getTemplateElement();
        const content = template.content;
        const svgElement = content.firstChild;
        content.removeChild(svgElement);
        reparentNodes(content, svgElement.firstChild);
        return template;
    }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isPrimitive = (value) => (value === null ||
    !(typeof value === 'object' || typeof value === 'function'));
/**
 * Sets attribute values for AttributeParts, so that the value is only set once
 * even if there are multiple parts for an attribute.
 */
class AttributeCommitter {
    constructor(element, name, strings) {
        this.dirty = true;
        this.element = element;
        this.name = name;
        this.strings = strings;
        this.parts = [];
        for (let i = 0; i < strings.length - 1; i++) {
            this.parts[i] = this._createPart();
        }
    }
    /**
     * Creates a single part. Override this to create a differnt type of part.
     */
    _createPart() {
        return new AttributePart(this);
    }
    _getValue() {
        const strings = this.strings;
        const l = strings.length - 1;
        let text = '';
        for (let i = 0; i < l; i++) {
            text += strings[i];
            const part = this.parts[i];
            if (part !== undefined) {
                const v = part.value;
                if (v != null &&
                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
                    for (const t of v) {
                        text += typeof t === 'string' ? t : String(t);
                    }
                }
                else {
                    text += typeof v === 'string' ? v : String(v);
                }
            }
        }
        text += strings[l];
        return text;
    }
    commit() {
        if (this.dirty) {
            this.dirty = false;
            this.element.setAttribute(this.name, this._getValue());
        }
    }
}
class AttributePart {
    constructor(comitter) {
        this.value = undefined;
        this.committer = comitter;
    }
    setValue(value) {
        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
            this.value = value;
            // If the value is a not a directive, dirty the committer so that it'll
            // call setAttribute. If the value is a directive, it'll dirty the
            // committer if it calls setValue().
            if (!isDirective(value)) {
                this.committer.dirty = true;
            }
        }
    }
    commit() {
        while (isDirective(this.value)) {
            const directive$$1 = this.value;
            this.value = noChange;
            directive$$1(this);
        }
        if (this.value === noChange) {
            return;
        }
        this.committer.commit();
    }
}
class NodePart {
    constructor(templateFactory) {
        this.value = undefined;
        this._pendingValue = undefined;
        this.templateFactory = templateFactory;
    }
    /**
     * Inserts this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendInto(container) {
        this.startNode = container.appendChild(createMarker());
        this.endNode = container.appendChild(createMarker());
    }
    /**
     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
     * its next sibling must be static, unchanging nodes such as those that appear
     * in a literal section of a template.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterNode(ref) {
        this.startNode = ref;
        this.endNode = ref.nextSibling;
    }
    /**
     * Appends this part into a parent part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendIntoPart(part) {
        part._insert(this.startNode = createMarker());
        part._insert(this.endNode = createMarker());
    }
    /**
     * Appends this part after `ref`
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterPart(ref) {
        ref._insert(this.startNode = createMarker());
        this.endNode = ref.endNode;
        ref.endNode = this.startNode;
    }
    setValue(value) {
        this._pendingValue = value;
    }
    commit() {
        while (isDirective(this._pendingValue)) {
            const directive$$1 = this._pendingValue;
            this._pendingValue = noChange;
            directive$$1(this);
        }
        const value = this._pendingValue;
        if (value === noChange) {
            return;
        }
        if (isPrimitive(value)) {
            if (value !== this.value) {
                this._commitText(value);
            }
        }
        else if (value instanceof TemplateResult) {
            this._commitTemplateResult(value);
        }
        else if (value instanceof Node) {
            this._commitNode(value);
        }
        else if (Array.isArray(value) || value[Symbol.iterator]) {
            this._commitIterable(value);
        }
        else if (value.then !== undefined) {
            this._commitPromise(value);
        }
        else {
            // Fallback, will render the string representation
            this._commitText(value);
        }
    }
    _insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    _commitNode(value) {
        if (this.value === value) {
            return;
        }
        this.clear();
        this._insert(value);
        this.value = value;
    }
    _commitText(value) {
        const node = this.startNode.nextSibling;
        value = value == null ? '' : value;
        if (node === this.endNode.previousSibling &&
            node.nodeType === Node.TEXT_NODE) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if this.value is primitive?
            node.textContent = value;
        }
        else {
            this._commitNode(document.createTextNode(typeof value === 'string' ? value : String(value)));
        }
        this.value = value;
    }
    _commitTemplateResult(value) {
        const template = this.templateFactory(value);
        if (this.value && this.value.template === template) {
            this.value.update(value.values);
        }
        else {
            // Make sure we propagate the template processor from the TemplateResult
            // so that we use it's syntax extension, etc. The template factory comes
            // from the render function so that it can control caching.
            const instance = new TemplateInstance(template, value.processor, this.templateFactory);
            const fragment = instance._clone();
            instance.update(value.values);
            this._commitNode(fragment);
            this.value = instance;
        }
    }
    _commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _value is an array, then the previous render was of an
        // iterable and _value will contain the NodeParts from the previous
        // render. If _value is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this.value)) {
            this.value = [];
            this.clear();
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this.value;
        let partIndex = 0;
        let itemPart;
        for (const item of value) {
            // Try to reuse an existing part
            itemPart = itemParts[partIndex];
            // If no existing part, create a new one
            if (itemPart === undefined) {
                itemPart = new NodePart(this.templateFactory);
                itemParts.push(itemPart);
                if (partIndex === 0) {
                    itemPart.appendIntoPart(this);
                }
                else {
                    itemPart.insertAfterPart(itemParts[partIndex - 1]);
                }
            }
            itemPart.setValue(item);
            itemPart.commit();
            partIndex++;
        }
        if (partIndex < itemParts.length) {
            // Truncate the parts array so _value reflects the current state
            itemParts.length = partIndex;
            this.clear(itemPart && itemPart.endNode);
        }
    }
    _commitPromise(value) {
        this.value = value;
        value.then((v) => {
            if (this.value === value) {
                this.setValue(v);
                this.commit();
            }
        });
    }
    clear(startNode = this.startNode) {
        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
    }
}
/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */
class BooleanAttributePart {
    constructor(element, name, strings) {
        this.value = undefined;
        this._pendingValue = undefined;
        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
            throw new Error('Boolean attributes can only contain a single expression');
        }
        this.element = element;
        this.name = name;
        this.strings = strings;
    }
    setValue(value) {
        this._pendingValue = value;
    }
    commit() {
        while (isDirective(this._pendingValue)) {
            const directive$$1 = this._pendingValue;
            this._pendingValue = noChange;
            directive$$1(this);
        }
        if (this._pendingValue === noChange) {
            return;
        }
        const value = !!this._pendingValue;
        if (this.value !== value) {
            if (value) {
                this.element.setAttribute(this.name, '');
            }
            else {
                this.element.removeAttribute(this.name);
            }
        }
        this.value = value;
        this._pendingValue = noChange;
    }
}
/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */
class PropertyCommitter extends AttributeCommitter {
    constructor(element, name, strings) {
        super(element, name, strings);
        this.single =
            (strings.length === 2 && strings[0] === '' && strings[1] === '');
    }
    _createPart() {
        return new PropertyPart(this);
    }
    _getValue() {
        if (this.single) {
            return this.parts[0].value;
        }
        return super._getValue();
    }
    commit() {
        if (this.dirty) {
            this.dirty = false;
            this.element[this.name] = this._getValue();
        }
    }
}
class PropertyPart extends AttributePart {
}
class EventPart {
    constructor(element, eventName) {
        this.value = undefined;
        this._pendingValue = undefined;
        this.element = element;
        this.eventName = eventName;
    }
    setValue(value) {
        this._pendingValue = value;
    }
    commit() {
        while (isDirective(this._pendingValue)) {
            const directive$$1 = this._pendingValue;
            this._pendingValue = noChange;
            directive$$1(this);
        }
        if (this._pendingValue === noChange) {
            return;
        }
        if ((this._pendingValue == null) !== (this.value == null)) {
            if (this._pendingValue == null) {
                this.element.removeEventListener(this.eventName, this);
            }
            else {
                this.element.addEventListener(this.eventName, this);
            }
        }
        this.value = this._pendingValue;
        this._pendingValue = noChange;
    }
    handleEvent(event) {
        if (typeof this.value === 'function') {
            this.value.call(this.element, event);
        }
        else if (typeof this.value.handleEvent === 'function') {
            this.value.handleEvent(event);
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Creates Parts when a template is instantiated.
 */
class DefaultTemplateProcessor {
    /**
     * Create parts for an attribute-position binding, given the event, attribute
     * name, and string literals.
     *
     * @param element The element containing the binding
     * @param name  The attribute name
     * @param strings The string literals. There are always at least two strings,
     *   event for fully-controlled bindings with a single expression.
     */
    handleAttributeExpressions(element, name, strings) {
        const prefix = name[0];
        if (prefix === '.') {
            const comitter = new PropertyCommitter(element, name.slice(1), strings);
            return comitter.parts;
        }
        if (prefix === '@') {
            return [new EventPart(element, name.slice(1))];
        }
        if (prefix === '?') {
            return [new BooleanAttributePart(element, name.slice(1), strings)];
        }
        const comitter = new AttributeCommitter(element, name, strings);
        return comitter.parts;
    }
    /**
     * Create parts for a text-position binding.
     * @param templateFactory
     */
    handleTextExpression(templateFactory) {
        return new NodePart(templateFactory);
    }
}
const defaultTemplateProcessor = new DefaultTemplateProcessor();

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */
function templateFactory(result) {
    let templateCache = templateCaches.get(result.type);
    if (templateCache === undefined) {
        templateCache = new Map();
        templateCaches.set(result.type, templateCache);
    }
    let template = templateCache.get(result.strings);
    if (template === undefined) {
        template = new Template(result, result.getTemplateElement());
        templateCache.set(result.strings, template);
    }
    return template;
}
// The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
const templateCaches = new Map();

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const parts = new WeakMap();
/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result a TemplateResult created by evaluating a template tag like
 *     `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param templateFactory a function to create a Template or retreive one from
 *     cache.
 */
function render(result, container, templateFactory$$1 = templateFactory) {
    let part = parts.get(container);
    if (part === undefined) {
        removeNodes(container, container.firstChild);
        parts.set(container, part = new NodePart(templateFactory$$1));
        part.appendInto(container);
    }
    part.setValue(result);
    part.commit();
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const keyMapCache = new WeakMap();
function cleanMap(part, key, map) {
    if (!part.startNode.parentNode) {
        map.delete(key);
    }
}
function repeat(items, keyFnOrTemplate, template) {
    let keyFn;
    if (arguments.length === 2) {
        template = keyFnOrTemplate;
    }
    else if (arguments.length === 3) {
        keyFn = keyFnOrTemplate;
    }
    return directive((part) => {
        let keyMap = keyMapCache.get(part);
        if (keyMap === undefined) {
            keyMap = new Map();
            keyMapCache.set(part, keyMap);
        }
        const container = part.startNode.parentNode;
        let index = -1;
        let currentMarker = part.startNode.nextSibling;
        for (const item of items) {
            let result;
            let key;
            try {
                ++index;
                result = template(item, index);
                key = keyFn ? keyFn(item) : index;
            }
            catch (e) {
                console.error(e);
                continue;
            }
            // Try to reuse a part
            let itemPart = keyMap.get(key);
            if (itemPart === undefined) {
                // TODO(justinfagnani): We really want to avoid manual marker creation
                // here and instead use something like part.insertBeforePart(). This
                // requires a little refactoring, like iterating through values and
                // existing parts like NodePart#_setIterable does. We can also remove
                // keyMapCache and use part._value instead.
                // But... repeat() is badly in need of rewriting, so we'll do this for
                // now and revisit soon.
                const marker$$1 = createMarker();
                const endNode = createMarker();
                container.insertBefore(marker$$1, currentMarker);
                container.insertBefore(endNode, currentMarker);
                itemPart = new NodePart(part.templateFactory);
                itemPart.insertAfterNode(marker$$1);
                if (key !== undefined) {
                    keyMap.set(key, itemPart);
                }
            }
            else if (currentMarker !== itemPart.startNode) {
                // Existing part in the wrong position
                const end = itemPart.endNode.nextSibling;
                if (currentMarker !== end) {
                    reparentNodes(container, itemPart.startNode, end, currentMarker);
                }
            }
            else {
                // else part is in the correct position already
                currentMarker = itemPart.endNode.nextSibling;
            }
            itemPart.setValue(result);
            itemPart.commit();
        }
        // Cleanup
        if (currentMarker !== part.endNode) {
            removeNodes(container, currentMarker, part.endNode);
            keyMap.forEach(cleanMap);
        }
    });
}

/*
  lit-html directive that removes and attribute if it has a falsy value
*/
function ifTruthy(value) {
  return directive((part) => {
    if (!value && part instanceof AttributePart && !(part instanceof PropertyPart)) {
      if (value !== part.value) {
        const name = part.committer.name;
        part.committer.element.removeAttribute(name);
      }
    }
    else {
      part.setValue(value);
    }
  });
}

var index = {
    html,
    svg,
    render,
    repeat,
    ifTruthy
};

class LitRenderer {

	static render(renderResult, domNode) {
		index.render(renderResult, domNode);
	}
}

const RendererImpl = LitRenderer;

class ControlRenderer {

	static render(control) {
		const placeholder = control._getPlaceholder();
		const templateContext = control._getTemplateContext();
		const renderer = Object.getPrototypeOf(control).constructor.renderer.render;
		const renderResult = renderer(templateContext);

		RendererImpl.render(renderResult, placeholder);
	}

	static storeFocus() {
		let activeElement = document.activeElement;
		while (activeElement.shadowRoot) {
			// drill down the DOM to find the actual focused DOM element
			activeElement = activeElement.shadowRoot.activeElement;
		}
		if (!activeElement.matches(":focus")) {
			ControlRenderer._focusedControl = undefined;
			return;
		}

		ControlRenderer._focusedControl = activeElement;
	}

	static restoreFocus() {
		if (ControlRenderer._focusedControl) {
			ControlRenderer._focusedControl.focus();
		}
	}
}

class RenderQueue {

	constructor() {
		this.list = []; // Used to store the controls in order
		this.lookup = new Set(); // Used for fast checks whether a control is in the list
	}

	add(control) {
		if (this.lookup.has(control)) {
			return;
		}

		this.list.push(control);
		this.lookup.add(control);
	}

	getList() {
		return this.list;
	}

	isAdded(control) {
		return this.lookup.has(control);
	}
}

/* globals performance */

// Tells whether a render task is currently scheduled
let renderTaskId;

// Queue for invalidated controls
let invalidatedControls = new RenderQueue();

let renderTaskPromiseResolve, taskResult;

/**
 * Class that manages the rendering/re-rendering of controls
 * This is always asynchronous
 */
class RenderScheduler {

	constructor() {
		throw new Error("Static class");
	}

	/**
	 * Queues a control for re-rendering
	 * @param control
	 */
	static addToQueue(control) {
		// Enqueue the control
		invalidatedControls.add(control);

		// Schedule a rendering task
		RenderScheduler.scheduleRenderTask();
	}

	/**
	 * Schedules a rendering task, if not scheduled already
	 */
	static scheduleRenderTask() {
		if (!renderTaskId) {
			//renderTaskId = window.setTimeout(RenderScheduler.renderControls, 0); // Task
			//renderTaskId = Promise.resolve().then(RenderScheduler.renderControls); // Micro task
			renderTaskId = window.requestAnimationFrame(RenderScheduler.renderControls); // AF
		}
	}

	static renderControls() {
		const controlsToUpdate = invalidatedControls;

		invalidatedControls = new RenderQueue();
		renderTaskId = undefined;

		ControlRenderer.storeFocus();

		controlsToUpdate.getList().forEach(control => {
			control._render();
		});

		ControlRenderer.restoreFocus();
	}

	/**
	 * return a promise that will be resolved once all invalidated controls are rendered
	 */
	static whenDOMUpdated() {
		return new Promise(resolve => {
			setTimeout(_ => {
				if (invalidatedControls.getList().length === 0) {
					resolve();
				}

				renderTaskPromiseResolve = resolve;
			});
		});

	}

	/**
	 * return a promise that will be resolved once all ui5 webcomponents on the page have their shadow root ready
	 */
	static whenShadowDOMReady() {
		// TODO: track promises internally, the dom traversal is a POC only
		const ui5Components = Array.from(document.querySelectorAll('*')).filter(_ => _._shadowRootReadyPromise);
		return Promise.all(ui5Components.map(comp => comp._shadowRootReadyPromise))
			.then(_ => Promise.resolve());	// qunit has a boolean cheack for the promise value and the array from the Promise all is considered truthy
	}

	static whenFinished() {
		return Promise.all([RenderScheduler.whenDOMUpdated(), RenderScheduler.whenShadowDOMReady()])
			.then(_ => Promise.resolve());
	}

	static _resolveTaskPromise() {
		if (invalidatedControls.getList().length > 0) {
			// More updates are pending. Resolve will be called again
			return;
		}

		if (renderTaskPromiseResolve) {
			renderTaskPromiseResolve.call(this, taskResult);
			renderTaskPromiseResolve = undefined;
		}
	}
}

const _convertClasses = (classes, customStyleClasses) => {
	for (let i in classes) {
		let customStyleClassesToAdd = i === "main" ? customStyleClasses : undefined;
		classes[i] = _convertSingleClass(classes[i], customStyleClassesToAdd);
	}

	return classes;
};

const _convertSingleClass = (oClass, customStyleClasses) => {
	// Push all custom classes first, if any
	if (Array.isArray(customStyleClasses)) {
		customStyleClasses.forEach(function (sClassName) {
			oClass[sClassName] = true;
		});
	}

	return Object.keys(oClass).filter(function (className) {
		return oClass[className];
	}).join(" ");
};

const _convertStyles = function (styles) {

	if (!styles) {
		return;
	}

	for (let i in styles) {
		let stylesNs = styles[i];

		let result = [];
		Object.keys(stylesNs).forEach(function (key) {
			if (stylesNs[key]) {
				result.push(key + ": " + stylesNs[key]);
			}
		});
		styles[i] = result.length ? result.join("; ") : undefined;
	}

	return styles;
};

class TemplateContext {

	// calculate control template context
	static calculate (control) {
		const templateContextMethod = control.constructor.calculateTemplateContext;
		const templateContext = templateContextMethod(control._state);
		if (!templateContext.hasOwnProperty('ariaHidden')) {
			templateContext.ariaHidden = control._state.hidden ? "true" : undefined;
		}

		templateContext.classes = _convertClasses(templateContext.classes, control._customClasses);
		templateContext.styles = _convertStyles(templateContext.styles);

		return templateContext;
	}

}

class State {
	constructor(stateChangedCallback, propertyChangedCallback, id) {
		this._stateChangedCallback = stateChangedCallback;
		this._propertyChangedCallback = propertyChangedCallback;

		this._data = Object.assign({}, this.constructor._defaultState);
		this._data._id = id;
	}

	static generateAccessors(MetadataClass) {
		const proto = this.prototype;

		State.generateDefaultState(MetadataClass);

		const controlProperties = MetadataClass.getProperties();

		Object.defineProperty(proto, "_id", {
			get: function () {
				return this._data._id;
			},

			set: function () {
				throw new Error("_id should not be set by the control developer");
			}
		});

		for (const [prop, propData] of Object.entries(controlProperties)) {
			Object.defineProperty(proto, prop, {
				get: function () {
					if (typeof this._data[prop] !== 'undefined') {
						return this._data[prop];
					}
					if (propData.type === 'boolean') {
						return false;
					} else if (propData.multiple) {
						return [];
					} else {
						return propData.defaultValue;
					}
				},
				set: function (value) {
					value = MetadataClass.constructor.validatePropertyValue(value, propData);
					if (this._data[prop] === value) {
						return;
					}
					const oldState = this._data[prop];

					if (oldState !== value) {
						this._data[prop] = value;
						this._stateChangedCallback();
						this._propertyChangedCallback(prop, value);
					}
				}
			});
		}

		const slots = MetadataClass.getSlots();
		for (const [slot, slotData] of Object.entries(slots)) {
			Object.defineProperty(proto, slot, {
				get: function () {
					if (typeof this._data[slot] !== 'undefined') {
						return this._data[slot];
					}
					if (slotData.multiple) {
						return [];
					}
					return null;
				},
				set: function (value) {
					value = MetadataClass.constructor.validateSlotValue(value, slotData);
					if (this._data[slot] === value) {
						return;
					}

					const oldState = this._data[slot];

					if (oldState !== value) {
						this._data[slot] = value;
						this._stateChangedCallback();
					}
				}
			});
		}

		Object.defineProperty(proto, "_nodeText", {
			get: function () {
				return this._data["_nodeText"];
			},
			set: function (value) {
				this._data["_nodeText"] = value;
				this._stateChangedCallback();
			}
		});
	}

	static generateDefaultState(MetadataClass) {

		let defaultState = {};

		// Initialize properties
		let props = MetadataClass.getProperties();
		for (const propName in props) {
			if (props[propName].type === "boolean") {
				defaultState[propName] = false;
			} else if (props[propName].multiple) {
				defaultState[propName] = [];
			} else if (props[propName].type === Object) {
				defaultState[propName] = "defaultValue" in props[propName] ? props[propName].defaultValue : {};
			} else {
				defaultState[propName] = props[propName].defaultValue;
			}
		}

		// Initialize slots
		let slots = MetadataClass.getSlots();
		for (const slotName in slots) {
			if (slots[slotName].multiple) {
				defaultState[slotName] = [];
			} else {
				defaultState[slotName] = null;
			}
		}

		this._defaultState = defaultState;
	}
}

let coreConfig;

const metadata$1 = {
	properties: {
		/**
		 * CSS classes that will be applied to the top-level element of the control
		 */
		_customClasses: {
			type: String,
			multiple: true
		},

		/**
		 * Attributes (most commonly accessibility-related) that will be passed to the control.
		 * The control has the responsibility to render these attributes
		 */
		_customAttributes: {
			type: Object
		}
	},
	events: {
		_propertyChange: {}
	}
};

const DefinitionsSet = new Set();
const IDMap = new Map();

class WebComponent extends HTMLElement {
	constructor() {
		super();
		this._generateId();
		this._createShadowRoot();
		this.initState();
		this._upgradeAllProperties();
		this._initializeShadowRoot();
	}

	_generateId() {
		this._id = this.constructor._nextID();
	}

	_createShadowRoot() {
		this._shadowRootReadyPromise = new Promise((resolve, reject) => {
			this._shadowRootReadyPromiseResolver = resolve;
		});
		if (this.constructor.getMetadata().getNoShadowDOM()) {
			return;
		}
		if (!this.shadowRoot) {
			this.attachShadow({ mode: 'open' });
		}
	}

	_initializeShadowRoot() {
		if (this.constructor.getMetadata().getNoShadowDOM()) {
			this._shadowRootReadyPromiseResolver();
			return;
		}
		return ShadowDOM.prepareShadowDOM(this.constructor).then(shadowDOM => {
			this.shadowRoot.appendChild(shadowDOM);
			this._shadowRootReadyPromiseResolver();
		});
	}
	connectedCallback() {
		if (this.constructor.getMetadata().getNoShadowDOM()) {
			return;
		}
		if (this.constructor.getMetadata().isLazy()) {
			return;
		}
		this.connectInternalControl();
	}
	connectInternalControl() {
		if (!this._controlConnectedPromise) {
			this._controlConnectedPromise = new Promise((resolve, reject) => {
				this.renderInternalControl().then(_ => {
					this._startObservingDOMChildren();
					if (typeof this.onEnterDOM === 'function') {
						this.onEnterDOM();
					}
					resolve();
				});
			});
		}
		return this._controlConnectedPromise;
	}
	renderInternalControl() {
		if (!this._controlRenderedPromise) {
			this._controlRenderedPromise = new Promise((resolve, reject) => {
				this._whenShadowRootReady().then(_ => {
					this._processChildren();
					this._render();
					resolve();
				});
			});
		}
		return this._controlRenderedPromise;
	}
	_whenShadowRootReady() {
		return this._shadowRootReadyPromise;
	}
	adoptedCallback() {
	}
	disconnectedCallback() {
		if (this.constructor.getMetadata().getNoShadowDOM()) {
			return;
		}
		this._controlConnectedPromise = null;
		this._stopObservingDOMChildren();
		if (typeof this.onExitDOM === 'function') {
			this.onExitDOM();
		}
	}
	_startObservingDOMChildren() {
		const shouldObserveChildren = this.constructor.shouldObserveChildren();
		const shouldObserveText = this.constructor.shouldObserveTextContent();
		if (!shouldObserveChildren && !shouldObserveText) {
			return;
		}
		let mutationObserverOptions = {
			childList: true,
			subtree: shouldObserveText,
			characterData: shouldObserveText
		};
		DOMObserver.observeDOMNode(this, this._processChildren.bind(this), mutationObserverOptions);
	}
	_stopObservingDOMChildren() {
		DOMObserver.unobserveDOMNode(this);
	}
	onChildrenChanged(mutations) {
	}
	_processChildren(mutations) {
		const usesNodeText = this.constructor.getMetadata().usesNodeText();
		const hasChildren = this.constructor.getMetadata().hasSlots();
		if (usesNodeText) {
			this._updateNodeText();
		} else if (hasChildren) {
			this._updateSlots();
		}
		this.onChildrenChanged(mutations);
	}
	_updateNodeText() {
		this._state._nodeText = this.textContent;
	}
	_updateSlots() {
		const domChildren = Array.from(this.children);

		const slotsMap = this.constructor.getMetadata().getSlots();
		for (let [prop, propData] of Object.entries(slotsMap)) {
			if (propData.multiple) {
				this._state[prop] = [];
			} else {
				this._state[prop] = null;
			}
		}
		const autoIncrementMap = new Map();
		domChildren.forEach(child => {
			const slot = child.getAttribute('data-ui5-slot') || this.constructor.getMetadata().getDefaultSlot();
			if (slotsMap[slot] === 'undefined') {
				return;
			}
			let slotName;
			if (slotsMap[slot].multiple) {
				const nextId = (autoIncrementMap.get(slot) || 0) + 1;
				slotName = slot + '-' + nextId;
				autoIncrementMap.set(slot, nextId);
			} else {
				slotName = slot;
			}
			child._slot = slotName;
			if (slotsMap[slot].multiple) {
				this._updateSlot(slot, [...this._state[slot], child]);
			} else {
				this._updateSlot(slot, child);
			}
			child.setAttribute('slot', slotName);
		});
	}

	_updateSlot(slot, value) {
		this._state[slot] = value;
	}

	static shouldObserveChildren() {
		return this.getMetadata().hasSlots();
	}
	static shouldObserveTextContent() {
		return !!this.getMetadata().usesNodeText();
	}
	static get observedAttributes() {
		const observedProps = this.getMetadata().getObservedProps();
		let enhancedObservedProps;
		if (!coreConfig) {
			coreConfig = Core$1.getConfiguration();

		}

		const noConflict = coreConfig.getWCNoConflict();
		if (noConflict === false) {
			enhancedObservedProps = observedProps;
		} else {
			enhancedObservedProps = [];
			observedProps.forEach(prop => {
				enhancedObservedProps.push(prop);
				if (noConflict === true || Array.isArray(noConflict) && noConflict.indexOf(prop) !== -1) {
					enhancedObservedProps.push(`ui5-${ prop }`);
				}
			});
		}
		const observedAttributes = enhancedObservedProps.map(prop => camelToKebabCase(prop));
		return observedAttributes;
	}
	attributeChangedCallback(name, oldValue, newValue) {
		const properties = this.constructor.getMetadata().getProperties();
		const realName = name.replace(/^ui5-/, '');
		const nameInCamelCase = kebabToCamelCase(realName);
		if (properties.hasOwnProperty(nameInCamelCase)) {
			const propertyTypeClass = properties[nameInCamelCase].type;
			if (propertyTypeClass === Boolean) {
				newValue = newValue !== null;
			}
			if (propertyTypeClass === Integer) {
				newValue = parseInt(newValue, 10);
			}
			this[nameInCamelCase] = newValue;
		}
	}
	_updateAttribute(name, newValue) {
		const publicChildren = this.constructor.getMetadata().getSlots();
		if (publicChildren[name] || WebComponentMetadata.isPrivateProperty(name)) {
			return;
		}

		if (typeof newValue === 'object') {
			return;
		}

		const attrName = camelToKebabCase(name);
		const attrValue = this.getAttribute(attrName);
		if (typeof newValue === 'boolean') {
			if (newValue === true && attrValue === null) {
				this.setAttribute(attrName, '');
			} else if (newValue === false && attrValue !== null) {
				this.removeAttribute(attrName);
			}
		} else {
			if (attrValue !== newValue) {
				this.setAttribute(attrName, newValue);
			}
		}
	}
	_upgradeProperty(prop) {
		if (this.hasOwnProperty(prop)) {
			const value = this[prop];
			delete this[prop];
			this[prop] = value;
		}
	}
	_upgradeAllProperties() {
		const observedProps = this.constructor.getMetadata().getObservedProps();
		observedProps.forEach(prop => {
			this._upgradeProperty(prop);
		});
	}

	static define() {
		const tag = this.getMetadata().getTag();

		if (!DefinitionsSet.has(tag)) {
			DefinitionsSet.add(tag);
			this.generateAccessors();
			window.customElements.define(tag, this);
		}
		return this;
	}
	static getMetadata() {
		if (!this._metadata) {
			this._metadata = new WebComponentMetadata(this.metadata);
		}
		return this._metadata;
	}

	static get metadata() {
		return metadata$1;
	}


	initState() {
		const StateClass = this.constructor.StateClass;
		this._state = new StateClass(
			this._invalidate.bind(this),
			this._propertyChange.bind(this),
			this._id
		);

		this._delegates = [];

		this._monitoredChildProps = new Map();
	}

	static get StateClass() {
		if (!this.hasOwnProperty("_StateClass")) {
			this._StateClass = class extends State {};
			this._StateClass.generateAccessors(this.getMetadata());
		}

		return this._StateClass;
	}

	static getMetadata() {

		let klass = this;

		if (klass.hasOwnProperty("_metadata")) {
			return klass._metadata;
		}

		let metadatas = [Object.assign(klass.metadata, {})];
		while (klass !== WebComponent) {
			klass = Object.getPrototypeOf(klass);
			metadatas.push(klass.metadata);
		}

		const result = metadatas[0];

		// merge properties
		const mergedProperties = metadatas.reverse().reduce((result, current) => {
			Object.assign(result, current.properties);
			return result;
		}, {});

		result.properties = mergedProperties;

		// merge slots
		const mergedSlots = metadatas.reverse().reduce((result, current) => {
			Object.assign(result, current.slots);
			return result;
		}, {});

		result.slots = mergedSlots;

		// merge events
		const mergedEvents = metadatas.reverse().reduce((result, current) => {
			Object.assign(result, current.events);
			return result;
		}, {});

		result.events = mergedEvents;

		this._metadata = new WebComponentMetadata(result);
		return this._metadata;
	}

	static calculateTemplateContext(state) {
		return {
			ctr: state
		};
	}

	_attachChildPropertyUpdated(child, propData) {
		const listenFor = propData.listenFor,
			childMetadata = child.constructor.getMetadata(),
			childType = undefined, //todo Adi FIX ME, type is no longer in metadata (was getType() which was always undefined)
			childProperties = childMetadata.getProperties();

		let observedProps = [],
			notObservedProps = [];

		if (!listenFor) {
			return;
		}

		if (Array.isArray(listenFor)) {
			observedProps = listenFor;
		} else {
			observedProps = Array.isArray(listenFor.props) ? listenFor.props : Object.keys(childProperties);
			notObservedProps = Array.isArray(listenFor.exclude) ? listenFor.exclude : [];
		}

		if (!this._monitoredChildProps.has(childType)) {
			this._monitoredChildProps.set(childType, { observedProps, notObservedProps });
		}

		child.addEventListener("_propertyChange", this._onChildPropertyUpdated);
	}

	_detachChildPropertyUpdated(child) {
		child.removeEventListener("_propertyChange", this._onChildPropertyUpdated);
	}

	_onChildPropertyUpdated(prop) {
		if (!this._parent) {
			return;
		}

		const { observedProps, notObservedProps } = this._parent._monitoredChildProps.get(undefined);

		if (observedProps.includes(prop.detail.name) && !notObservedProps.includes(prop.detail.name)) {
			this._parent._invalidate();
		}
	}

	/**
	 * Asynchronously re-renders an already rendered control
	 * @private
	 */
	_invalidate() {
		if (this.getDomRef() && !this._suppressInvalidation) {
			RenderScheduler.addToQueue(this);
		}
	}

	_render() {
		// onBeforeRendering
		if (typeof this.onBeforeRendering === "function") {
			this._suppressInvalidation = true;
			this.onBeforeRendering();
			delete this._suppressInvalidation;
		}

		// render
		ControlRenderer.render(this);

		// onAfterRendering
		if (typeof this.onAfterRendering === "function") {
			this.onAfterRendering();
		}

		RenderScheduler._resolveTaskPromise();
	}

	_getTemplateContext() {
		return TemplateContext.calculate(this);
	}

	getDomRef() {
		if (!this.shadowRoot || this.shadowRoot.children.length === 0) {
			return;
		}

		return this._getPlaceholder().children[0];
	}

	_getPlaceholder() {
		return this.shadowRoot.querySelector("[data-sap-ui-wc-placeholder]");
	}

	getFocusDomRef() {
		let domRef = this.getDomRef();
		if (domRef) {
			let focusRef = domRef.querySelector("[data-sap-focus-ref]");
			return focusRef || domRef;
		}
	}

	focus() {
		let focusDomRef = this.getFocusDomRef();
		if (focusDomRef) {
			focusDomRef.focus();
		}
	}

	/**
	 * Calls the event handler on the control for a native event or a pseudo event
	 *
	 * @param event The event object
	 * @param pseudoEventType For pseudo events, use this type to construct the name of the handler
	 * @private
	 */
	_handleEvent(event, pseudoEventType) {
		const sHandlerName = "on" + (pseudoEventType || event.type);

		this._delegates.forEach(delegate => {
			if (delegate[sHandlerName]) {
				delegate[sHandlerName](event);
			}
		});

		if (this[sHandlerName]) {
			this[sHandlerName](event);
		}
	}

	_propertyChange(name, value) {
		this._updateAttribute(name, value);

		let customEvent = new CustomEvent("_propertyChange", {
			detail: { name: name, newValue: value },
			composed: false,
			bubbles: true
		});

		this.dispatchEvent(customEvent);
	}

	fireEvent(name, data, cancelable) {
		let customEvent = new CustomEvent(name, {
			detail: data,
			composed: false,
			bubbles: true,
			cancelable: cancelable
		});

		return this.dispatchEvent(customEvent);
	}

	/**
	 * Used to generate the next auto-increment id for the current class
	 * Note: do not call Control._nextID (static) but rather this.constructor._nextID (polymorphic)
	 * @returns {string}
	 * @private
	 */
	static _nextID() {
		const className = "el";
		const lastNumber = IDMap.get(className);
		const nextNumber = lastNumber !== undefined ? lastNumber + 1 : 1;
		IDMap.set(className, nextNumber);
		return `__${className}${nextNumber}`;
	}

	static generateAccessors() {
		const proto = this.prototype;

		// Properties
		const properties = this.getMetadata().getProperties();
		for (const [prop, propData] of Object.entries(properties)) {

			if (nameCollidesWithNative(prop)) {
				throw new Error(`"${prop}" is not a valid property name. Use a name that does not collide with DOM APIs`);
			}

			if (propData.type === "boolean" && propData.defaultValue) {
				throw new Error(`Cannot set a default value for property "${prop}". All booleans are false by default.`);
			}

			Object.defineProperty(proto, prop, {
				get: function () {
					return this._state[prop];
				},
				set: function (value) {
					this._state[prop] = value;
				}
			});
		}

		// Slots
		const slots = this.getMetadata().getSlots();
		for (const [slot, slotData] of Object.entries(slots)) {

			if (nameCollidesWithNative(slot)) {
				throw new Error(`"${prop}" is not a valid property name. Use a name that does not collide with DOM APIs`);
			}

			Object.defineProperty(proto, slot, {
				get: function () {
					return this._state[slot];
				},
				set: function (value) {
					throw new Error("Cannot set slots directly, use the DOM APIs");
				}
			});
		}

		// Node Text
		Object.defineProperty(proto, "_nodeText", {
			get: function () {
				return this._state._nodeText;
			},
			set: function (value) {
				throw new Error("Cannot set node text directly, use the DOM APIs");
			}
		});
	}
}
const kebabToCamelCase = string => toCamelCase(string.split('-'));
const camelToKebabCase = string => string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
const toCamelCase = parts => {
	return parts.map((string, index) => {
		return index === 0 ? string.toLowerCase() : string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	}).join('');
};
const nameCollidesWithNative = name => {
	if (name === 'disabled') {
		return false;
	}
	const classes = [
		HTMLElement,
		Element,
		Node
	];
	return classes.some(klass => klass.prototype.hasOwnProperty(name));
};

const html$1 = index.html;

const ButtonLitRenderer = {};

const block0 = (context) => { return html$1`<button 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
		class="${index.ifTruthy(context.classes.main)}"
		style="${index.ifTruthy(context.styles.main)}"
		disabled="${index.ifTruthy(context.ctr.disabled)}"
		aria-disabled="${index.ifTruthy(context.ariaDisabled)}"
		title="${index.ifTruthy(context.ctr.tooltip)}"
		tabindex="${index.ifTruthy(context.tabindex)}"
		
	>
		${ context.ctr._iconSettings ? block1(context) : undefined }${ context.ctr._nodeText ? block2(context) : undefined }</button>

`; };
const block1 = (context) => { return html$1`<ui5-icon
				class="${index.ifTruthy(context.classes.icon)}"
				src="${index.ifTruthy(context.ctr._iconSettings.src)}"
			></ui5-icon>
		`; };
const block2 = (context) => { return html$1`<span id="${index.ifTruthy(context.ctr._id)}-content" dir="${index.ifTruthy(context.dir)}" class="${index.ifTruthy(context.classes.text)}"><bdi>${index.ifTruthy(context.ctr._nodeText)}</bdi></span>
		`; };
const renderMe = block0;

ButtonLitRenderer.render = renderMe;

/**
 * Different types of Button.
 */
const ButtonTypes = {
	/**
	 * default type (no special styling)
	 */
	Default: "Default",

	/**
	 * accept type (green button)
	 */
	Accept: "Accept",

	/**
	 * reject style (red button)
	 */
	Reject: "Reject",

	/**
	 * transparent type
	 */
	Transparent: "Transparent",

	/**
	 * ghost type
	 */
	Ghost: "Ghost",

	/**
	 * emphasized type
	 */
	Emphasized: "Emphasized"
};

class ButtonType extends DataType {
	static isValid(value) {
		return !!ButtonTypes[value];
	}
}

ButtonType.generataTypeAcessors(ButtonTypes);

const TextDirections = {
	/**
	 * Specifies left-to-right text direction.
	 * @public
	 */
	LTR: "LTR",

	/**
	 * Specifies right-to-left text direction.
	 * @public
	 */
	RTL: "RTL",

	/**
	 * Inherits the direction from its parent control/container.
	 * @public
	 */
	Inherit: "Inherit"
};

class TextDirection extends DataType {
	static isValid(value) {
		return !!TextDirections[value];
	}
}

TextDirection.generataTypeAcessors(TextDirections);

class ButtonTemplateContext {

	static calculate(state) {

		return  {
			ctr: state,
			dir: state.textDirection !== TextDirection.Inherit ? state.textDirection : "",
			tabindex: state._customAttributes["tabindex"],
			classes: {
				main: ButtonTemplateContext.getMainClasses(state),
				icon: ButtonTemplateContext.getIconClasses(state),
				text: {
					"sapMBtnText": true
				}
			},
			styles: {
			},
			iconSrc: state._active ? state.activeIcon : state.icon,
			ariaDisabled: state.disabled ? "true" : undefined
		};
	}

	static getMainClasses(state) {
		return {
			"sapMBtn": true,
			"sapMBtnActive": state._active,
			"sapMBtnWithIcon": state.icon,
			"sapMBtnNoText": !state._nodeText,
			"sapMBtnDisabled": state.disabled,
			"sapMBtnIconLast": state.iconLast,
			["sapMBtn" + state.type]: true
		};
	}

	static getIconClasses() {
		return {
			"sapWCIconInButton": true
		};
	}
}

class URI$1 extends DataType {

	static isValid(value) {
		// TODO: recheck
		return /^((([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?)$/.test(value);
	}
}

var belize = "";

ShadowDOM.registerStyle("sap_belize", "Button.css", belize);

const metadata$2 = {
	tag: "ui5-button",
	styleUrl: [
		"Button.css"
	],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.Button.prototype */ {
		/**
		 * Defines the <code>Button</code> type.
		 */
		type: {type: ButtonType, defaultValue: ButtonType.Default},

		/**
		 * Determines whether the <code>Button</code> is enabled (default is set to <code>true</code>).
		 * A disabled <code>Button</code> has different colors depending on the {@link sap.m.ButtonType ButtonType}.
		 */
		disabled: {type: Boolean},

		/**
		 * Defines the icon to be displayed as graphical element within the <code>Button</code>.
		 * It can be an image or an icon from the icon font.
		 */
		icon: {type: URI$1, defaultValue: null},

		/**
		 * Determines whether the icon is displayed after the text.
		 * @type {boolean}
		 * @defaultvalue false
		 * @public
		 */
		iconLast: {type: Boolean},

		/**
		 * The source property of an alternative icon for the active (depressed) state of the button.
		 * Both active and default icon properties should be defined and have the same type: image or icon font.
		 * If the <code>icon</code> property is not set or has a different type, the active icon is not displayed.
		 */
		activeIcon: {type: URI$1, defaultValue: null},

		/**
		 * This property specifies the element's text directionality with enumerated options. By default, the control inherits text direction from the DOM.
		 */
		textDirection: {type: TextDirection, defaultValue: TextDirection.Inherit},

		/**
		 * Used to switch the active state (pressed or not) of the button
		 */
		_active: {type: Boolean},

		_iconSettings: { type: Object }
	},
	slots: {},
	events: /** @lends  sap.ui.webcomponents.main.Button.prototype */ {
		/**
		 * press event
		 * @event
		 * @public
		 */
		press: {}
	}
};

/**
 * @class
 *
 * It can be used for button.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Button
 * @extends sap.ui.webcomponents.base.WebComponent
 * @customtag ui5-button
 * @public
 */
class Button$1 extends WebComponent {

	static get metadata() {
		return metadata$2;
	}

	static get renderer() {
		return ButtonLitRenderer;
	}

	static get calculateTemplateContext() {
		return ButtonTemplateContext.calculate;
	}

	constructor() {
		super();
	}

	onBeforeRendering() {
		if (this.icon) {
			this._iconSettings = {
				src: this._active && this.activeIcon ? this.activeIcon : this.icon
			};
		} else {
			this._iconSettings = null;
		}
	}

	ontap(_event) {
		if (!this.disabled) {
			this.fireEvent("press", {});
		}
	}

	ondown(_event) {
		if (this.activeIcon) {
			this._active = true;
		}
	}

	onup(_event) {
		if (this.activeIcon) {
			this._active = false;
		}
	}

	onkeydown(event) {
		if (event.which === mKeyCodes.SPACE || event.which === mKeyCodes.ENTER) {
			this._active = true;
		}
	}

	onkeyup(event) {
		if (event.which === mKeyCodes.SPACE || event.which === mKeyCodes.ENTER) {
			this._active = false;
		}
	}

	onfocusout(_event) {
			this._active = false;
	}
}

Core$1.boot().then(_ => {
	Button$1.define();
});

class CSSSize extends DataType {
	static isValid(value) {
		return /^(auto|inherit|[-+]?(0*|([0-9]+|[0-9]*\.[0-9]+)([rR][eE][mM]|[eE][mM]|[eE][xX]|[pP][xX]|[cC][mM]|[mM][mM]|[iI][nN]|[pP][tT]|[pP][cC]|%))|calc\(\s*(\(\s*)*[-+]?(([0-9]+|[0-9]*\.[0-9]+)([rR][eE][mM]|[eE][mM]|[eE][xX]|[pP][xX]|[cC][mM]|[mM][mM]|[iI][nN]|[pP][tT]|[pP][cC]|%)?)(\s*(\)\s*)*(\s[-+]\s|[*\/])\s*(\(\s*)*([-+]?(([0-9]+|[0-9]*\.[0-9]+)([rR][eE][mM]|[eE][mM]|[eE][xX]|[pP][xX]|[cC][mM]|[mM][mM]|[iI][nN]|[pP][tT]|[pP][cC]|%)?)))*\s*(\)\s*)*\))$/.test(value);
	}
}

/**
 * Different states.
 */
const ValueStates = {
	None: "None",
	Success: "Success",
	Warning: "Warning",
	Error: "Error"
};

class ValueState extends DataType {
	static isValid(value) {
		return !!ValueStates[value];
	}
}

ValueState.generataTypeAcessors(ValueStates);

const html$2 = index.html;

const CheckBoxLitRenderer = {};

const block0$1 = (context) => { return html$2`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
	class="${index.ifTruthy(context.classes.main)}"
	style="${index.ifTruthy(context.styles.main)}"
	role="checkbox"
	aria-checked="${index.ifTruthy(context.ctr.selected)}"
	aria-readonly="${index.ifTruthy(context.ariaReadonly)}"
	tabindex="${index.ifTruthy(context.tabIndex)}"
	title="${index.ifTruthy(context.tooltip)}"><div id="${index.ifTruthy(context.ctr._id)}-CbBg" class="${index.ifTruthy(context.classes.inner)}"><input id="${index.ifTruthy(context.ctr._id)}-CB" type='checkbox' ?checked="${index.ifTruthy(context.ctr.selected)}" name="${index.ifTruthy(context.ctr.name)}" ?readonly="${index.ifTruthy(context.ctr.readOnly)}" data-sap-no-tab-ref/></div>

		${ context.ctr._label ? block1$1(context) : undefined }</div>`; };
const block1$1 = (context) => { return html$2`<ui5-label
				class="labelInCheckbox"
				wrap="${index.ifTruthy(context.ctr._label.wrap)}"
				text-direction="${index.ifTruthy(context.ctr._label.textDirection)}"
		>${index.ifTruthy(context.ctr._label.text)}</ui5-label>
		`; };
const renderMe$1 = block0$1;

CheckBoxLitRenderer.render = renderMe$1;

const _getTextMap = () => {
	const ResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.core");

	let ValueStateText = new Map();
	ValueStateText.set(ValueState.Error, ResourceBundle.getText("VALUE_STATE_ERROR"));
	ValueStateText.set(ValueState.Warning, ResourceBundle.getText("VALUE_STATE_WARNING"));
	ValueStateText.set(ValueState.Success, ResourceBundle.getText("VALUE_STATE_SUCCESS"));

	return ValueStateText;
};

class ValueStateSupport {

	static getTextForValueState(valueState) {
		if (!this.textMap) {
			this.textMap = _getTextMap();
		}

		return this.textMap.get(valueState);
	}

	/*
	* Appends a generic success, warning or error message to the given tooltip text if the given Element
	* has a property "valueState" with one of these three states.
	*/
	static getEnrichedTooltip(tooltip, valueState) {
		if (valueState === ValueState.None) {
			return tooltip;
		}

		let additionalTooltip = ValueStateSupport.getTextForValueState(valueState);

		if (additionalTooltip) {
			return (tooltip ? tooltip + " - " : "") + additionalTooltip;
		}

		return tooltip;
	}
}

class CheckBoxTemplateContext {

	static calculate(state) {
		let mainClasses = CheckBoxTemplateContext.getMainClasses(state);
		let innerClasses = CheckBoxTemplateContext.getInnerClasses(state);
		let tooltip = ValueStateSupport.getEnrichedTooltip(state.tooltip, state.valueState);

		let context = {
			tooltip: tooltip,
			ctr: state,
			readOnly: !state.disabled && state.displayOnly,// TODO: should check if this is correct (the readOnly property is not taken into account)
			tabIndex: state.disabled || state.displayOnly ? undefined : "0",
			classes: { main: mainClasses, inner: innerClasses},
			styles: {
				main: {"width": state.width}
			}
		};

		context["ariaReadonly"] = context.readOnly ? "true" : undefined;

		return context;
	}

	static getMainClasses(state) {
		return {
			"sapMCb": true,
			"sapMCbHasLabel": !!state.text,
			"sapMCbBgDis": state.disabled,
			"sapMCbRo": state.readOnly,
			"sapMCbErr": state.valueState === "Error",
			"sapMCbWarn": state.valueState === "Warning",
			"sapMCbWrapped": state.wrap,
			"sapMCbDisplayOnly": state.displayOnly && !state.disabled
		};
	}

	static getInnerClasses(state) {
		let hoverable = !state.disabled && !state.displayOnly && !state.readOnly &&  Device.system.desktop;

		return {
			"sapMCbBg": true,
			"sapMCbHoverable": hoverable,
			"sapMCbMark": true,
			"sapMCbMarkChecked": !!state.selected
		};
	}
}

/**
 * @public
 */
const metadata$3 = {
	tag: "ui5-checkbox",
	styleUrl: ['CheckBox.css'],
	properties: /** @lends sap.ui.webcomponents.main.CheckBox.prototype */ {

		/**
		 * Defines if the <code> <code>CheckBox</code></code> is disabled.
		 * @type {boolean}
		 * @public
		 */
		disabled: {
			"type": Boolean
		},

		/**
		 * Defines the displayOnly state of the <code>CheckBox</code>.
		 * Takes effect when the <code>CheckBox</code> is not disabled.
		 * @type {boolean}
		 * @public
		 */
		displayOnly: {
			"type": Boolean
		},

		/**
		 * Defines the name of <code>CheckBox</code> input element.
		 * @type {string}
		 * @public
		 */
		name: {
			"defaultValue": "",
			"type": String
		},

		/**
		 * Defines if the <code>CheckBox</code> is read only, e.g. editable or not.
		 * @type {boolean}
		 * @public
		 */
		readOnly: {
			"type": Boolean
		},

		/**
		 * Defines if the <code>CheckBox</code> is checked or not checked.
		 * @type {boolean}
		 * @public
		 */
		selected: {
			"type": Boolean
		},

		/**
		 * Defines the text of the <code>CheckBox</code>.
		 * @type {string}
		 * @public
		 */
		text : {
			"defaultValue": "",
			"type": String
		},

		/**
		 * Defines the text direction of the <code>CheckBox</code>.
		 * Available options are: <code>LTR</code> (left-to-right), <code>RTL</code> (right-to-left) and <code>Inherit</code>.
		 * @type {string}
		 * @public
		 */
		textDirection: {
			"defaultValue": TextDirection.Inherit,
			"type": TextDirection
		},

		/**
		 * Defines the tooltip of the <code>CheckBox</code>.
		 * @type {string}
		 * @public
		 */
		tooltip : {
			"defaultValue": "",
			"type": String
		},

		/**
		 * Defines the value state of the <code>CheckBox</code>.
		 * Supported options are: Warning, Error and None (by default).
		 * @type {string}
		 * @public
		 */
		valueState : {
			"defaultValue": ValueState.None,
			"type": ValueState
		},

		/**
		 * Defines the width of the <code>CheckBox</code> text.
		 * @type {string}
		 * @public
		 */
		width : {
			"defaultValue": "",
			"type": CSSSize
		},

		/**
		 * Defines if the <code>CheckBox</code> text is wrapping or not.
		 * @type {boolean}
		 * @public
		 */
		wrap: {
			"type": Boolean
		},

		_label: {
			"type": Object
		}
	},
	events: /** @lends sap.ui.webcomponents.main.CheckBox.prototype */ {
		/**
		 * Fired, whenever the <code>CheckBox</code> selected state changes.
		 * @public
		 * @param {boolean} selected Checks whether the CheckBox is marked or not .
		 * @event
		 */
		select: {
			detail : {
				selected : {type : "boolean"}
			}
		}
	}
};

/**
 * @class
 *
 * A class to represent a  <code>CheckBox</code>.
 *
 * <b> Overview </b>
 * Allows the user to set a binary value, such as true/false or yes/no for an item.
 * The  <code>CheckBox</code> control consists of a box and a label that describes its purpose.
 * If it's checked, an indicator is displayed inside the box.
 * To select/deselect the  <code>CheckBox</code>, the user has to click or tap the square box or its label.
 * Clicking or tapping toggles the  <code>CheckBox</code> between checked and unchecked state.
 * The <code>CheckBox</code> control only has 2 states - checked and unchecked.
 *
 * <b> Usage </b>
 * You can set the width of the element containing the box and the label manually with the use of the width property.
 * If the text exceeds the available width, it is truncated.
 * The touchable area for toggling the <code>CheckBox</code> ends where the text ends.
 * You can disable the <code>CheckBox</code> by setting the disabled property to true,
 * or use the <code>CheckBox</code> in read-only mode by setting the readOnly property to true.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.CheckBox
 * @public
 */
class CheckBox$2 extends WebComponent {

	static get metadata() {
		return metadata$3;
	}

	static get renderer() {
		return CheckBoxLitRenderer;
	}

	constructor(state) {
		super(state);
		this._label = {};
	}

	onBeforeRendering() {
		this.syncLabel();
	}

	syncLabel() {
		this._label = Object.assign({}, this._label);

		this._label.text = this.text;
		this._label.wrap = this.wrap;
		this._label.textDirection = this.textDirection;
	}

	ontap() {
		this.toggle();
	}

	onkeydown(event) {
		if (event.keyCode === mKeyCodes.SPACE ) {
			event.preventDefault();
		}

		if (event.keyCode === mKeyCodes.ENTER) {
			this.toggle();
		}
	}

	onkeyup(event) {
		if (event.keyCode === mKeyCodes.SPACE) {
			this.toggle();
		}
	}

	toggle() {
		if (this.canToggle()) {
			this.selected = !this.selected;
			this.fireEvent("select", {selected: this.selected});
		}
		return this;
	}

	canToggle() {
		return !(this.disabled || this.readOnly);
	}

	static get calculateTemplateContext() {
		return CheckBoxTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	CheckBox$2.define();
});

class CardTemplateContext {

	static calculate(state) {

		let jsonManifest = JSON.parse(state.manifest);

		let items = [];
		jsonManifest.content.data.json.forEach(function (item) {
			items.push({
				title: item.Name,
				description: item.Description
			});
		});

		let context = {
			title: jsonManifest.title,
			subTitle: jsonManifest.subTitle,
			status: jsonManifest.status,
			icon: jsonManifest.icon,
			items: items,
			ctr: state,
			classes: {
				main: {
					"sapFCard": true
				}
			}
		};

		return context;
	}
}

const html$3 = index.html;
const repeat$3 = index.repeat;

const CardLitRenderer = {};

const block0$2 = (context) => { return html$3`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
		class="${index.ifTruthy(context.classes.main)}"><header class="sapFCardHeader"><span role="img" aria-label="Avatar" class="sapFCardAvatar"><ui5-icon class="sapFCardHeaderIcon" src="${index.ifTruthy(context.icon.src)}"></ui5-icon></span><div class="sapFCardHeaderText"><div class="sapFCardTitle">${index.ifTruthy(context.title)}</div><div class="sapFCardSubtitle ">${index.ifTruthy(context.subTitle)}</div></div><span class="sapFCardStatus">${index.ifTruthy(context.status)}</span></header><section class="sapFCardContent"><ui5-list>
			${ repeat$3(context.items, undefined, (item, index$$1) => block1$2(item, index$$1, context)) }</ui5-list></section></div>`; };
const block1$2 = (item, index$$1, context) => { return html$3`<ui5-li-custom hide-border><div class="sapFCardListItem"><div class="sapFCardListItemTitle">${index.ifTruthy(item.title)}</div><div class="sapFCardListItemDescription">${index.ifTruthy(item.description)}</div></div></ui5-li-custom>
			`; };
const renderMe$2 = block0$2;

CardLitRenderer.render = renderMe$2;

/**
 * @public
 */
const metadata$4 = {
	tag: "ui5-card",
	styleUrl: [
		"Card.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.Card.prototype */ {
		/**
		 * Defines the card manifest.
		 * @type {Object}
		 * @public
		 */
		manifest: {
			type: String
		}
	}
};

/**
 * @class
 * A control that represents header and content area as a card.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Card
 * @public
 */
class Card$2 extends WebComponent {

	static get metadata() {
		return metadata$4;
	}

	static get renderer() {
		return CardLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	static get calculateTemplateContext() {
		return CardTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	Card$2.define();
});

class CalendarTemplateContext {

		static calculate(state) {

			let context = {
				ctr: state,
				classes: {
					main: {
						"sapUiCal": true
					}
				},
				styles: {}
			};

			return context;
		}
	}

class CalendarHeaderTemplateContext {

		static calculate(state) {

			let context = {
				ctr: state,
				classes: {
					main: {
						"sapUiCalHead": true
					}
				},
				styles: {}
			};

			return context;
		}
	}

const html$4 = index.html;

const CalendarHeaderLitRenderer = {};

const block0$3 = (context) => { return html$4`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
        class="${index.ifTruthy(context.classes.main)}"
><ui5-button
            id="${index.ifTruthy(context.ctr._id)}-btnPrev"
            icon="${index.ifTruthy(context.ctr._btnPrev.icon)}"
            ._customAttributes="${index.ifTruthy(context.ctr._btnPrev._customAttributes)}"
            ._customClasses="${index.ifTruthy(context.ctr._btnPrev._customClasses)}"
            @press="${index.ifTruthy(context.ctr._btnPrev.onPress)}"
    ></ui5-button><div><ui5-button
				id="${index.ifTruthy(context.ctr._id)}-btn1"
				type="${index.ifTruthy(context.ctr._btn1.type)}"
				@press="${index.ifTruthy(context.ctr._btn1.onPress)}"
				data-sap-focus-ref
		>${index.ifTruthy(context.ctr._btn1.text)}</ui5-button><ui5-button
				id="${index.ifTruthy(context.ctr._id)}-btn2"
				type="${index.ifTruthy(context.ctr._btn2.type)}"
				@press="${index.ifTruthy(context.ctr._btn2.onPress)}"
		>${index.ifTruthy(context.ctr._btn2.text)}</ui5-button></div><ui5-button
            id="${index.ifTruthy(context.ctr._id)}-btnNext"
            icon="${index.ifTruthy(context.ctr._btnNext.icon)}"
            ._customAttributes="${index.ifTruthy(context.ctr._btnNext._customAttributes)}"
            ._customClasses="${index.ifTruthy(context.ctr._btnNext._customClasses)}"
            @press="${index.ifTruthy(context.ctr._btnNext.onPress)}"
    ></ui5-button></div>`; };
const renderMe$3 = block0$3;

CalendarHeaderLitRenderer.render = renderMe$3;

var calendarHeaderBelize = "";

ShadowDOM.registerStyle("sap_belize", "CalendarHeader.css", calendarHeaderBelize);

const metadata$5 = {
	tag: "ui5-calendar-header",
	styleUrl: [
		"CalendarHeader.css",
		"Button.css",
		"Icon.css"
	],
	properties: {
		monthText: {
			type: String
		},
		yearText: {
			type: String
		},
		_btnPrev: {
			type: Object
		},
		_btnNext: {
			type: Object
		},
		_btn1: {
			type: Object
		},
		_btn2: {
			type: Object
		}
	},
	events : {
		pressPrevious : {},
		pressNext : {},
		btn1Press : {},
		btn2Press : {}
	}
};

class CalendarHeader$1 extends WebComponent {

	static get metadata() {
		return metadata$5;
	}

	static get renderer() {
		return CalendarHeaderLitRenderer;
	}

	constructor(state) {
		super(state);

		this._btnPrev = {};
		this._btnPrev.icon = "sap-icon://slim-arrow-left";
		this._btnPrev.onPress = this._handlePrevPress.bind(this);

		this._btnNext = {};
		this._btnNext.icon = "sap-icon://slim-arrow-right";
		this._btnNext.onPress = this._handleNextPress.bind(this);

		this._btn1 = {};
		this._btn1.type = ButtonType.Transparent;
		this._btn1.onPress = this._handleBtn1Press.bind(this);

		this._btn2 = {};
		this._btn2.type = ButtonType.Transparent;
		this._btn2.onPress = this._handleBtn2Press.bind(this);
	}

	onBeforeRendering() {
		this._btnPrev._customAttributes = {
			"tabindex": '-1'
		};
		this._btnNext._customAttributes = {
			"tabindex": '-1'
		};
		this._btnPrev._customClasses = ['sapUiCalHeadPrev'];
		this._btnNext._customClasses = ['sapUiCalHeadNext'];
		this._btn1.text = this.monthText;
		this._btn2.text = this.yearText;
	}

	_handlePrevPress(event) {
		this.fireEvent("pressPrevious", event);
	}

	_handleNextPress(event) {
		this.fireEvent("pressNext", event);
	}

	_handleBtn1Press(event) {
		this.fireEvent("btn1Press", event);
	}

	_handleBtn2Press(event) {
		this.fireEvent("btn2Press", event);
	}

	static get calculateTemplateContext() {
		return CalendarHeaderTemplateContext.calculate;
	}
}

Core$1.boot().then(async _ => {
	await Button$1.define();
	CalendarHeader$1.define();
});

class DayPickerTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			classes: {
				main: {
					"sapUiCalMonthView": true,
					"sapUiCalNoWeekNum": !state.showWeekNumbers
				}
			},
			styles: {
				main: {
					"width": "100%",
					"display": state._hidden ? 'none' : 'block'
				}
			}
		};

		return context;
	}
}

class EventProvider {
	constructor() {
		this._eventRegistry = {};
	}

	attachEvent(eventName, fnFunction) {
		let eventRegistry = this._eventRegistry;
		let eventListeners = eventRegistry[eventName];

		if (!Array.isArray(eventListeners)) {
			eventListeners = eventRegistry[eventName] = [];
		}

		eventListeners.push({
			'function': fnFunction
		});
	}

	detachEvent(eventName, fnFunction) {
		let eventRegistry = this._eventRegistry;
		let eventListeners = eventRegistry[eventName];

		if (!eventListeners) {
			return;
		}

		for (let i = 0; i < eventListeners.length; i++) {
			let event = eventListeners[i];
			if (event['function'] == fnFunction) {
				eventListeners.splice(i, 1);
			}
		}

		if (eventListeners.length == 0) {
			delete eventRegistry[eventName];
		}
	}

	fireEvent(eventName, data) {
		let eventRegistry = this._eventRegistry;
		let eventListeners = eventRegistry[eventName];

		if (!eventListeners) {
			return;
		}

		eventListeners.forEach(event => {
			event['function'].call(this, data);
		});
	}

	isHandlerAttached(eventName, fnFunction) {
		let eventRegistry = this._eventRegistry;
		let eventListeners = eventRegistry[eventName];

		if (!eventListeners) {
			return false;
		}

		for (let i = 0; i < eventListeners.length; i++) {
			let event = eventListeners[i];
			if (event['function'] == fnFunction) {
				return true;
			}
		}

		return false;
	}

	hasListeners(eventName) {
		return !!this._eventRegistry[eventName];
	}
}

// navigatable items must have id and tabindex
class ItemNavigation extends EventProvider {

	constructor(rootControl, options = {}) {
		super();

		this.currentIndex = options.currentIndex || 0;
		this.rowSize = options.rowSize || 1;
		this.cyclic = options.cyclic || false;

		this.rootControl = rootControl;
	}

	static get metadata() {
		return metadata;
	}

	init() {
		this._getItems().forEach((item, idx) => {
			item._tabIndex = (idx === this.currentIndex) ? "0" : "-1";
		});
	}

	_onKeyPress(event) {
		const items = this._getItems();

		if (this.currentIndex >= items.length) {
			if (!this.cyclic) {
				this.fireEvent(ItemNavigation.BORDER_REACH, { start: false, end: true, offset: this.currentIndex });
			}

			this.currentIndex = this.currentIndex - items.length;
		} else if (this.currentIndex < 0) {
			if (!this.cyclic) {
				this.fireEvent(ItemNavigation.BORDER_REACH, { start: true, end: false, offset: this.currentIndex });
			}

			this.currentIndex = items.length + this.currentIndex;
		}

		this.update();
		this.focusCurrent();

		//stops browser scrolling with up/down keys
		event.stopPropagation();
		event.stopImmediatePropagation();
		event.preventDefault();
	}

	onsapup(event) {
		if (this._canNavigate()) {
			this.currentIndex -= this.rowSize;
			this._onKeyPress(event);
		}
	}

	onsapdown(event) {
		if (this._canNavigate()) {
			this.currentIndex += this.rowSize;
			this._onKeyPress(event);
		}
	}

	onsapleft(event) {
		if (this._canNavigate()) {
			this.currentIndex--;
			this._onKeyPress(event);
		}
	}

	onsapright(event) {
		if (this._canNavigate()) {
			this.currentIndex++;
			this._onKeyPress(event);
		}
	}

	onsaphome(event) {
		if (this._canNavigate()) {
			const homeEndRange = this.rowSize > 1 ? this.rowSize : this._getItems().length;
			this.currentIndex -= this.currentIndex % homeEndRange;
			this._onKeyPress(event);
		}
	}

	onsapend(event) {
		if (this._canNavigate()) {
			const homeEndRange = this.rowSize > 1 ? this.rowSize : this._getItems().length;
			this.currentIndex += (homeEndRange - 1 - this.currentIndex % homeEndRange);
			this._onKeyPress(event);
		}
	}

	update(current) {
		const origItems = this._getItems();

		if (current) {
			this.currentIndex = this._getItems().indexOf(current);
		}

		if (!origItems[this.currentIndex]
			|| (origItems[this.currentIndex]._tabIndex && origItems[this.currentIndex]._tabIndex === "0")) {
			return;
		}

		let items = origItems.slice(0);

		for (let i = 0; i < items.length; i++) {
			items[i]._tabIndex = (i === this.currentIndex ? "0" : "-1");
		}

		if (this._setItems) {
			this._setItems(items);
		}
	}

	focusCurrent() {
		let currentItem = this._getCurrentItem();
		if (currentItem) {
			currentItem.focus();
		}
	}

	_canNavigate() {

		let currentItem = this._getCurrentItem();

		let activeElement = document.activeElement;

		while(activeElement.shadowRoot) {
			activeElement = activeElement.shadowRoot.activeElement;
		}

		return currentItem && currentItem === activeElement;
	}

	_getCurrentItem() {
		const items = this._getItems();

		//normalize the index
		while (this.currentIndex >= items.length) {
			this.currentIndex -= this.rowSize;
		}

		let currentItem = items[this.currentIndex];

		if (currentItem instanceof WebComponent) {
			return currentItem.getFocusDomRef();
		}

		if (!this.rootControl.getDomRef()) {
			return;
		}

		return this.rootControl.getDomRef().querySelector("#" + currentItem.id);
	}

	set setItemsCallback(fn) {
		this._setItems = fn;
	}

	set getItemsCallback(fn) {
		this._getItems = fn;
	}

	set current(val) {
		this.currentIndex = val;
	}
}

ItemNavigation.BORDER_REACH = "_borderReach";

var registry = new Map();
var CalendarClassRegistry = {
    getCalendarClass: function (calendarType) {
        return registry.get(calendarType);
    },
    setCalendarClass: function (calendarType, Klass) {
        registry.set(calendarType, Klass);
    }
};

var UniversalDate = BaseObject$1.extend('sap.ui.core.date.UniversalDate', {
    constructor: function () {
        var clDate = UniversalDate.getClass();
        return this.createDate(clDate, arguments);
    }
});
UniversalDate.UTC = function () {
    var clDate = UniversalDate.getClass();
    return clDate.UTC.apply(clDate, arguments);
};
UniversalDate.now = function () {
    return Date.now();
};
UniversalDate.prototype.createDate = function (clDate, aArgs) {
    switch (aArgs.length) {
    case 0:
        return new clDate();
    case 1:
        return new clDate(aArgs[0]);
    case 2:
        return new clDate(aArgs[0], aArgs[1]);
    case 3:
        return new clDate(aArgs[0], aArgs[1], aArgs[2]);
    case 4:
        return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3]);
    case 5:
        return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3], aArgs[4]);
    case 6:
        return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3], aArgs[4], aArgs[5]);
    case 7:
        return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3], aArgs[4], aArgs[5], aArgs[6]);
    }
};
UniversalDate.getInstance = function (oDate, sCalendarType) {
    var clDate, oInstance;
    if (oDate instanceof UniversalDate) {
        oDate = oDate.getJSDate();
    }
    if (!sCalendarType) {
        sCalendarType = sap.ui.getCore().getConfiguration().getCalendarType();
    }
    clDate = UniversalDate.getClass(sCalendarType);
    oInstance = Object.create(clDate.prototype);
    oInstance.oDate = oDate;
    oInstance.sCalendarType = sCalendarType;
    return oInstance;
};
UniversalDate.getClass = function (sCalendarType) {
    if (!sCalendarType) {
        sCalendarType = sap.ui.getCore().getConfiguration().getCalendarType();
    }
    var Klass = CalendarClassRegistry.getCalendarClass(sCalendarType);
    if (!Klass) {
        if (!sap || !sap.ui || !sap.ui.requireSync) {
            throw new Error('Calendar type [' + sCalendarType + '] is not imported');
        }
        Klass = sap.ui.requireSync('sap/ui/core/date/' + sCalendarType);
    }
    return Klass;
};
[
    'getDate',
    'getMonth',
    'getFullYear',
    'getYear',
    'getDay',
    'getHours',
    'getMinutes',
    'getSeconds',
    'getMilliseconds',
    'getUTCDate',
    'getUTCMonth',
    'getUTCFullYear',
    'getUTCDay',
    'getUTCHours',
    'getUTCMinutes',
    'getUTCSeconds',
    'getUTCMilliseconds',
    'getTime',
    'valueOf',
    'getTimezoneOffset',
    'toString',
    'toDateString',
    'setDate',
    'setFullYear',
    'setYear',
    'setMonth',
    'setHours',
    'setMinutes',
    'setSeconds',
    'setMilliseconds',
    'setUTCDate',
    'setUTCFullYear',
    'setUTCMonth',
    'setUTCHours',
    'setUTCMinutes',
    'setUTCSeconds',
    'setUTCMilliseconds'
].forEach(function (sName) {
    UniversalDate.prototype[sName] = function () {
        return this.oDate[sName].apply(this.oDate, arguments);
    };
});
UniversalDate.prototype.getJSDate = function () {
    return this.oDate;
};
UniversalDate.prototype.getCalendarType = function () {
    return this.sCalendarType;
};
UniversalDate.prototype.getEra = function () {
    return UniversalDate.getEraByDate(this.sCalendarType, this.oDate.getFullYear(), this.oDate.getMonth(), this.oDate.getDate());
};
UniversalDate.prototype.setEra = function (iEra) {
};
UniversalDate.prototype.getUTCEra = function () {
    return UniversalDate.getEraByDate(this.sCalendarType, this.oDate.getUTCFullYear(), this.oDate.getUTCMonth(), this.oDate.getUTCDate());
};
UniversalDate.prototype.setUTCEra = function (iEra) {
};
UniversalDate.prototype.getWeek = function () {
    return UniversalDate.getWeekByDate(this.sCalendarType, this.getFullYear(), this.getMonth(), this.getDate());
};
UniversalDate.prototype.setWeek = function (oWeek) {
    var oDate = UniversalDate.getFirstDateOfWeek(this.sCalendarType, oWeek.year || this.getFullYear(), oWeek.week);
    this.setFullYear(oDate.year, oDate.month, oDate.day);
};
UniversalDate.prototype.getUTCWeek = function () {
    return UniversalDate.getWeekByDate(this.sCalendarType, this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate());
};
UniversalDate.prototype.setUTCWeek = function (oWeek) {
    var oDate = UniversalDate.getFirstDateOfWeek(this.sCalendarType, oWeek.year || this.getFullYear(), oWeek.week);
    this.setUTCFullYear(oDate.year, oDate.month, oDate.day);
};
UniversalDate.prototype.getQuarter = function () {
    return Math.floor(this.getMonth() / 3);
};
UniversalDate.prototype.getUTCQuarter = function () {
    return Math.floor(this.getUTCMonth() / 3);
};
UniversalDate.prototype.getDayPeriod = function () {
    if (this.getHours() < 12) {
        return 0;
    } else {
        return 1;
    }
};
UniversalDate.prototype.getUTCDayPeriod = function () {
    if (this.getUTCHours() < 12) {
        return 0;
    } else {
        return 1;
    }
};
UniversalDate.prototype.getTimezoneShort = function () {
    if (this.oDate.getTimezoneShort) {
        return this.oDate.getTimezoneShort();
    }
};
UniversalDate.prototype.getTimezoneLong = function () {
    if (this.oDate.getTimezoneLong) {
        return this.oDate.getTimezoneLong();
    }
};
var iMillisecondsInWeek = 7 * 24 * 60 * 60 * 1000;
UniversalDate.getWeekByDate = function (sCalendarType, iYear, iMonth, iDay) {
    var oLocale = sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale(), clDate = this.getClass(sCalendarType), oFirstDay = getFirstDayOfFirstWeek(clDate, iYear), oDate = new clDate(clDate.UTC(iYear, iMonth, iDay)), iWeek, iLastYear, iNextYear, oLastFirstDay, oNextFirstDay;
    if (oLocale.getRegion() === 'US') {
        iWeek = calculateWeeks(oFirstDay, oDate);
    } else {
        iLastYear = iYear - 1;
        iNextYear = iYear + 1;
        oLastFirstDay = getFirstDayOfFirstWeek(clDate, iLastYear);
        oNextFirstDay = getFirstDayOfFirstWeek(clDate, iNextYear);
        if (oDate >= oNextFirstDay) {
            iYear = iNextYear;
            iWeek = 0;
        } else if (oDate < oFirstDay) {
            iYear = iLastYear;
            iWeek = calculateWeeks(oLastFirstDay, oDate);
        } else {
            iWeek = calculateWeeks(oFirstDay, oDate);
        }
    }
    return {
        year: iYear,
        week: iWeek
    };
};
UniversalDate.getFirstDateOfWeek = function (sCalendarType, iYear, iWeek) {
    var oLocale = sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale(), clDate = this.getClass(sCalendarType), oFirstDay = getFirstDayOfFirstWeek(clDate, iYear), oDate = new clDate(oFirstDay.valueOf() + iWeek * iMillisecondsInWeek);
    if (oLocale.getRegion() === 'US' && iWeek === 0 && oFirstDay.getUTCFullYear() < iYear) {
        return {
            year: iYear,
            month: 0,
            day: 1
        };
    }
    return {
        year: oDate.getUTCFullYear(),
        month: oDate.getUTCMonth(),
        day: oDate.getUTCDate()
    };
};
function getFirstDayOfFirstWeek(clDate, iYear) {
    var oLocale = sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale(), oLocaleData = LocaleData.getInstance(oLocale), iMinDays = oLocaleData.getMinimalDaysInFirstWeek(), iFirstDayOfWeek = oLocaleData.getFirstDayOfWeek(), oFirstDay = new clDate(clDate.UTC(iYear, 0, 1)), iDayCount = 7;
    while (oFirstDay.getUTCDay() !== iFirstDayOfWeek) {
        oFirstDay.setUTCDate(oFirstDay.getUTCDate() - 1);
        iDayCount--;
    }
    if (iDayCount < iMinDays) {
        oFirstDay.setUTCDate(oFirstDay.getUTCDate() + 7);
    }
    return oFirstDay;
}
function calculateWeeks(oFromDate, oToDate) {
    return Math.floor((oToDate.valueOf() - oFromDate.valueOf()) / iMillisecondsInWeek);
}
var mEras = {};
UniversalDate.getEraByDate = function (sCalendarType, iYear, iMonth, iDay) {
    var aEras = getEras(sCalendarType), iTimestamp = new Date(0).setUTCFullYear(iYear, iMonth, iDay), oEra;
    for (var i = aEras.length - 1; i >= 0; i--) {
        oEra = aEras[i];
        if (!oEra) {
            continue;
        }
        if (oEra._start && iTimestamp >= oEra._startInfo.timestamp) {
            return i;
        }
        if (oEra._end && iTimestamp < oEra._endInfo.timestamp) {
            return i;
        }
    }
};
UniversalDate.getCurrentEra = function (sCalendarType) {
    var oNow = new Date();
    return this.getEraByDate(sCalendarType, oNow.getFullYear(), oNow.getMonth(), oNow.getDate());
};
UniversalDate.getEraStartDate = function (sCalendarType, iEra) {
    var aEras = getEras(sCalendarType), oEra = aEras[iEra] || aEras[0];
    if (oEra._start) {
        return oEra._startInfo;
    }
};
function getEras(sCalendarType) {
    var oLocale = sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale(), oLocaleData = LocaleData.getInstance(oLocale), aEras = mEras[sCalendarType];
    if (!aEras) {
        var aEras = oLocaleData.getEraDates(sCalendarType);
        if (!aEras[0]) {
            aEras[0] = { _start: '1-1-1' };
        }
        for (var i = 0; i < aEras.length; i++) {
            var oEra = aEras[i];
            if (!oEra) {
                continue;
            }
            if (oEra._start) {
                oEra._startInfo = parseDateString(oEra._start);
            }
            if (oEra._end) {
                oEra._endInfo = parseDateString(oEra._end);
            }
        }
        mEras[sCalendarType] = aEras;
    }
    return aEras;
}
function parseDateString(sDateString) {
    var aParts = sDateString.split('-'), iYear, iMonth, iDay;
    if (aParts[0] == '') {
        iYear = -parseInt(aParts[1]);
        iMonth = parseInt(aParts[2]) - 1;
        iDay = parseInt(aParts[3]);
    } else {
        iYear = parseInt(aParts[0]);
        iMonth = parseInt(aParts[1]) - 1;
        iDay = parseInt(aParts[2]);
    }
    return {
        timestamp: new Date(0).setUTCFullYear(iYear, iMonth, iDay),
        year: iYear,
        month: iMonth,
        day: iDay
    };
}

class CalendarDate {
	constructor() {
		var aArgs = arguments,
			oJSDate, oNow, sCalendarType;

		switch (aArgs.length) {
			case 0: // defaults to the current date
				oNow = new Date();
				return this.constructor(oNow.getFullYear(), oNow.getMonth(), oNow.getDate());

			case 1: // CalendarDate
			case 2: // CalendarDate, sCalendarType
				if (!(aArgs[0] instanceof CalendarDate)) {
					throw "Invalid arguments: the first argument must be of type sap.ui.unified.calendar.CalendarDate.";
				}
				sCalendarType = aArgs[1] ? aArgs[1] : aArgs[0]._oUDate.sCalendarType;
				//Use source.valueOf() (returns the same point of time regardless calendar type) instead of
				//source's getters to avoid non-gregorian Year, Month and Date may be used to construct a Gregorian date
				oJSDate = new Date(aArgs[0].valueOf());

				//Make this date really local. Now getters are safe.
				oJSDate.setFullYear(oJSDate.getUTCFullYear(), oJSDate.getUTCMonth(), oJSDate.getUTCDate());
				oJSDate.setHours(oJSDate.getUTCHours(), oJSDate.getUTCMinutes(), oJSDate.getUTCSeconds(), oJSDate.getUTCMilliseconds());

				this._oUDate = createUniversalUTCDate(oJSDate, sCalendarType);
				break;

			case 3: // year, month, date
			case 4: // year, month, date, sCalendarType
				checkNumericLike(aArgs[0], "Invalid year: " + aArgs[0]);
				checkNumericLike(aArgs[1], "Invalid month: " + aArgs[1]);
				checkNumericLike(aArgs[2], "Invalid date: " + aArgs[2]);

				oJSDate = new Date(0, 0, 1);
				oJSDate.setFullYear(aArgs[0], aArgs[1], aArgs[2]); // 2 digits year is not supported. If so, it is considered as full year as well.

				if (aArgs[3]) {
					sCalendarType = aArgs[3];
				}
				this._oUDate = createUniversalUTCDate(oJSDate, sCalendarType);
				break;

			default:
				throw "Invalid arguments. Accepted arguments are: 1) oCalendarDate, (optional)calendarType" +
				"or 2) year, month, date, (optional) calendarType" + aArgs;
		}
	}

	getYear() {
		return this._oUDate.getUTCFullYear();
	}

	setYear(year) {
		checkNumericLike(year, "Invalid year: " + year);
		this._oUDate.setUTCFullYear(year);
		return this;
	}

	getMonth() {
		return this._oUDate.getUTCMonth();
	}

	setMonth(month) {
		checkNumericLike(month, "Invalid month: " + month);
		this._oUDate.setUTCMonth(month);
		return this;
	}

	getDate() {
		return this._oUDate.getUTCDate();
	}

	setDate(date) {
		checkNumericLike(date, "Invalid date: " + date);
		this._oUDate.setUTCDate(date);
		return this;
	}

	getDay() {
		return this._oUDate.getUTCDay();
	}

	getCalendarType() {
		return this._oUDate.sCalendarType;
	}

	isBefore(oCalendarDate) {
		checkCalendarDate(oCalendarDate);
		return this.valueOf() < oCalendarDate.valueOf();
	}

	isAfter(oCalendarDate) {
		checkCalendarDate(oCalendarDate);
		return this.valueOf() > oCalendarDate.valueOf();
	}

	isSameOrBefore(oCalendarDate) {
		checkCalendarDate(oCalendarDate);
		return this.valueOf() <= oCalendarDate.valueOf();
	}

	isSameOrAfter(oCalendarDate) {
		checkCalendarDate(oCalendarDate);
		return this.valueOf() >= oCalendarDate.valueOf();
	}

	isSame(oCalendarDate) {
		checkCalendarDate(oCalendarDate);
		return this.valueOf() === oCalendarDate.valueOf();
	}

	toLocalJSDate() {
		// Use this._oUDate.getTime()(returns the same point of time regardless calendar type)  instead of
		// this._oUDate's getters to avoid non-gregorian Year, Month and Date to be used to construct a Gregorian date
		var oLocalDate = new Date(this._oUDate.getTime());

		//Make this date really local. Now getters are safe.
		oLocalDate.setFullYear(oLocalDate.getUTCFullYear(), oLocalDate.getUTCMonth(), oLocalDate.getUTCDate());
		oLocalDate.setHours(0, 0, 0, 0);

		return oLocalDate;
	}

	toUTCJSDate() {
		// Use this._oUDate.getTime()(returns the same point of time regardless calendar type)  instead of
		// this._oUDate's getters to avoid non-gregorian Year, Month and Date to be used to construct a Gregorian date
		var oUTCDate = new Date(this._oUDate.getTime());
		oUTCDate.setUTCHours(0, 0, 0, 0);

		return oUTCDate;
	}

	toString() {
		return this._oUDate.sCalendarType + ": " + this.getYear() + "/" + (this.getMonth() + 1) + "/" + this.getDate();
	}

	valueOf() {
		return this._oUDate.getTime();
	}

	static fromLocalJSDate(oJSDate, sCalendarType) {
		// Cross frame check for a date should be performed here otherwise setDateValue would fail in OPA tests
		// because Date object in the test is different than the Date object in the application (due to the iframe).
		// We can use jQuery.type or this method:
		function isValidDate(date) {
			return date && Object.prototype.toString.call(date) === "[object Date]" && !isNaN(date);
		}
		if (!isValidDate) {
			throw new Error("Date parameter must be a JavaScript Date object: [" + oJSDate + "].");
		}
		return new CalendarDate(oJSDate.getFullYear(), oJSDate.getMonth(), oJSDate.getDate(), sCalendarType);
	}
}

function createUniversalUTCDate(oDate, sCalendarType) {
	if (sCalendarType) {
		return UniversalDate.getInstance(createUTCDate(oDate), sCalendarType);
	} else {
		return new UniversalDate(createUTCDate(oDate).getTime());
	}
}

/**
 * Creates a JavaScript UTC Date corresponding to the given JavaScript Date.
 * @param {Date} oDate JavaScript date object. Time related information is cut.
 * @returns {Date} JavaScript date created from the date object, but this time considered as UTC date information.
 */
function createUTCDate(oDate) {
	var oUTCDate = new Date(Date.UTC(0, 0, 1));

	oUTCDate.setUTCFullYear(oDate.getFullYear(), oDate.getMonth(), oDate.getDate());

	return oUTCDate;
}

function checkCalendarDate(oCalendarDate) {
	if (!(oCalendarDate instanceof CalendarDate)) {
		throw "Invalid calendar date: [" + oCalendarDate + "]. Expected: sap.ui.unified.calendar.CalendarDate";
	}
}

/**
 * Verifies the given value is numeric like, i.e. 3, "3" and throws an error if it is not.
 * @param {any} value The value of any type to check. If null or undefined, this method throws an error.
 * @param {string} message The message to be used if an error is to be thrown
 * @throws will throw an error if the value is null or undefined or is not like a number
 */
function checkNumericLike(value, message) {
	if (value == undefined || value === Infinity || isNaN(value)) {//checks also for null.
		throw message;
	}
}

/**
 * Different calendar types.
 */
const CalendarTypes = {
	Gregorian: "Gregorian",
	Islamic: "Islamic",
	Japanese: "Japanese",
	Buddhist: "Buddhist",
	Persian: "Persian"
};

class CalendarType$1 extends DataType {
	static isValid(value) {
		return !!CalendarTypes[value];
	}
}

CalendarType$1.generataTypeAcessors(CalendarTypes);

const html$5 = index.html;
const repeat$5 = index.repeat;

const DayPickerLitRenderer = {};

const block0$4 = (context) => { return html$5`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"        class="${index.ifTruthy(context.classes.main)}"		style="${index.ifTruthy(context.styles.main)}"><div role="row" style="overflow:hidden">		${ repeat$5(context.ctr._dayNames, undefined, (item, index$$1) => block1$3(item, index$$1, context)) }</div><div id="${index.ifTruthy(context.ctr._id)}-days" class="sapUiCalItems" tabindex="-1">		${ repeat$5(context.ctr._days, undefined, (item, index$$1) => block2$1(item, index$$1, context)) }</div></div>`; };
const block1$3 = (item, index$$1, context) => { return html$5`<div				id=${index.ifTruthy(item._id)}				role="columnheader"				aria-label="${index.ifTruthy(item.name)}"				class="${index.ifTruthy(item.classes)}">				${index.ifTruthy(item.ultraShortName)}</div>		`; };
const block2$1 = (item, index$$1, context) => { return html$5`<div				id="${index.ifTruthy(item.id)}"				tabindex="${index.ifTruthy(item._tabIndex)}"				data-sap-timestamp="${index.ifTruthy(item.timestamp)}"				role="gridcell"				aria-selected="${index.ifTruthy(item.selected)}"				class="${index.ifTruthy(item.classes)}"><span class="sapUiCalItemText">						${index.ifTruthy(item.iDay)}</span>					${ item.iWeekNumber ? block3(item, index$$1, context) : undefined }</div>		`; };
const block3 = (item, index$$1, context) => { return html$5`<span class="sapUiCalWeekNum">${index.ifTruthy(item.iWeekNumber)}</span>					`; };
const renderMe$4 = block0$4;

DayPickerLitRenderer.render = renderMe$4;

var calendarBelize = "";

/**
 * @public
 */
const metadata$6 = {
	tag: "ui5-daypicker",
	styleUrl: [
		"Calendar.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.DayPicker.prototype */ {
		/**
		 * A UNIX timestamp - seconds since 00:00:00 UTC on Jan 1, 1970.
		 * @type {number}
		 * @public
		 */
		timestamp: {
			type: Integer
		},
		/**
		 * Sets a calendar type used for display.
		 * If not set, the calendar type of the global configuration is used.
		 * @type {string}
		 * @public
		 */
		primaryCalendarType: {
			type: CalendarType$1
		},
		/**
		 * Sets the selected dates as UTC timestamps.
		 * @type {Array}
		 * @public
		 */
		selectedDates: {
			type: Integer,
			multiple: true
		},
		_days: {
			type: Object,
			multiple: true,
			nonVisual: true
		},
		_dayNames: {
			type: Object,
			multiple: true,
			nonVisual: true
		},
		_hidden: {
			type: Boolean
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.DayPicker.prototype */ {
		/**
		 * Fired when the user selects a new Date on the control.
		 * @public
		 * @event
		 */
		selectedDatesChange: {},
		/**
		 * Fired when month, year has changed due to item navigation.
		 * @public
		 * @event
		 */
		navigate: {}
	}
};

/**
 * @class
 *
 * Represents one month view inside a calendar.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.DayPicker
 * @public
 */
class DayPicker extends WebComponent {

	static get metadata() {
		return metadata$6;
	}

	static get renderer() {
		return DayPickerLitRenderer;
	}

	constructor(state) {
		super(state);
		this._oLocale = Core$1.getConfiguration().getFormatSettings().getFormatLocale();
		this._oLocaleData = new LocaleData(this._oLocale);

		this._itemNav = new ItemNavigation(this, { rowSize: 7});
		this._itemNav.getItemsCallback = function() {
			return this._days;
		}.bind(this);
		this._itemNav.setItemsCallback = function(items) {
			this._days = items;
		}.bind(this);

		this._itemNav.attachEvent(ItemNavigation.BORDER_REACH, this._handleItemNavigationBorderReach.bind(this));

		this._delegates.push(this._itemNav);
	}

	onBeforeRendering() {
		let oCalDate, day, timestamp;
		const _aVisibleDays = this._getVisibleDays(this._calendarDate);

		this._days = [];

		for (let i = 0; i < _aVisibleDays.length; i++) {
			oCalDate = _aVisibleDays[i];
			timestamp = oCalDate.valueOf() / 1000; //no need to round because CalendarDate does it
			day = {
				timestamp: timestamp.toString(),
				selected: this._selectedDates.some(d => timestamp === d),
				iDay: oCalDate.getDate(),
				classes: "sapUiCalItem sapUiCalWDay" + oCalDate.getDay().toString()
			};

			if (oCalDate.getDay() === this._getFirstDayOfWeek()) {
				day.classes += " sapUiCalFirstWDay";
			}

			if (day.selected) {
				day.classes += " sapUiCalItemSel";
			}

			if (oCalDate.isSame(this._currentCalendarDate)) {
				day.classes += " sapUiCalItemNow";
			}

			if (this._isWeekend(oCalDate)) {
				day.classes += " sapUiCalItemWeekEnd";
			}

			if (oCalDate.getMonth() !== this._month) {
				day.classes += " sapUiCalItemOtherMonth";
			}

			day.id = this._id  + "-" + timestamp;
			this._days.push(day);
		}

		this._itemNav.init();

		const aDayNamesWide = this._oLocaleData.getDays("wide", this._primaryCalendarType);
		const aDayNamesAbbreviated = this._oLocaleData.getDays("abbreviated", this._primaryCalendarType);
		const aUltraShortNames = aDayNamesAbbreviated.map((n) => n.substring(0,1));
		let dayName;

		this._dayNames = [];
		for (let i = 0; i < 7; i++) {
			dayName = {
				id: this._id + "-WH" + i.toString(),
				name: aDayNamesWide[i],
				ultraShortName: aUltraShortNames[i],
				classes: "sapUiCalWH"
			};

			this._dayNames.push(dayName);
		}

		this._dayNames[0].classes += " sapUiCalFirstWDay";
	}

	onAfterRendering() {
		this._itemNav.focusCurrent();
	}

	onclick(event) {
		if (event.ui5target.className.indexOf('sapUiCalItemText') > -1) {
			const targetDate = parseInt(event.ui5target.parentNode.getAttribute("data-sap-timestamp"), 10);

			//findIndex, give it to item navigation
			let i;
			for (i = 0; i < this._days.length; i++) {
				if (parseInt(this._days[i].timestamp, 10) === targetDate) {
					this._itemNav.current = i;
					break;
				}
			}

			this._modifySelectionAndNotifySubscribers(targetDate, event.ctrlKey);
		}
	}

	onsapenter(event) {
		event.preventDefault();
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const targetDate = parseInt(event.ui5target.getAttribute("data-sap-timestamp"), 10);
			this._modifySelectionAndNotifySubscribers(targetDate, event.ctrlKey);
		}
	}

	onsapspace(event) {
		event.preventDefault();
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const targetDate = parseInt(event.ui5target.getAttribute("data-sap-timestamp"), 10);
			this._modifySelectionAndNotifySubscribers(targetDate, event.ctrlKey);
		}
	}

	get _timestamp() {
		return this.timestamp !== undefined ? this.timestamp : Math.floor(new Date().getTime() / 1000);
	}

	get _localDate() {
		return new Date(this._timestamp * 1000);
	}

	get _calendarDate() {
		return CalendarDate.fromLocalJSDate(this._localDate, this._primaryCalendarType);
	}

	get _month() {
		return this._calendarDate.getMonth();
	}

	get _year() {
		return this._calendarDate.getYear();
	}

	get _currentCalendarDate() {
		return CalendarDate.fromLocalJSDate(new Date(), this._primaryCalendarType);
	}

	get _selectedDates() {
		return this.selectedDates || [];
	}

	get _primaryCalendarType() {
		return this.primaryCalendarType || Core$1.getConfiguration().getCalendarType();
	}

	_modifySelectionAndNotifySubscribers(sNewDate, bAdd) {
		if (bAdd) {
			this.selectedDates = [...this._selectedDates, sNewDate];
		} else {
			this.selectedDates = [sNewDate];
		}

		this.fireEvent('selectedDatesChange', { dates: [...this._selectedDates] });
	}

	_handleItemNavigationBorderReach(event) {
		const currentMonth = this._month,
			currentYear = this._year;
		let iNewMonth, iNewYear;

		if (event.end) {
			iNewMonth = currentMonth < 11 ? currentMonth + 1 : 0;
			iNewYear = currentMonth < 11 ? currentYear : currentYear + 1;
		} else if (event.start) {
			iNewMonth = currentMonth > 0 ? currentMonth - 1 : 11;
			iNewYear = currentMonth > 0 ? currentYear : currentYear - 1;
		}

		const oNewDate = this._calendarDate;
		oNewDate.setYear(iNewYear);
		oNewDate.setMonth(iNewMonth);

		this.fireEvent("navigate", { timestamp: (oNewDate.valueOf() / 1000) });
	}

	_isWeekend(oDate) {
		const iWeekDay = oDate.getDay(),
			iWeekendStart = this._oLocaleData.getWeekendStart(),
			iWeekendEnd = this._oLocaleData.getWeekendEnd();

		return (iWeekDay >= iWeekendStart && iWeekDay <= iWeekendEnd)
			|| (iWeekendEnd < iWeekendStart && (iWeekDay >= iWeekendStart || iWeekDay <= iWeekendEnd));
	}

	_getVisibleDays(oStartDate, bIncludeBCDates) {
		var iNextMonth,
			oDay,
			oCalDate,
			iDaysOldMonth,
			oFirstDay,
			iFirstDayOfWeek,
			iYear;

		const _aVisibleDays = [];

		// If date passed generate days for new start date else return the current one
		if (!oStartDate) {
			return _aVisibleDays;
		}

		iFirstDayOfWeek = this._getFirstDayOfWeek();

		// determine weekday of first day in month
		oFirstDay = new CalendarDate(oStartDate, this._primaryCalendarType);
		oFirstDay.setDate(1);
		iDaysOldMonth = oFirstDay.getDay() - iFirstDayOfWeek;
		if (iDaysOldMonth < 0) {
			iDaysOldMonth = 7 + iDaysOldMonth;
		}

		if (iDaysOldMonth > 0) {
			// determine first day for display
			oFirstDay.setDate(1 - iDaysOldMonth);
		}

		oDay = new CalendarDate(oFirstDay);
		iNextMonth = (oStartDate.getMonth() + 1) % 12;
		do {
			iYear = oDay.getYear();
			oCalDate = new CalendarDate(oDay, this._primaryCalendarType);
			if (bIncludeBCDates && iYear < 1) {
				// For dates before 0001-01-01 we should render only empty squares to keep the month square matrix correct.
				oCalDate._bBeforeFirstYear = true;
				_aVisibleDays.push(oCalDate);
			} else if (iYear > 0 && iYear < 10000) { // Days before 0001-01-01 or after 9999-12-31 should not be rendered.
				_aVisibleDays.push(oCalDate);
			}
			oDay.setDate(oDay.getDate() + 1);
		} while (oDay.getMonth() !== iNextMonth || oDay.getDay() !== iFirstDayOfWeek);

		return _aVisibleDays;
	}

	_getFirstDayOfWeek() {
		return this._oLocaleData.getFirstDayOfWeek();
	}

	static get calculateTemplateContext() {
		return DayPickerTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	DayPicker.define();
});

var rMessageFormat = /('')|'([^']+(?:''[^']*)*)(?:'|$)|\{([0-9]+(?:\s*,[^{}]*)?)\}|[{}]/g;
var fnFormatMessage = function (sPattern, aValues) {
    fnAssert(typeof sPattern === 'string' || sPattern instanceof String, 'pattern must be string');
    if (arguments.length > 2 || aValues != null && !Array.isArray(aValues)) {
        aValues = Array.prototype.slice.call(arguments, 1);
    }
    aValues = aValues || [];
    return sPattern.replace(rMessageFormat, function ($0, $1, $2, $3, offset) {
        if ($1) {
            return '\'';
        } else if ($2) {
            return $2.replace(/''/g, '\'');
        } else if ($3) {
            return String(aValues[parseInt($3)]);
        }
        throw new Error('formatMessage: pattern syntax error at pos. ' + offset);
    });
};

var DateFormat = function () {
    throw new Error();
};
var mCldrDatePattern = {};
DateFormat.oDateInfo = {
    oDefaultFormatOptions: {
        style: 'medium',
        relativeScale: 'day',
        relativeStyle: 'wide'
    },
    aFallbackFormatOptions: [
        { style: 'short' },
        { style: 'medium' },
        { pattern: 'yyyy-MM-dd' },
        {
            pattern: 'yyyyMMdd',
            strictParsing: true
        }
    ],
    bShortFallbackFormatOptions: true,
    bPatternFallbackWithoutDelimiter: true,
    getPattern: function (oLocaleData, sStyle, sCalendarType) {
        return oLocaleData.getDatePattern(sStyle, sCalendarType);
    },
    oRequiredParts: {
        'text': true,
        'year': true,
        'weekYear': true,
        'month': true,
        'day': true
    },
    aRelativeScales: [
        'year',
        'month',
        'week',
        'day'
    ],
    aRelativeParseScales: [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second'
    ],
    aIntervalCompareFields: [
        'FullYear',
        'Quarter',
        'Month',
        'Week',
        'Date'
    ]
};
DateFormat.oDateTimeInfo = {
    oDefaultFormatOptions: {
        style: 'medium',
        relativeScale: 'auto',
        relativeStyle: 'wide'
    },
    aFallbackFormatOptions: [
        { style: 'short' },
        { style: 'medium' },
        { pattern: 'yyyy-MM-dd\'T\'HH:mm:ss' },
        { pattern: 'yyyyMMdd HHmmss' }
    ],
    getPattern: function (oLocaleData, sStyle, sCalendarType) {
        var iSlashIndex = sStyle.indexOf('/');
        if (iSlashIndex > 0) {
            return oLocaleData.getCombinedDateTimePattern(sStyle.substr(0, iSlashIndex), sStyle.substr(iSlashIndex + 1), sCalendarType);
        } else {
            return oLocaleData.getCombinedDateTimePattern(sStyle, sStyle, sCalendarType);
        }
    },
    oRequiredParts: {
        'text': true,
        'year': true,
        'weekYear': true,
        'month': true,
        'day': true,
        'hour0_23': true,
        'hour1_24': true,
        'hour0_11': true,
        'hour1_12': true
    },
    aRelativeScales: [
        'year',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second'
    ],
    aRelativeParseScales: [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second'
    ],
    aIntervalCompareFields: [
        'FullYear',
        'Quarter',
        'Month',
        'Week',
        'Date',
        'DayPeriod',
        'Hours',
        'Minutes',
        'Seconds'
    ]
};
DateFormat.oTimeInfo = {
    oDefaultFormatOptions: {
        style: 'medium',
        relativeScale: 'auto',
        relativeStyle: 'wide'
    },
    aFallbackFormatOptions: [
        { style: 'short' },
        { style: 'medium' },
        { pattern: 'HH:mm:ss' },
        { pattern: 'HHmmss' }
    ],
    getPattern: function (oLocaleData, sStyle, sCalendarType) {
        return oLocaleData.getTimePattern(sStyle, sCalendarType);
    },
    oRequiredParts: {
        'text': true,
        'hour0_23': true,
        'hour1_24': true,
        'hour0_11': true,
        'hour1_12': true
    },
    aRelativeScales: [
        'hour',
        'minute',
        'second'
    ],
    aRelativeParseScales: [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second'
    ],
    aIntervalCompareFields: [
        'DayPeriod',
        'Hours',
        'Minutes',
        'Seconds'
    ]
};
DateFormat.getInstance = function (oFormatOptions, oLocale) {
    return this.getDateInstance(oFormatOptions, oLocale);
};
DateFormat.getDateInstance = function (oFormatOptions, oLocale) {
    return this.createInstance(oFormatOptions, oLocale, this.oDateInfo);
};
DateFormat.getDateTimeInstance = function (oFormatOptions, oLocale) {
    return this.createInstance(oFormatOptions, oLocale, this.oDateTimeInfo);
};
DateFormat.getTimeInstance = function (oFormatOptions, oLocale) {
    return this.createInstance(oFormatOptions, oLocale, this.oTimeInfo);
};
function createIntervalPatternWithNormalConnector(oFormat) {
    var sPattern = oFormat.oLocaleData.getIntervalPattern('', oFormat.oFormatOptions.calendarType);
    sPattern = sPattern.replace(/[^\{\}01 ]/, '-');
    return sPattern.replace(/\{(0|1)\}/g, oFormat.oFormatOptions.pattern);
}
DateFormat.createInstance = function (oFormatOptions, oLocale, oInfo) {
    var oFormat = Object.create(this.prototype);
    if (oFormatOptions instanceof Locale) {
        oLocale = oFormatOptions;
        oFormatOptions = undefined;
    }
    if (!oLocale) {
        oLocale = sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale();
    }
    oFormat.oLocale = oLocale;
    oFormat.oLocaleData = LocaleData.getInstance(oLocale);
    oFormat.oFormatOptions = jQuery.extend(false, {}, oInfo.oDefaultFormatOptions, oFormatOptions);
    if (!oFormat.oFormatOptions.calendarType) {
        oFormat.oFormatOptions.calendarType = sap.ui.getCore().getConfiguration().getCalendarType();
    }
    if (!oFormat.oFormatOptions.pattern) {
        if (oFormat.oFormatOptions.format) {
            oFormat.oFormatOptions.pattern = oFormat.oLocaleData.getCustomDateTimePattern(oFormat.oFormatOptions.format, oFormat.oFormatOptions.calendarType);
        } else {
            oFormat.oFormatOptions.pattern = oInfo.getPattern(oFormat.oLocaleData, oFormat.oFormatOptions.style, oFormat.oFormatOptions.calendarType);
        }
    }
    if (oFormat.oFormatOptions.interval) {
        if (oFormat.oFormatOptions.format) {
            oFormat.intervalPatterns = oFormat.oLocaleData.getCustomIntervalPattern(oFormat.oFormatOptions.format, null, oFormat.oFormatOptions.calendarType);
            if (typeof oFormat.intervalPatterns === 'string') {
                oFormat.intervalPatterns = [oFormat.intervalPatterns];
            }
            oFormat.intervalPatterns.push(oFormat.oLocaleData.getCustomDateTimePattern(oFormat.oFormatOptions.format, oFormat.oFormatOptions.calendarType));
        } else {
            oFormat.intervalPatterns = [
                oFormat.oLocaleData.getCombinedIntervalPattern(oFormat.oFormatOptions.pattern, oFormat.oFormatOptions.calendarType),
                oFormat.oFormatOptions.pattern
            ];
        }
        var sCommonConnectorPattern = createIntervalPatternWithNormalConnector(oFormat);
        oFormat.intervalPatterns.push(sCommonConnectorPattern);
    }
    if (!oFormat.oFormatOptions.fallback) {
        if (!oInfo.oFallbackFormats) {
            oInfo.oFallbackFormats = {};
        }
        var sLocale = oLocale.toString(), sCalendarType = oFormat.oFormatOptions.calendarType, sKey = sLocale + '-' + sCalendarType, sPattern, aFallbackFormatOptions;
        if (oFormat.oFormatOptions.pattern && oInfo.bPatternFallbackWithoutDelimiter) {
            sKey = sKey + '-' + oFormat.oFormatOptions.pattern;
        }
        if (oFormat.oFormatOptions.interval) {
            sKey = sKey + '-' + 'interval';
        }
        var oFallbackFormats = oInfo.oFallbackFormats[sKey] ? Object.assign({}, oInfo.oFallbackFormats[sKey]) : undefined;
        if (!oFallbackFormats) {
            aFallbackFormatOptions = oInfo.aFallbackFormatOptions;
            if (oInfo.bShortFallbackFormatOptions) {
                sPattern = oInfo.getPattern(oFormat.oLocaleData, 'short');
                aFallbackFormatOptions = aFallbackFormatOptions.concat(DateFormat._createFallbackOptionsWithoutDelimiter(sPattern));
            }
            if (oFormat.oFormatOptions.pattern && oInfo.bPatternFallbackWithoutDelimiter) {
                aFallbackFormatOptions = DateFormat._createFallbackOptionsWithoutDelimiter(oFormat.oFormatOptions.pattern).concat(aFallbackFormatOptions);
            }
            oFallbackFormats = DateFormat._createFallbackFormat(aFallbackFormatOptions, sCalendarType, oLocale, oInfo, oFormat.oFormatOptions.interval);
        }
        oFormat.aFallbackFormats = oFallbackFormats;
    }
    oFormat.oRequiredParts = oInfo.oRequiredParts;
    oFormat.aRelativeScales = oInfo.aRelativeScales;
    oFormat.aRelativeParseScales = oInfo.aRelativeParseScales;
    oFormat.aIntervalCompareFields = oInfo.aIntervalCompareFields;
    oFormat.init();
    return oFormat;
};
DateFormat.prototype.init = function () {
    var sCalendarType = this.oFormatOptions.calendarType;
    this.aMonthsAbbrev = this.oLocaleData.getMonths('abbreviated', sCalendarType);
    this.aMonthsWide = this.oLocaleData.getMonths('wide', sCalendarType);
    this.aMonthsNarrow = this.oLocaleData.getMonths('narrow', sCalendarType);
    this.aMonthsAbbrevSt = this.oLocaleData.getMonthsStandAlone('abbreviated', sCalendarType);
    this.aMonthsWideSt = this.oLocaleData.getMonthsStandAlone('wide', sCalendarType);
    this.aMonthsNarrowSt = this.oLocaleData.getMonthsStandAlone('narrow', sCalendarType);
    this.aDaysAbbrev = this.oLocaleData.getDays('abbreviated', sCalendarType);
    this.aDaysWide = this.oLocaleData.getDays('wide', sCalendarType);
    this.aDaysNarrow = this.oLocaleData.getDays('narrow', sCalendarType);
    this.aDaysShort = this.oLocaleData.getDays('short', sCalendarType);
    this.aDaysAbbrevSt = this.oLocaleData.getDaysStandAlone('abbreviated', sCalendarType);
    this.aDaysWideSt = this.oLocaleData.getDaysStandAlone('wide', sCalendarType);
    this.aDaysNarrowSt = this.oLocaleData.getDaysStandAlone('narrow', sCalendarType);
    this.aDaysShortSt = this.oLocaleData.getDaysStandAlone('short', sCalendarType);
    this.aQuartersAbbrev = this.oLocaleData.getQuarters('abbreviated', sCalendarType);
    this.aQuartersWide = this.oLocaleData.getQuarters('wide', sCalendarType);
    this.aQuartersNarrow = this.oLocaleData.getQuarters('narrow', sCalendarType);
    this.aQuartersAbbrevSt = this.oLocaleData.getQuartersStandAlone('abbreviated', sCalendarType);
    this.aQuartersWideSt = this.oLocaleData.getQuartersStandAlone('wide', sCalendarType);
    this.aQuartersNarrowSt = this.oLocaleData.getQuartersStandAlone('narrow', sCalendarType);
    this.aErasNarrow = this.oLocaleData.getEras('narrow', sCalendarType);
    this.aErasAbbrev = this.oLocaleData.getEras('abbreviated', sCalendarType);
    this.aErasWide = this.oLocaleData.getEras('wide', sCalendarType);
    this.aDayPeriods = this.oLocaleData.getDayPeriods('abbreviated', sCalendarType);
    this.aFormatArray = this.parseCldrDatePattern(this.oFormatOptions.pattern);
    this.sAllowedCharacters = this.getAllowedCharacters(this.aFormatArray);
};
DateFormat._createFallbackFormat = function (aFallbackFormatOptions, sCalendarType, oLocale, oInfo, bInterval) {
    return aFallbackFormatOptions.map(function (oOptions) {
        var oFormatOptions = Object.assign({}, oOptions);
        if (bInterval) {
            oFormatOptions.interval = true;
        }
        oFormatOptions.calendarType = sCalendarType;
        oFormatOptions.fallback = true;
        var oFallbackFormat = DateFormat.createInstance(oFormatOptions, oLocale, oInfo);
        oFallbackFormat.bIsFallback = true;
        return oFallbackFormat;
    });
};
DateFormat._createFallbackOptionsWithoutDelimiter = function (sBasePattern) {
    var rNonDateFields = /[^dMyGU]/g, oDayReplace = {
            regex: /d+/g,
            replace: 'dd'
        }, oMonthReplace = {
            regex: /M+/g,
            replace: 'MM'
        }, oYearReplace = {
            regex: /[yU]+/g,
            replace: [
                'yyyy',
                'yy'
            ]
        };
    sBasePattern = sBasePattern.replace(rNonDateFields, '');
    sBasePattern = sBasePattern.replace(oDayReplace.regex, oDayReplace.replace);
    sBasePattern = sBasePattern.replace(oMonthReplace.regex, oMonthReplace.replace);
    return oYearReplace.replace.map(function (sReplace) {
        return {
            pattern: sBasePattern.replace(oYearReplace.regex, sReplace),
            strictParsing: true
        };
    });
};
var oParseHelper = {
    isNumber: function (iCharCode) {
        return iCharCode >= 48 && iCharCode <= 57;
    },
    findNumbers: function (sValue, iMaxLength) {
        var iLength = 0;
        while (iLength < iMaxLength && this.isNumber(sValue.charCodeAt(iLength))) {
            iLength++;
        }
        if (typeof sValue !== 'string') {
            sValue = sValue.toString();
        }
        return sValue.substr(0, iLength);
    },
    findEntry: function (sValue, aList) {
        var iFoundIndex = -1, iMatchedLength = 0;
        for (var j = 0; j < aList.length; j++) {
            if (aList[j] && aList[j].length > iMatchedLength && sValue.indexOf(aList[j]) === 0) {
                iFoundIndex = j;
                iMatchedLength = aList[j].length;
            }
        }
        return {
            index: iFoundIndex,
            value: iFoundIndex === -1 ? null : aList[iFoundIndex]
        };
    },
    parseTZ: function (sValue, bISO) {
        var iLength = 0;
        var iTZFactor = sValue.charAt(0) == '+' ? -1 : 1;
        var sPart;
        iLength++;
        sPart = this.findNumbers(sValue.substr(iLength), 2);
        var iTZDiffHour = parseInt(sPart);
        iLength += 2;
        if (bISO) {
            iLength++;
        }
        sPart = this.findNumbers(sValue.substr(iLength), 2);
        iLength += 2;
        var iTZDiff = parseInt(sPart);
        return {
            length: iLength,
            tzDiff: (iTZDiff + 60 * iTZDiffHour) * iTZFactor
        };
    },
    checkValid: function (sType, bPartInvalid, oFormat) {
        if (sType in oFormat.oRequiredParts && bPartInvalid) {
            return false;
        }
    }
};
DateFormat.prototype.oSymbols = {
    '': {
        name: 'text',
        format: function (oField, oDate, bUTC, oFormat) {
            return oField.value;
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var sChar;
            var bValid = true;
            var iValueIndex = 0;
            var iPatternIndex = 0;
            for (; iPatternIndex < oPart.value.length; iPatternIndex++) {
                sChar = oPart.value.charAt(iPatternIndex);
                if (sChar !== ' ') {
                    if (sValue.charAt(iValueIndex) !== sChar) {
                        bValid = false;
                    }
                    iValueIndex++;
                } else {
                    while (sValue.charAt(iValueIndex) === ' ') {
                        iValueIndex++;
                    }
                }
                if (!bValid) {
                    break;
                }
            }
            if (bValid) {
                return { length: iValueIndex };
            } else {
                var bPartInvalid = false;
                if (oConfig.index < oConfig.formatArray.length - 1) {
                    bPartInvalid = oConfig.formatArray[oConfig.index + 1].type in oFormat.oRequiredParts;
                }
                return { valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat) };
            }
        }
    },
    'G': {
        name: 'era',
        format: function (oField, oDate, bUTC, oFormat) {
            var iEra = bUTC ? oDate.getUTCEra() : oDate.getEra();
            if (oField.digits <= 3) {
                return oFormat.aErasAbbrev[iEra];
            } else if (oField.digits === 4) {
                return oFormat.aErasWide[iEra];
            } else {
                return oFormat.aErasNarrow[iEra];
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var aErasVariants = [
                oFormat.aErasWide,
                oFormat.aErasAbbrev,
                oFormat.aErasNarrow
            ];
            for (var i = 0; i < aErasVariants.length; i++) {
                var aVariants = aErasVariants[i];
                var oFound = oParseHelper.findEntry(sValue, aVariants);
                if (oFound.index !== -1) {
                    return {
                        era: oFound.index,
                        length: oFound.value.length
                    };
                }
            }
            return {
                era: oFormat.aErasWide.length - 1,
                valid: oParseHelper.checkValid(oPart.type, true, oFormat)
            };
        }
    },
    'y': {
        name: 'year',
        format: function (oField, oDate, bUTC, oFormat) {
            var iYear = bUTC ? oDate.getUTCFullYear() : oDate.getFullYear();
            var sYear = String(iYear);
            var sCalendarType = oFormat.oFormatOptions.calendarType;
            if (oField.digits == 2 && sYear.length > 2) {
                sYear = sYear.substr(sYear.length - 2);
            }
            if (sCalendarType != CalendarType.Japanese && oField.digits == 1 && iYear < 100) {
                sYear = sYear.padStart(4, '0');
            }
            return sYear.padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var sCalendarType = oFormat.oFormatOptions.calendarType;
            var sPart;
            if (oPart.digits == 1) {
                sPart = oParseHelper.findNumbers(sValue, 4);
            } else if (oPart.digits == 2) {
                sPart = oParseHelper.findNumbers(sValue, 2);
            } else {
                sPart = oParseHelper.findNumbers(sValue, oPart.digits);
            }
            var iYear = parseInt(sPart);
            if (sCalendarType != CalendarType.Japanese && sPart.length <= 2) {
                var oCurrentDate = UniversalDate.getInstance(new Date(), sCalendarType), iCurrentYear = oCurrentDate.getFullYear(), iCurrentCentury = Math.floor(iCurrentYear / 100), iYearDiff = iCurrentCentury * 100 + iYear - iCurrentYear;
                if (iYearDiff < -70) {
                    iYear += (iCurrentCentury + 1) * 100;
                } else if (iYearDiff < 30) {
                    iYear += iCurrentCentury * 100;
                } else {
                    iYear += (iCurrentCentury - 1) * 100;
                }
            }
            return {
                length: sPart.length,
                valid: oParseHelper.checkValid(oPart.type, sPart === '', oFormat),
                year: iYear
            };
        }
    },
    'Y': {
        name: 'weekYear',
        format: function (oField, oDate, bUTC, oFormat) {
            var oWeek = bUTC ? oDate.getUTCWeek() : oDate.getWeek();
            var iWeekYear = oWeek.year;
            var sWeekYear = String(iWeekYear);
            var sCalendarType = oFormat.oFormatOptions.calendarType;
            if (oField.digits == 2 && sWeekYear.length > 2) {
                sWeekYear = sWeekYear.substr(sWeekYear.length - 2);
            }
            if (sCalendarType != CalendarType.Japanese && oField.digits == 1 && iWeekYear < 100) {
                sWeekYear = sWeekYear.padStart(4, '0');
            }
            return sWeekYear.padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var sCalendarType = oFormat.oFormatOptions.calendarType;
            var sPart;
            if (oPart.digits == 1) {
                sPart = oParseHelper.findNumbers(sValue, 4);
            } else if (oPart.digits == 2) {
                sPart = oParseHelper.findNumbers(sValue, 2);
            } else {
                sPart = oParseHelper.findNumbers(sValue, oPart.digits);
            }
            var iYear = parseInt(sPart);
            var iWeekYear;
            if (sCalendarType != CalendarType.Japanese && sPart.length <= 2) {
                var oCurrentDate = UniversalDate.getInstance(new Date(), sCalendarType), iCurrentYear = oCurrentDate.getFullYear(), iCurrentCentury = Math.floor(iCurrentYear / 100), iYearDiff = iCurrentCentury * 100 + iWeekYear - iCurrentYear;
                if (iYearDiff < -70) {
                    iWeekYear += (iCurrentCentury + 1) * 100;
                } else if (iYearDiff < 30) {
                    iWeekYear += iCurrentCentury * 100;
                } else {
                    iWeekYear += (iCurrentCentury - 1) * 100;
                }
            }
            return {
                length: sPart.length,
                valid: oParseHelper.checkValid(oPart.type, sPart === '', oFormat),
                year: iYear,
                weekYear: iWeekYear
            };
        }
    },
    'M': {
        name: 'month',
        format: function (oField, oDate, bUTC, oFormat) {
            var iMonth = bUTC ? oDate.getUTCMonth() : oDate.getMonth();
            if (oField.digits == 3) {
                return oFormat.aMonthsAbbrev[iMonth];
            } else if (oField.digits == 4) {
                return oFormat.aMonthsWide[iMonth];
            } else if (oField.digits > 4) {
                return oFormat.aMonthsNarrow[iMonth];
            } else {
                return String(iMonth + 1).padStart(oField.digits, '0');
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var aMonthsVariants = [
                oFormat.aMonthsWide,
                oFormat.aMonthsWideSt,
                oFormat.aMonthsAbbrev,
                oFormat.aMonthsAbbrevSt,
                oFormat.aMonthsNarrow,
                oFormat.aMonthsNarrowSt
            ];
            var bValid;
            var iMonth;
            var sPart;
            if (oPart.digits < 3) {
                sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
                bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
                iMonth = parseInt(sPart) - 1;
                if (oConfig.strict && (iMonth > 11 || iMonth < 0)) {
                    bValid = false;
                }
            } else {
                for (var i = 0; i < aMonthsVariants.length; i++) {
                    var aVariants = aMonthsVariants[i];
                    var oFound = oParseHelper.findEntry(sValue, aVariants);
                    if (oFound.index !== -1) {
                        return {
                            month: oFound.index,
                            length: oFound.value.length
                        };
                    }
                }
                bValid = oParseHelper.checkValid(oPart.type, true, oFormat);
            }
            return {
                month: iMonth,
                length: sPart ? sPart.length : 0,
                valid: bValid
            };
        }
    },
    'L': {
        name: 'monthStandalone',
        format: function (oField, oDate, bUTC, oFormat) {
            var iMonth = bUTC ? oDate.getUTCMonth() : oDate.getMonth();
            if (oField.digits == 3) {
                return oFormat.aMonthsAbbrevSt[iMonth];
            } else if (oField.digits == 4) {
                return oFormat.aMonthsWideSt[iMonth];
            } else if (oField.digits > 4) {
                return oFormat.aMonthsNarrowSt[iMonth];
            } else {
                return String(iMonth + 1).padStart(oField.digits, '0');
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var aMonthsVariants = [
                oFormat.aMonthsWide,
                oFormat.aMonthsWideSt,
                oFormat.aMonthsAbbrev,
                oFormat.aMonthsAbbrevSt,
                oFormat.aMonthsNarrow,
                oFormat.aMonthsNarrowSt
            ];
            var bValid;
            var iMonth;
            var sPart;
            if (oPart.digits < 3) {
                sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
                bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
                iMonth = parseInt(sPart) - 1;
                if (oConfig.strict && (iMonth > 11 || iMonth < 0)) {
                    bValid = false;
                }
            } else {
                for (var i = 0; i < aMonthsVariants.length; i++) {
                    var aVariants = aMonthsVariants[i];
                    var oFound = oParseHelper.findEntry(sValue, aVariants);
                    if (oFound.index !== -1) {
                        return {
                            month: oFound.index,
                            length: oFound.value.length
                        };
                    }
                }
                bValid = oParseHelper.checkValid(oPart.type, true, oFormat);
            }
            return {
                month: iMonth,
                length: sPart ? sPart.length : 0,
                valid: bValid
            };
        }
    },
    'w': {
        name: 'weekInYear',
        format: function (oField, oDate, bUTC, oFormat) {
            var oWeek = bUTC ? oDate.getUTCWeek() : oDate.getWeek();
            var iWeek = oWeek.week;
            var sWeek = String(iWeek + 1);
            if (oField.digits < 3) {
                sWeek = sWeek.padStart(oField.digits, '0');
            } else {
                sWeek = oFormat.oLocaleData.getCalendarWeek(oField.digits === 3 ? 'narrow' : 'wide', sWeek.padStart(2, '0'));
            }
            return sWeek;
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var sPart;
            var iWeek;
            var iLength = 0;
            if (oPart.digits < 3) {
                sPart = oParseHelper.findNumbers(sValue, 2);
                iLength = sPart.length;
                iWeek = parseInt(sPart) - 1;
                bValid = oParseHelper.checkValid(oPart.type, !sPart, oFormat);
            } else {
                sPart = oFormat.oLocaleData.getCalendarWeek(oPart.digits === 3 ? 'narrow' : 'wide');
                sPart = sPart.replace('{0}', '[0-9]+');
                var rWeekNumber = new RegExp(sPart), oResult = rWeekNumber.exec(sValue);
                if (oResult) {
                    iLength = oResult[0].length;
                    iWeek = parseInt(oResult[0]) - 1;
                } else {
                    bValid = oParseHelper.checkValid(oPart.type, true, oFormat);
                }
            }
            return {
                length: iLength,
                valid: bValid,
                week: iWeek
            };
        }
    },
    'W': {
        name: 'weekInMonth',
        format: function (oField, oDate, bUTC, oFormat) {
            return '';
        },
        parse: function () {
            return {};
        }
    },
    'D': {
        name: 'dayInYear',
        format: function (oField, oDate, bUTC, oFormat) {
        },
        parse: function () {
            return {};
        }
    },
    'd': {
        name: 'day',
        format: function (oField, oDate, bUTC, oFormat) {
            var iDate = bUTC ? oDate.getUTCDate() : oDate.getDate();
            return String(iDate).padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            var iDay = parseInt(sPart);
            if (oConfig.strict && (iDay > 31 || iDay < 1)) {
                bValid = false;
            }
            return {
                day: iDay,
                length: sPart.length,
                valid: bValid
            };
        }
    },
    'Q': {
        name: 'quarter',
        format: function (oField, oDate, bUTC, oFormat) {
            var iQuarter = bUTC ? oDate.getUTCQuarter() : oDate.getQuarter();
            if (oField.digits == 3) {
                return oFormat.aQuartersAbbrev[iQuarter];
            } else if (oField.digits == 4) {
                return oFormat.aQuartersWide[iQuarter];
            } else if (oField.digits > 4) {
                return oFormat.aQuartersNarrow[iQuarter];
            } else {
                return String(iQuarter + 1).padStart(oField.digits, '0');
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var iQuarter;
            var sPart;
            var aQuartersVariants = [
                oFormat.aQuartersWide,
                oFormat.aQuartersWideSt,
                oFormat.aQuartersAbbrev,
                oFormat.aQuartersAbbrevSt,
                oFormat.aQuartersNarrow,
                oFormat.aQuartersNarrowSt
            ];
            if (oPart.digits < 3) {
                sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
                bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
                iQuarter = parseInt(sPart) - 1;
                if (oConfig.strict && iQuarter > 3) {
                    bValid = false;
                }
            } else {
                for (var i = 0; i < aQuartersVariants.length; i++) {
                    var aVariants = aQuartersVariants[i];
                    var oFound = oParseHelper.findEntry(sValue, aVariants);
                    if (oFound.index !== -1) {
                        return {
                            quarter: oFound.index,
                            length: oFound.value.length
                        };
                    }
                }
                bValid = oParseHelper.checkValid(oPart.type, true, oFormat);
            }
            return {
                length: sPart ? sPart.length : 0,
                quarter: iQuarter,
                valid: bValid
            };
        }
    },
    'q': {
        name: 'quarterStandalone',
        format: function (oField, oDate, bUTC, oFormat) {
            var iQuarter = bUTC ? oDate.getUTCQuarter() : oDate.getQuarter();
            if (oField.digits == 3) {
                return oFormat.aQuartersAbbrevSt[iQuarter];
            } else if (oField.digits == 4) {
                return oFormat.aQuartersWideSt[iQuarter];
            } else if (oField.digits > 4) {
                return oFormat.aQuartersNarrowSt[iQuarter];
            } else {
                return String(iQuarter + 1).padStart(oField.digits, '0');
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var iQuarter;
            var sPart;
            var aQuartersVariants = [
                oFormat.aQuartersWide,
                oFormat.aQuartersWideSt,
                oFormat.aQuartersAbbrev,
                oFormat.aQuartersAbbrevSt,
                oFormat.aQuartersNarrow,
                oFormat.aQuartersNarrowSt
            ];
            if (oPart.digits < 3) {
                sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
                bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
                iQuarter = parseInt(sPart) - 1;
                if (oConfig.strict && iQuarter > 3) {
                    bValid = false;
                }
            } else {
                for (var i = 0; i < aQuartersVariants.length; i++) {
                    var aVariants = aQuartersVariants[i];
                    var oFound = oParseHelper.findEntry(sValue, aVariants);
                    if (oFound.index !== -1) {
                        return {
                            quarter: oFound.index,
                            length: oFound.value.length
                        };
                    }
                }
                bValid = oParseHelper.checkValid(oPart.type, true, oFormat);
            }
            return {
                length: sPart ? sPart.length : 0,
                quarter: iQuarter,
                valid: bValid
            };
        }
    },
    'F': {
        name: 'dayOfWeekInMonth',
        format: function (oField, oDate, bUTC, oFormat) {
            return '';
        },
        parse: function () {
            return {};
        }
    },
    'E': {
        name: 'dayNameInWeek',
        format: function (oField, oDate, bUTC, oFormat) {
            var iDay = bUTC ? oDate.getUTCDay() : oDate.getDay();
            if (oField.digits < 4) {
                return oFormat.aDaysAbbrev[iDay];
            } else if (oField.digits == 4) {
                return oFormat.aDaysWide[iDay];
            } else if (oField.digits == 5) {
                return oFormat.aDaysNarrow[iDay];
            } else {
                return oFormat.aDaysShort[iDay];
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var aDaysVariants = [
                oFormat.aDaysWide,
                oFormat.aDaysWideSt,
                oFormat.aDaysAbbrev,
                oFormat.aDaysAbbrevSt,
                oFormat.aDaysShort,
                oFormat.aDaysShortSt,
                oFormat.aDaysNarrow,
                oFormat.aDaysNarrowSt
            ];
            for (var i = 0; i < aDaysVariants.length; i++) {
                var aVariants = aDaysVariants[i];
                var oFound = oParseHelper.findEntry(sValue, aVariants);
                if (oFound.index !== -1) {
                    return {
                        dayOfWeek: oFound.index,
                        length: oFound.value.length
                    };
                }
            }
        }
    },
    'c': {
        name: 'dayNameInWeekStandalone',
        format: function (oField, oDate, bUTC, oFormat) {
            var iDay = bUTC ? oDate.getUTCDay() : oDate.getDay();
            if (oField.digits < 4) {
                return oFormat.aDaysAbbrevSt[iDay];
            } else if (oField.digits == 4) {
                return oFormat.aDaysWideSt[iDay];
            } else if (oField.digits == 5) {
                return oFormat.aDaysNarrowSt[iDay];
            } else {
                return oFormat.aDaysShortSt[iDay];
            }
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var aDaysVariants = [
                oFormat.aDaysWide,
                oFormat.aDaysWideSt,
                oFormat.aDaysAbbrev,
                oFormat.aDaysAbbrevSt,
                oFormat.aDaysShort,
                oFormat.aDaysShortSt,
                oFormat.aDaysNarrow,
                oFormat.aDaysNarrowSt
            ];
            for (var i = 0; i < aDaysVariants.length; i++) {
                var aVariants = aDaysVariants[i];
                var oFound = oParseHelper.findEntry(sValue, aVariants);
                if (oFound.index !== -1) {
                    return {
                        day: oFound.index,
                        length: oFound.value.length
                    };
                }
            }
        }
    },
    'u': {
        name: 'dayNumberOfWeek',
        format: function (oField, oDate, bUTC, oFormat) {
            var iDay = bUTC ? oDate.getUTCDay() : oDate.getDay();
            return oFormat._adaptDayOfWeek(iDay);
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var sPart = oParseHelper.findNumbers(sValue, oPart.digits);
            return {
                dayNumberOfWeek: parseInt(sPart),
                length: sPart.length
            };
        }
    },
    'a': {
        name: 'amPmMarker',
        format: function (oField, oDate, bUTC, oFormat) {
            var iDayPeriod = bUTC ? oDate.getUTCDayPeriod() : oDate.getDayPeriod();
            return oFormat.aDayPeriods[iDayPeriod];
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bPM;
            var iLength;
            var sAM = oFormat.aDayPeriods[0], sPM = oFormat.aDayPeriods[1];
            var rAMPM = /[aApP](?:\.)?[mM](?:\.)?/;
            var aMatch = sValue.match(rAMPM);
            var bVariant = aMatch && aMatch.index === 0;
            if (bVariant) {
                sValue = aMatch[0].replace(/\./g, '').toLowerCase() + sValue.substring(aMatch[0].length);
                sAM = sAM.toLowerCase();
                sPM = sPM.toLowerCase();
            }
            if (sValue.indexOf(sAM) === 0) {
                bPM = false;
                iLength = bVariant ? aMatch[0].length : sAM.length;
            } else if (sValue.indexOf(sPM) === 0) {
                bPM = true;
                iLength = bVariant ? aMatch[0].length : sPM.length;
            }
            return {
                pm: bPM,
                length: iLength
            };
        }
    },
    'H': {
        name: 'hour0_23',
        format: function (oField, oDate, bUTC, oFormat) {
            var iHours = bUTC ? oDate.getUTCHours() : oDate.getHours();
            return String(iHours).padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var iHours = parseInt(sPart);
            bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            if (oConfig.strict && iHours > 23) {
                bValid = false;
            }
            return {
                hour: iHours,
                length: sPart.length,
                valid: bValid
            };
        }
    },
    'k': {
        name: 'hour1_24',
        format: function (oField, oDate, bUTC, oFormat) {
            var iHours = bUTC ? oDate.getUTCHours() : oDate.getHours();
            var sHours = iHours === 0 ? '24' : String(iHours);
            return sHours.padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var iHours = parseInt(sPart);
            bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            if (iHours == 24) {
                iHours = 0;
            }
            if (oConfig.strict && iHours > 23) {
                bValid = false;
            }
            return {
                hour: iHours,
                length: sPart.length,
                valid: bValid
            };
        }
    },
    'K': {
        name: 'hour0_11',
        format: function (oField, oDate, bUTC, oFormat) {
            var iHours = bUTC ? oDate.getUTCHours() : oDate.getHours();
            var sHours = String(iHours > 11 ? iHours - 12 : iHours);
            return sHours.padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var iHours = parseInt(sPart);
            bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            if (oConfig.strict && iHours > 11) {
                bValid = false;
            }
            return {
                hour: iHours,
                length: sPart.length,
                valid: bValid
            };
        }
    },
    'h': {
        name: 'hour1_12',
        format: function (oField, oDate, bUTC, oFormat) {
            var iHours = bUTC ? oDate.getUTCHours() : oDate.getHours();
            var sHours;
            if (iHours > 12) {
                sHours = String(iHours - 12);
            } else if (iHours == 0) {
                sHours = '12';
            } else {
                sHours = String(iHours);
            }
            return sHours.padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bPM = oConfig.dateValue.pm;
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var iHours = parseInt(sPart);
            var bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            if (iHours == 12) {
                iHours = 0;
                bPM = bPM === undefined ? true : bPM;
            }
            if (oConfig.strict && iHours > 11) {
                bValid = false;
            }
            return {
                hour: iHours,
                length: sPart.length,
                pm: bPM,
                valid: bValid
            };
        }
    },
    'm': {
        name: 'minute',
        format: function (oField, oDate, bUTC, oFormat) {
            var iMinutes = bUTC ? oDate.getUTCMinutes() : oDate.getMinutes();
            return String(iMinutes).padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var iMinutes = parseInt(sPart);
            bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            if (oConfig.strict && iMinutes > 59) {
                bValid = false;
            }
            return {
                length: sPart.length,
                minute: iMinutes,
                valid: bValid
            };
        }
    },
    's': {
        name: 'second',
        format: function (oField, oDate, bUTC, oFormat) {
            var iSeconds = bUTC ? oDate.getUTCSeconds() : oDate.getSeconds();
            return String(iSeconds).padStart(oField.digits, '0');
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var bValid;
            var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));
            var iSeconds = parseInt(sPart);
            bValid = oParseHelper.checkValid(oPart.type, sPart === '', oFormat);
            if (oConfig.strict && iSeconds > 59) {
                bValid = false;
            }
            return {
                length: sPart.length,
                second: iSeconds,
                valid: bValid
            };
        }
    },
    'S': {
        name: 'fractionalsecond',
        format: function (oField, oDate, bUTC, oFormat) {
            var iMilliseconds = bUTC ? oDate.getUTCMilliseconds() : oDate.getMilliseconds();
            var sMilliseconds = String(iMilliseconds);
            var sFractionalseconds = sMilliseconds.padStart(3, '0');
            sFractionalseconds = sFractionalseconds.substr(0, oField.digits);
            sFractionalseconds = sFractionalseconds.padEnd(oField.digits, '0');
            return sFractionalseconds;
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var sPart = oParseHelper.findNumbers(sValue, oPart.digits);
            var iLength = sPart.length;
            sPart = sPart.substr(0, 3);
            sPart = sPart.padEnd(3, '0');
            var iMilliseconds = parseInt(sPart);
            return {
                length: iLength,
                millisecond: iMilliseconds
            };
        }
    },
    'z': {
        name: 'timezoneGeneral',
        format: function (oField, oDate, bUTC, oFormat) {
            if (oField.digits > 3 && oDate.getTimezoneLong()) {
                return oDate.getTimezoneLong();
            } else if (oDate.getTimezoneShort()) {
                return oDate.getTimezoneShort();
            }
            var sTimeZone = 'GMT';
            var iTZOffset = Math.abs(oDate.getTimezoneOffset());
            var bPositiveOffset = oDate.getTimezoneOffset() > 0;
            var iHourOffset = Math.floor(iTZOffset / 60);
            var iMinuteOffset = iTZOffset % 60;
            if (!bUTC && iTZOffset != 0) {
                sTimeZone += bPositiveOffset ? '-' : '+';
                sTimeZone += String(iHourOffset).padStart(2, '0');
                sTimeZone += ':';
                sTimeZone += String(iMinuteOffset).padStart(2, '0');
            } else {
                sTimeZone += 'Z';
            }
            return sTimeZone;
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            var iLength = 0;
            var iTZDiff;
            var oTZ = sValue.substring(0, 3);
            if (oTZ === 'GMT' || oTZ === 'UTC') {
                iLength = 3;
            } else if (sValue.substring(0, 2) === 'UT') {
                iLength = 2;
            } else if (sValue.charAt(0) == 'Z') {
                iLength = 1;
                iTZDiff = 0;
            } else {
                return { error: 'cannot be parsed correcly by sap.ui.core.format.DateFormat: The given timezone is not supported!' };
            }
            if (sValue.charAt(0) != 'Z') {
                var oParsedTZ = oParseHelper.parseTZ(sValue.substr(iLength), true);
                iLength += oParsedTZ.length;
                iTZDiff = oParsedTZ.tzDiff;
            }
            return {
                length: iLength,
                tzDiff: iTZDiff
            };
        }
    },
    'Z': {
        name: 'timezoneRFC822',
        format: function (oField, oDate, bUTC, oFormat) {
            var iTZOffset = Math.abs(oDate.getTimezoneOffset());
            var bPositiveOffset = oDate.getTimezoneOffset() > 0;
            var iHourOffset = Math.floor(iTZOffset / 60);
            var iMinuteOffset = iTZOffset % 60;
            var sTimeZone = '';
            if (!bUTC && iTZOffset != 0) {
                sTimeZone += bPositiveOffset ? '-' : '+';
                sTimeZone += String(iHourOffset).padStart(2, '0');
                sTimeZone += String(iMinuteOffset).padStart(2, '0');
            }
            return sTimeZone;
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            return oParseHelper.parseTZ(sValue, false);
        }
    },
    'X': {
        name: 'timezoneISO8601',
        format: function (oField, oDate, bUTC, oFormat) {
            var iTZOffset = Math.abs(oDate.getTimezoneOffset());
            var bPositiveOffset = oDate.getTimezoneOffset() > 0;
            var iHourOffset = Math.floor(iTZOffset / 60);
            var iMinuteOffset = iTZOffset % 60;
            var sTimeZone = '';
            if (!bUTC && iTZOffset != 0) {
                sTimeZone += bPositiveOffset ? '-' : '+';
                sTimeZone += String(iHourOffset).padStart(2, '0');
                sTimeZone += ':';
                sTimeZone += String(iMinuteOffset).padStart(2, '0');
            } else {
                sTimeZone += 'Z';
            }
            return sTimeZone;
        },
        parse: function (sValue, oPart, oFormat, oConfig) {
            if (sValue.charAt(0) == 'Z') {
                return {
                    length: 1,
                    tzDiff: 0
                };
            } else {
                return oParseHelper.parseTZ(sValue, true);
            }
        }
    }
};
DateFormat.prototype._format = function (oJSDate, bUTC) {
    if (this.oFormatOptions.relative) {
        var sRes = this.formatRelative(oJSDate, bUTC, this.oFormatOptions.relativeRange);
        if (sRes) {
            return sRes;
        }
    }
    var sCalendarType = this.oFormatOptions.calendarType;
    var oDate = UniversalDate.getInstance(oJSDate, sCalendarType);
    var aBuffer = [], oPart, sResult, sSymbol;
    for (var i = 0; i < this.aFormatArray.length; i++) {
        oPart = this.aFormatArray[i];
        sSymbol = oPart.symbol || '';
        aBuffer.push(this.oSymbols[sSymbol].format(oPart, oDate, bUTC, this));
    }
    sResult = aBuffer.join('');
    if (sap.ui.getCore().getConfiguration().getOriginInfo()) {
        sResult = new String(sResult);
        sResult.originInfo = {
            source: 'Common Locale Data Repository',
            locale: this.oLocale.toString(),
            style: this.oFormatOptions.style,
            pattern: this.oFormatOptions.pattern
        };
    }
    return sResult;
};
DateFormat.prototype.format = function (vJSDate, bUTC) {
    if (bUTC === undefined) {
        bUTC = this.oFormatOptions.UTC;
    }
    if (Array.isArray(vJSDate)) {
        if (!this.oFormatOptions.interval) {
            Log.error('Non-interval DateFormat can\'t format more than one date instance.');
            return '';
        }
        if (vJSDate.length !== 2) {
            Log.error('Interval DateFormat can only format with 2 date instances but ' + vJSDate.length + ' is given.');
            return '';
        }
        var bValid = vJSDate.every(function (oJSDate) {
            return oJSDate && !isNaN(oJSDate.getTime());
        });
        if (!bValid) {
            Log.error('At least one date instance which is passed to the interval DateFormat isn\'t valid.');
            return '';
        }
        return this._formatInterval(vJSDate, bUTC);
    } else {
        if (!vJSDate || isNaN(vJSDate.getTime())) {
            Log.error('The given date instance isn\'t valid.');
            return '';
        }
        if (this.oFormatOptions.interval) {
            Log.error('Interval DateFormat expects an array with two dates for the first argument but only one date is given.');
            return '';
        }
        return this._format(vJSDate, bUTC);
    }
};
DateFormat.prototype._formatInterval = function (aJSDates, bUTC) {
    var sCalendarType = this.oFormatOptions.calendarType;
    var oFromDate = UniversalDate.getInstance(aJSDates[0], sCalendarType);
    var oToDate = UniversalDate.getInstance(aJSDates[1], sCalendarType);
    var oDate;
    var oPart;
    var sSymbol;
    var aBuffer = [];
    var sPattern;
    var oDiffField = this._getGreatestDiffField([
        oFromDate,
        oToDate
    ], bUTC);
    if (!oDiffField) {
        return this._format(aJSDates[0], bUTC);
    }
    if (this.oFormatOptions.format) {
        sPattern = this.oLocaleData.getCustomIntervalPattern(this.oFormatOptions.format, oDiffField, sCalendarType);
    } else {
        sPattern = this.oLocaleData.getCombinedIntervalPattern(this.oFormatOptions.pattern, sCalendarType);
    }
    this.aFormatArray = this.parseCldrDatePattern(sPattern);
    oDate = oFromDate;
    for (var i = 0; i < this.aFormatArray.length; i++) {
        oPart = this.aFormatArray[i];
        sSymbol = oPart.symbol || '';
        if (oPart.repeat) {
            oDate = oToDate;
        }
        aBuffer.push(this.oSymbols[sSymbol].format(oPart, oDate, bUTC, this));
    }
    return aBuffer.join('');
};
var mFieldToGroup = {
    FullYear: 'Year',
    Quarter: 'Quarter',
    Month: 'Month',
    Week: 'Week',
    Date: 'Day',
    DayPeriod: 'DayPeriod',
    Hours: 'Hour',
    Minutes: 'Minute',
    Seconds: 'Second'
};
DateFormat.prototype._getGreatestDiffField = function (aDates, bUTC) {
    var bDiffFound = false, mDiff = {};
    this.aIntervalCompareFields.forEach(function (sField) {
        var sGetterPrefix = 'get' + (bUTC ? 'UTC' : ''), sMethodName = sGetterPrefix + sField, sFieldGroup = mFieldToGroup[sField], vFromValue = aDates[0][sMethodName].apply(aDates[0]), vToValue = aDates[1][sMethodName].apply(aDates[1]);
        if (!fnEqual(vFromValue, vToValue)) {
            bDiffFound = true;
            mDiff[sFieldGroup] = true;
        }
    });
    if (bDiffFound) {
        return mDiff;
    }
    return null;
};
DateFormat.prototype._parse = function (sValue, aFormatArray, bUTC, bStrict) {
    var iIndex = 0, oPart, sSubValue, oResult;
    var oDateValue = { valid: true };
    var oParseConf = {
        formatArray: aFormatArray,
        dateValue: oDateValue,
        strict: bStrict
    };
    for (var i = 0; i < aFormatArray.length; i++) {
        sSubValue = sValue.substr(iIndex);
        oPart = aFormatArray[i];
        oParseConf.index = i;
        oResult = this.oSymbols[oPart.symbol || ''].parse(sSubValue, oPart, this, oParseConf) || {};
        oDateValue = jQuery.extend(oDateValue, oResult);
        if (oResult.valid === false) {
            break;
        }
        iIndex += oResult.length || 0;
    }
    oDateValue.index = iIndex;
    if (oDateValue.pm) {
        oDateValue.hour += 12;
    }
    if (oDateValue.dayNumberOfWeek === undefined && oDateValue.dayOfWeek !== undefined) {
        oDateValue.dayNumberOfWeek = this._adaptDayOfWeek(oDateValue.dayOfWeek);
    }
    if (oDateValue.quarter !== undefined && oDateValue.month === undefined && oDateValue.day === undefined) {
        oDateValue.month = 3 * oDateValue.quarter;
        oDateValue.day = 1;
    }
    return oDateValue;
};
DateFormat.prototype._parseInterval = function (sValue, sCalendarType, bUTC, bStrict) {
    var aDateValues, iRepeat, oDateValue;
    this.intervalPatterns.some(function (sPattern) {
        var aFormatArray = this.parseCldrDatePattern(sPattern);
        iRepeat = undefined;
        for (var i = 0; i < aFormatArray.length; i++) {
            if (aFormatArray[i].repeat) {
                iRepeat = i;
                break;
            }
        }
        if (iRepeat === undefined) {
            oDateValue = this._parse(sValue, aFormatArray, bUTC, bStrict);
            if (oDateValue.index === 0 || oDateValue.index < sValue.length) {
                oDateValue.valid = false;
            }
            if (oDateValue.valid === false) {
                return;
            }
            aDateValues = [
                oDateValue,
                oDateValue
            ];
            return true;
        } else {
            aDateValues = [];
            oDateValue = this._parse(sValue, aFormatArray.slice(0, iRepeat), bUTC, bStrict);
            if (oDateValue.valid === false) {
                return;
            }
            aDateValues.push(oDateValue);
            var iLength = oDateValue.index;
            oDateValue = this._parse(sValue.substring(iLength), aFormatArray.slice(iRepeat), bUTC, bStrict);
            if (oDateValue.index === 0 || oDateValue.index + iLength < sValue.length) {
                oDateValue.valid = false;
            }
            if (oDateValue.valid === false) {
                return;
            }
            aDateValues.push(oDateValue);
            return true;
        }
    }.bind(this));
    return aDateValues;
};
var fnCreateDate = function (oDateValue, sCalendarType, bUTC, bStrict) {
    var oDate, iYear = typeof oDateValue.year === 'number' ? oDateValue.year : 1970;
    if (oDateValue.valid) {
        if (bUTC || oDateValue.tzDiff !== undefined) {
            oDate = UniversalDate.getInstance(new Date(0), sCalendarType);
            oDate.setUTCEra(oDateValue.era || UniversalDate.getCurrentEra(sCalendarType));
            oDate.setUTCFullYear(iYear);
            oDate.setUTCMonth(oDateValue.month || 0);
            oDate.setUTCDate(oDateValue.day || 1);
            oDate.setUTCHours(oDateValue.hour || 0);
            oDate.setUTCMinutes(oDateValue.minute || 0);
            oDate.setUTCSeconds(oDateValue.second || 0);
            oDate.setUTCMilliseconds(oDateValue.millisecond || 0);
            if (bStrict && (oDateValue.day || 1) !== oDate.getUTCDate()) {
                oDateValue.valid = false;
                oDate = undefined;
            } else {
                if (oDateValue.tzDiff) {
                    oDate.setUTCMinutes((oDateValue.minute || 0) + oDateValue.tzDiff);
                }
                if (oDateValue.week !== undefined && (oDateValue.month === undefined || oDateValue.day === undefined)) {
                    oDate.setUTCWeek({
                        year: oDateValue.weekYear || oDateValue.year,
                        week: oDateValue.week
                    });
                    if (oDateValue.dayNumberOfWeek !== undefined) {
                        oDate.setUTCDate(oDate.getUTCDate() + oDateValue.dayNumberOfWeek - 1);
                    }
                }
            }
        } else {
            oDate = UniversalDate.getInstance(new Date(1970, 0, 1, 0, 0, 0), sCalendarType);
            oDate.setEra(oDateValue.era || UniversalDate.getCurrentEra(sCalendarType));
            oDate.setFullYear(iYear);
            oDate.setMonth(oDateValue.month || 0);
            oDate.setDate(oDateValue.day || 1);
            oDate.setHours(oDateValue.hour || 0);
            oDate.setMinutes(oDateValue.minute || 0);
            oDate.setSeconds(oDateValue.second || 0);
            oDate.setMilliseconds(oDateValue.millisecond || 0);
            if (bStrict && (oDateValue.day || 1) !== oDate.getDate()) {
                oDateValue.valid = false;
                oDate = undefined;
            } else if (oDateValue.week !== undefined && (oDateValue.month === undefined || oDateValue.day === undefined)) {
                oDate.setWeek({
                    year: oDateValue.weekYear || oDateValue.year,
                    week: oDateValue.week
                });
                if (oDateValue.dayNumberOfWeek !== undefined) {
                    oDate.setDate(oDate.getDate() + oDateValue.dayNumberOfWeek - 1);
                }
            }
        }
        if (oDateValue.valid) {
            oDate = oDate.getJSDate();
            return oDate;
        }
    }
    return null;
};
function mergeWithoutOverwrite(object1, object2) {
    if (object1 === object2) {
        return object1;
    }
    var oMergedObject = {};
    Object.keys(object1).forEach(function (sKey) {
        oMergedObject[sKey] = object1[sKey];
    });
    Object.keys(object2).forEach(function (sKey) {
        if (!oMergedObject.hasOwnProperty(sKey)) {
            oMergedObject[sKey] = object2[sKey];
        }
    });
    return oMergedObject;
}
DateFormat.prototype.parse = function (sValue, bUTC, bStrict) {
    sValue = jQuery.trim(sValue);
    var oDateValue;
    var sCalendarType = this.oFormatOptions.calendarType;
    if (bUTC === undefined) {
        bUTC = this.oFormatOptions.UTC;
    }
    if (bStrict === undefined) {
        bStrict = this.oFormatOptions.strictParsing;
    }
    if (!this.oFormatOptions.interval) {
        var oJSDate = this.parseRelative(sValue, bUTC);
        if (oJSDate) {
            return oJSDate;
        }
        oDateValue = this._parse(sValue, this.aFormatArray, bUTC, bStrict);
        if (oDateValue.index === 0 || oDateValue.index < sValue.length) {
            oDateValue.valid = false;
        }
        oJSDate = fnCreateDate(oDateValue, sCalendarType, bUTC, bStrict);
        if (oJSDate) {
            return oJSDate;
        }
    } else {
        var aDateValues = this._parseInterval(sValue, sCalendarType, bUTC, bStrict);
        var oJSDate1, oJSDate2;
        if (aDateValues && aDateValues.length == 2) {
            var oDateValue1 = mergeWithoutOverwrite(aDateValues[0], aDateValues[1]);
            var oDateValue2 = mergeWithoutOverwrite(aDateValues[1], aDateValues[0]);
            oJSDate1 = fnCreateDate(oDateValue1, sCalendarType, bUTC, bStrict);
            oJSDate2 = fnCreateDate(oDateValue2, sCalendarType, bUTC, bStrict);
            if (oJSDate1 && oJSDate2) {
                return [
                    oJSDate1,
                    oJSDate2
                ];
            }
        }
    }
    if (!this.bIsFallback) {
        var vDate;
        this.aFallbackFormats.every(function (oFallbackFormat) {
            vDate = oFallbackFormat.parse(sValue, bUTC, bStrict);
            if (Array.isArray(vDate)) {
                return !(vDate[0] && vDate[1]);
            } else {
                return !vDate;
            }
        });
        return vDate;
    }
    if (!this.oFormatOptions.interval) {
        return null;
    } else {
        return [
            null,
            null
        ];
    }
};
DateFormat.prototype.parseCldrDatePattern = function (sPattern) {
    if (mCldrDatePattern[sPattern]) {
        return mCldrDatePattern[sPattern];
    }
    var aFormatArray = [], i, bQuoted = false, oCurrentObject = null, sState = '', sNewState = '', mAppeared = {}, bIntervalStartFound = false;
    for (i = 0; i < sPattern.length; i++) {
        var sCurChar = sPattern.charAt(i), sNextChar, sPrevChar, sPrevPrevChar;
        if (bQuoted) {
            if (sCurChar == '\'') {
                sPrevChar = sPattern.charAt(i - 1);
                sPrevPrevChar = sPattern.charAt(i - 2);
                sNextChar = sPattern.charAt(i + 1);
                if (sPrevChar == '\'' && sPrevPrevChar != '\'') {
                    bQuoted = false;
                } else if (sNextChar == '\'') {
                    i += 1;
                } else {
                    bQuoted = false;
                    continue;
                }
            }
            if (sState == 'text') {
                oCurrentObject.value += sCurChar;
            } else {
                oCurrentObject = {
                    type: 'text',
                    value: sCurChar
                };
                aFormatArray.push(oCurrentObject);
                sState = 'text';
            }
        } else {
            if (sCurChar == '\'') {
                bQuoted = true;
            } else if (this.oSymbols[sCurChar]) {
                sNewState = this.oSymbols[sCurChar].name;
                if (sState == sNewState) {
                    oCurrentObject.digits++;
                } else {
                    oCurrentObject = {
                        type: sNewState,
                        symbol: sCurChar,
                        digits: 1
                    };
                    aFormatArray.push(oCurrentObject);
                    sState = sNewState;
                    if (!bIntervalStartFound) {
                        if (mAppeared[sNewState]) {
                            oCurrentObject.repeat = true;
                            bIntervalStartFound = true;
                        } else {
                            mAppeared[sNewState] = true;
                        }
                    }
                }
            } else {
                if (sState == 'text') {
                    oCurrentObject.value += sCurChar;
                } else {
                    oCurrentObject = {
                        type: 'text',
                        value: sCurChar
                    };
                    aFormatArray.push(oCurrentObject);
                    sState = 'text';
                }
            }
        }
    }
    mCldrDatePattern[sPattern] = aFormatArray;
    return aFormatArray;
};
DateFormat.prototype.parseRelative = function (sValue, bUTC) {
    var aPatterns, oEntry, rPattern, oResult, iValue;
    if (!sValue) {
        return null;
    }
    aPatterns = this.oLocaleData.getRelativePatterns(this.aRelativeParseScales, this.oFormatOptions.relativeStyle);
    for (var i = 0; i < aPatterns.length; i++) {
        oEntry = aPatterns[i];
        rPattern = new RegExp('^\\s*' + oEntry.pattern.replace(/\{0\}/, '(\\d+)') + '\\s*$', 'i');
        oResult = rPattern.exec(sValue);
        if (oResult) {
            if (oEntry.value !== undefined) {
                return computeRelativeDate(oEntry.value, oEntry.scale);
            } else {
                iValue = parseInt(oResult[1]);
                return computeRelativeDate(iValue * oEntry.sign, oEntry.scale);
            }
        }
    }
    function computeRelativeDate(iDiff, sScale) {
        var iToday, oToday = new Date(), oJSDate;
        if (bUTC) {
            iToday = oToday.getTime();
        } else {
            iToday = Date.UTC(oToday.getFullYear(), oToday.getMonth(), oToday.getDate(), oToday.getHours(), oToday.getMinutes(), oToday.getSeconds(), oToday.getMilliseconds());
        }
        oJSDate = new Date(iToday);
        switch (sScale) {
        case 'second':
            oJSDate.setUTCSeconds(oJSDate.getUTCSeconds() + iDiff);
            break;
        case 'minute':
            oJSDate.setUTCMinutes(oJSDate.getUTCMinutes() + iDiff);
            break;
        case 'hour':
            oJSDate.setUTCHours(oJSDate.getUTCHours() + iDiff);
            break;
        case 'day':
            oJSDate.setUTCDate(oJSDate.getUTCDate() + iDiff);
            break;
        case 'week':
            oJSDate.setUTCDate(oJSDate.getUTCDate() + iDiff * 7);
            break;
        case 'month':
            oJSDate.setUTCMonth(oJSDate.getUTCMonth() + iDiff);
            break;
        case 'quarter':
            oJSDate.setUTCMonth(oJSDate.getUTCMonth() + iDiff * 3);
            break;
        case 'year':
            oJSDate.setUTCFullYear(oJSDate.getUTCFullYear() + iDiff);
            break;
        }
        if (bUTC) {
            return oJSDate;
        } else {
            return new Date(oJSDate.getUTCFullYear(), oJSDate.getUTCMonth(), oJSDate.getUTCDate(), oJSDate.getUTCHours(), oJSDate.getUTCMinutes(), oJSDate.getUTCSeconds(), oJSDate.getUTCMilliseconds());
        }
    }
};
DateFormat.prototype.formatRelative = function (oJSDate, bUTC, aRange) {
    var oToday = new Date(), oDateUTC, sScale = this.oFormatOptions.relativeScale || 'day', iDiff, sPattern, iDiffSeconds;
    iDiffSeconds = (oJSDate.getTime() - oToday.getTime()) / 1000;
    if (this.oFormatOptions.relativeScale == 'auto') {
        sScale = this._getScale(iDiffSeconds, this.aRelativeScales);
    }
    if (!aRange) {
        aRange = this._mRanges[sScale];
    }
    if (sScale == 'year' || sScale == 'month' || sScale == 'day') {
        oToday = new Date(Date.UTC(oToday.getFullYear(), oToday.getMonth(), oToday.getDate()));
        oDateUTC = new Date(0);
        if (bUTC) {
            oDateUTC.setUTCFullYear(oJSDate.getUTCFullYear(), oJSDate.getUTCMonth(), oJSDate.getUTCDate());
        } else {
            oDateUTC.setUTCFullYear(oJSDate.getFullYear(), oJSDate.getMonth(), oJSDate.getDate());
        }
        oJSDate = oDateUTC;
    }
    iDiff = this._getDifference(sScale, [
        oToday,
        oJSDate
    ]);
    if (this.oFormatOptions.relativeScale != 'auto' && (iDiff < aRange[0] || iDiff > aRange[1])) {
        return null;
    }
    sPattern = this.oLocaleData.getRelativePattern(sScale, iDiff, iDiffSeconds > 0, this.oFormatOptions.relativeStyle);
    return fnFormatMessage(sPattern, [Math.abs(iDiff)]);
};
DateFormat.prototype._mRanges = {
    second: [
        -60,
        60
    ],
    minute: [
        -60,
        60
    ],
    hour: [
        -24,
        24
    ],
    day: [
        -6,
        6
    ],
    week: [
        -4,
        4
    ],
    month: [
        -12,
        12
    ],
    year: [
        -10,
        10
    ]
};
DateFormat.prototype._mScales = {
    second: 1,
    minute: 60,
    hour: 3600,
    day: 86400,
    week: 604800,
    month: 2592000,
    quarter: 7776000,
    year: 31536000
};
DateFormat.prototype._getScale = function (iDiffSeconds, aScales) {
    var sScale, sTestScale;
    iDiffSeconds = Math.abs(iDiffSeconds);
    for (var i = 0; i < aScales.length; i++) {
        sTestScale = aScales[i];
        if (iDiffSeconds >= this._mScales[sTestScale]) {
            sScale = sTestScale;
            break;
        }
    }
    if (!sScale) {
        sScale = aScales[aScales.length - 1];
    }
    return sScale;
};
function cutDateFields(oDate, iStartIndex) {
    var aFields = [
            'FullYear',
            'Month',
            'Date',
            'Hours',
            'Minutes',
            'Seconds',
            'Milliseconds'
        ], sMethodName;
    for (var i = iStartIndex; i < aFields.length; i++) {
        sMethodName = 'set' + aFields[iStartIndex];
        oDate[sMethodName].apply(oDate, [0]);
    }
}
var mRelativeDiffs = {
    year: function (oFromDate, oToDate) {
        return oToDate.getFullYear() - oFromDate.getFullYear();
    },
    month: function (oFromDate, oToDate) {
        return oToDate.getMonth() - oFromDate.getMonth() + this.year(oFromDate, oToDate) * 12;
    },
    week: function (oFromDate, oToDate, oFormat) {
        var iFromDay = oFormat._adaptDayOfWeek(oFromDate.getDay());
        var iToDay = oFormat._adaptDayOfWeek(oToDate.getDay());
        cutDateFields(oFromDate, 3);
        cutDateFields(oToDate, 3);
        return (oToDate.getTime() - oFromDate.getTime() - (iToDay - iFromDay) * oFormat._mScales.day * 1000) / (oFormat._mScales.week * 1000);
    },
    day: function (oFromDate, oToDate, oFormat) {
        cutDateFields(oFromDate, 3);
        cutDateFields(oToDate, 3);
        return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.day * 1000);
    },
    hour: function (oFromDate, oToDate, oFormat) {
        cutDateFields(oFromDate, 4);
        cutDateFields(oToDate, 4);
        return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.hour * 1000);
    },
    minute: function (oFromDate, oToDate, oFormat) {
        cutDateFields(oFromDate, 5);
        cutDateFields(oToDate, 5);
        return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.minute * 1000);
    },
    second: function (oFromDate, oToDate, oFormat) {
        cutDateFields(oFromDate, 6);
        cutDateFields(oToDate, 6);
        return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.second * 1000);
    }
};
DateFormat.prototype._adaptDayOfWeek = function (iDayOfWeek) {
    var iFirstDayOfWeek = LocaleData.getInstance(sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale()).getFirstDayOfWeek();
    var iDayNumberOfWeek = iDayOfWeek - (iFirstDayOfWeek - 1);
    if (iDayNumberOfWeek <= 0) {
        iDayNumberOfWeek += 7;
    }
    return iDayNumberOfWeek;
};
DateFormat.prototype._getDifference = function (sScale, aDates) {
    var oFromDate = aDates[0];
    var oToDate = aDates[1];
    return Math.round(mRelativeDiffs[sScale](oFromDate, oToDate, this));
};
DateFormat.prototype.getAllowedCharacters = function (aFormatArray) {
    if (this.oFormatOptions.relative) {
        return '';
    }
    var sAllowedCharacters = '';
    var bNumbers = false;
    var bAll = false;
    var oPart;
    for (var i = 0; i < aFormatArray.length; i++) {
        oPart = aFormatArray[i];
        switch (oPart.type) {
        case 'text':
            if (sAllowedCharacters.indexOf(oPart.value) < 0) {
                sAllowedCharacters += oPart.value;
            }
            break;
        case 'day':
        case 'year':
        case 'weekYear':
        case 'dayNumberOfWeek':
        case 'weekInYear':
        case 'hour0_23':
        case 'hour1_24':
        case 'hour0_11':
        case 'hour1_12':
        case 'minute':
        case 'second':
        case 'fractionalsecond':
            if (!bNumbers) {
                sAllowedCharacters += '0123456789';
                bNumbers = true;
            }
            break;
        case 'month':
        case 'monthStandalone':
            if (oPart.digits < 3) {
                if (!bNumbers) {
                    sAllowedCharacters += '0123456789';
                    bNumbers = true;
                }
            } else {
                bAll = true;
            }
            break;
        default:
            bAll = true;
            break;
        }
    }
    if (bAll) {
        sAllowedCharacters = '';
    }
    return sAllowedCharacters;
};

class MonthPickerTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			styles: {
				main: {
					display: state._hidden ? 'none' : 'block'
				}
			}
		};

		return context;
	}
}

const html$6 = index.html;
const repeat$6 = index.repeat;

const MonthPickerLitRenderer = {};

const block0$5 = (context) => { return html$6`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="sapUiCalMonthPicker"	role="grid"	aria-readonly="false"	aria-multiselectable="false"	style="${index.ifTruthy(context.styles.main)}">    ${ repeat$6(context.ctr._months, undefined, (item, index$$1) => block1$4(item, index$$1, context)) }</div>`; };
const block1$4 = (item, index$$1, context) => { return html$6`<div id="${index.ifTruthy(item.id)}" data-sap-timestamp=${index.ifTruthy(item.timestamp)} tabindex=${index.ifTruthy(item._tabIndex)} class="${index.ifTruthy(item.classes)}" style="width:33.333333333333336%" role="gridcell" aria-selected="false">			${index.ifTruthy(item.name)}</div>    `; };
const renderMe$5 = block0$5;

MonthPickerLitRenderer.render = renderMe$5;

/**
 * @public
 */
const metadata$7 = {
	tag: "ui5-month-picker",
	styleUrl: [
		"Calendar.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.MonthPicker.prototype */ {
		/**
		 * A UNIX timestamp - seconds since 00:00:00 UTC on Jan 1, 1970.
		 * @type {Integer}
		 * @public
		 */
		timestamp: {
			type: Integer
		},
		/**
		 * Sets a calendar type used for display.
		 * If not set, the calendar type of the global configuration is used.
		 * @type {String}
		 * @public
		 */
		primaryCalendarType: {
			type: CalendarType$1
		},
		_months: {
			type: Object,
			multiple: true
		},
		_hidden: {
			type: Boolean
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.MonthPicker.prototype */ {
		/**
		 * Fired when the user selects a new Date on the control.
		 * @public
		 * @event
		 */
		selectedMonthChange: {}
	}
};

/**
 * Month picker component.
 *
 * @class
 *
 * Displays months which can be selected.
 *
 * @extends sap.ui.webcomponents.base.Control
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.MonthPicker
 * @public
 */
class MonthPicker extends WebComponent {

	static get metadata() {
		return metadata$7;
	}

	static get renderer() {
		return MonthPickerLitRenderer;
	}

	constructor(state) {
		super(state);
		this._oLocale = Core$1.getConfiguration().getFormatSettings().getFormatLocale();

		this._oLocaleData = new LocaleData(this._oLocale);

		this._itemNav = new ItemNavigation(this, { rowSize: 3, cyclic: true});
		this._itemNav.getItemsCallback = function() {
			return this._months;
		}.bind(this);
		this._itemNav.setItemsCallback = function(items) {
			this._months = items;
		}.bind(this);

		this._delegates.push(this._itemNav);
	}

	onBeforeRendering() {
		const months = [];
		const oCalDate = CalendarDate.fromLocalJSDate(new Date(), this._primaryCalendarType);
		let timestamp;

		for (let i = 0; i < 12; i++) {
			oCalDate.setMonth(i);
			timestamp = oCalDate.valueOf() / 1000;

			let month = {
				timestamp: timestamp.toString(),
				id: this._state._id + "-m" + months.length,
				name: this._oLocaleData.getMonths("wide", this._primaryCalendarType)[i],
				classes: "sapUiCalItem"
			};

			if (this._month === i) {
				month.classes += " sapUiCalItemSel";
			}
			months.push(month);
		}

		this._months = months;

		this._itemNav.init();
	}

	onAfterRendering() {
		this._itemNav.focusCurrent();
	}

	get _timestamp() {
		return this.timestamp !== undefined ? this.timestamp : Math.floor(new Date().getTime() / 1000);
	}

	get _localDate() {
		return new Date(this._timestamp * 1000);
	}

	get _calendarDate() {
		return CalendarDate.fromLocalJSDate(this._localDate, this._primaryCalendarType);
	}

	get _month() {
		return this._calendarDate.getMonth();
	}

	get _primaryCalendarType() {
		return this.primaryCalendarType || Core$1.getConfiguration().getCalendarType();
	}

	onclick(event) {
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const timestamp = this.getTimestampFromDOM(event.ui5target);
			this.timestamp = timestamp;
			this._itemNav.current = this._month;
			this.fireEvent('selectedMonthChange', { timestamp });
		}
	}

	onsapenter(event) {
		event.preventDefault();
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const timestamp = this.getTimestampFromDOM(event.ui5target);
			this.timestamp = timestamp;
			this.fireEvent('selectedMonthChange', { timestamp });
		}
	}

	onsapspace(event) {
		event.preventDefault();
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			this.timestamp = this.getTimestampFromDOM(event.ui5target);
		}
	}

	getTimestampFromDOM(domNode) {
		const oMonthDomRef = domNode.getAttribute("data-sap-timestamp");
		return parseInt(oMonthDomRef, 10);
	}

	static get calculateTemplateContext() {
		return MonthPickerTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	MonthPicker.define();
});

class YearPickerTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			styles: {
				main: {
					display: state._hidden ? 'none' : 'block'
				}
			}
		};

		return context;
	}
}

const html$7 = index.html;
const repeat$7 = index.repeat;

const YearPickerLitRenderer = {};

const block0$6 = (context) => { return html$7`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="sapUiCalYearPicker"	role="grid"	aria-readonly="false"	aria-multiselectable="false"	style="${index.ifTruthy(context.styles.main)}">    ${ repeat$7(context.ctr._years, undefined, (item, index$$1) => block1$5(item, index$$1, context)) }</div>`; };
const block1$5 = (item, index$$1, context) => { return html$7`<div id="${index.ifTruthy(item.id)}"			tabindex="${index.ifTruthy(item._tabIndex)}"			data-sap-timestamp="${index.ifTruthy(item.timestamp)}"			class="${index.ifTruthy(item.classes)}"			style="width:20%"			role="gridcell"			aria-selected="false">				${index.ifTruthy(item.year)}</div>    `; };
const renderMe$6 = block0$6;

YearPickerLitRenderer.render = renderMe$6;

ShadowDOM.registerStyle("sap_belize", "Calendar.css", calendarBelize);

/**
 * @public
 */
const metadata$8 = {
	tag: "ui5-year-picker",
	styleUrl: [
		"Calendar.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.YearPicker.prototype */ {
		/**
		 * A UNIX timestamp - seconds since 00:00:00 UTC on Jan 1, 1970.
		 * @type {Integer}
		 * @public
		 */
		timestamp: {
			type: Integer
		},
		/**
		 * Sets a calendar type used for display.
		 * If not set, the calendar type of the global configuration is used.
		 * @type {String}
		 * @public
		 */
		primaryCalendarType: {
			type: CalendarType$1
		},
		_selectedYear: {
			type: Integer
		},
		_years: {
			type: Object,
			multiple: true
		},
		_hidden: {
			type: Boolean
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.YearPicker.prototype */ {
		/**
		 * Fired when the user selects a new Date on the control.
		 * @public
		 * @event
		 */
		selectedYearChange: {}
	}
};

const ITEMS_MAX_OFFSET = 12;
const ITEMS_COUNT = 2 * ITEMS_MAX_OFFSET + 1;

/**
 * @class
 *
 * Displays years which can be selected.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.YearPicker
 * @public
 */
class YearPicker extends WebComponent {

	static get metadata() {
		return metadata$8;
	}

	static get renderer() {
		return YearPickerLitRenderer;
	}

	constructor(state) {
		super(state);

		this._oLocale = Core$1.getConfiguration().getFormatSettings().getFormatLocale();

		this._itemNav = new ItemNavigation(this, { rowSize: 5 });
		this._itemNav.getItemsCallback = function() {
			return this._years;
		}.bind(this);
		this._itemNav.setItemsCallback = function(items) {
			this._years = items;
		}.bind(this);

		this._itemNav.attachEvent(ItemNavigation.BORDER_REACH, this._handleItemNavigationBorderReach.bind(this));

		this._delegates.push(this._itemNav);
	}

	onBeforeRendering() {
		const oYearFormat = DateFormat.getDateInstance({ format: "y", calendarType: this._primaryCalendarType }, this._oLocale);
		const oCalDate = this._calendarDate;
		oCalDate.setMonth(0);
		oCalDate.setDate(1);
		oCalDate.setYear(oCalDate.getYear() - ITEMS_MAX_OFFSET - 1);
		const years = [];
		let timestamp;

		if (this._selectedYear === undefined) {
			this._selectedYear = this._year;
		}

		for (let i = 0; i <= 2 * ITEMS_MAX_OFFSET; i++) {
			oCalDate.setYear(oCalDate.getYear() + 1);
			timestamp = oCalDate.valueOf() / 1000;

			let year = {
				timestamp: timestamp.toString(),
				id: this._state._id + "-y" + (timestamp),
				year: oYearFormat.format(oCalDate.toLocalJSDate()),
				classes: "sapUiCalItem"
			};

			if (oCalDate.getYear() === this._selectedYear) {
				year.classes += " sapUiCalItemSel";
			}
			years.push(year);
		}

		this._years = years;

		this._itemNav.init();
	}

	onAfterRendering() {
		this._itemNav.focusCurrent();
	}

	get _timestamp() {
		return this.timestamp !== undefined ? this.timestamp : Math.floor(new Date().getTime() / 1000);
	}

	get _localDate() {
		return new Date(this._timestamp * 1000);
	}

	get _calendarDate() {
		return CalendarDate.fromLocalJSDate(this._localDate, this._primaryCalendarType);
	}

	get _year() {
		return this._calendarDate.getYear();
	}

	get _primaryCalendarType() {
		return this.primaryCalendarType || Core$1.getConfiguration().getCalendarType();
	}

	onclick(event) {
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const timestamp = this.getTimestampFromDom(event.ui5target);
			this.timestamp = timestamp;
			this._selectedYear = this._year;
			this._itemNav.current = ITEMS_MAX_OFFSET;
			this.fireEvent('selectedYearChange', { timestamp });
		}
	}

	getTimestampFromDom(domNode) {
		const sTimestamp = domNode.getAttribute("data-sap-timestamp");
		return parseInt(sTimestamp, 10);
	}

	static get calculateTemplateContext() {
		return YearPickerTemplateContext.calculate;
	}

	onsapenter(event) {
		event.preventDefault();
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const timestamp = this.getTimestampFromDom(event.ui5target);
			this.timestamp = timestamp;
			this._selectedYear = this._year;
			this._itemNav.current = ITEMS_MAX_OFFSET;
			this.fireEvent('selectedYearChange', { timestamp });
		}
	}

	onsapspace(event) {
		event.preventDefault();
		if (event.ui5target.className.indexOf('sapUiCalItem') > -1) {
			const timestamp = this.getTimestampFromDom(event.ui5target);
			this._selectedYear = CalendarDate.fromLocalJSDate(new Date(timestamp * 1000), this._primaryCalendarType).getYear();
		}
	}

	_handleItemNavigationBorderReach(event) {
		const oCalDate = this._calendarDate;
		oCalDate.setMonth(0);
		oCalDate.setDate(1);

		if (event.end) {
			oCalDate.setYear(oCalDate.getYear() + ITEMS_COUNT);
		} else if (event.start) {
			oCalDate.setYear(oCalDate.getYear() - ITEMS_COUNT);
		}

		this.timestamp = oCalDate.valueOf() / 1000;
	}
}

Core$1.boot().then(_ => {
	YearPicker.define();
});

const html$8 = index.html;

const CalendarLitRenderer = {};

const block0$7 = (context) => { return html$8`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}" class="${index.ifTruthy(context.classes.main)}"><ui5-calendar-header
            id="${index.ifTruthy(context.ctr._id)}-head"
            month-text="${index.ifTruthy(context.ctr._header.monthText)}"
            year-text="${index.ifTruthy(context.ctr._header.yearText)}"
			.primaryCalendarType="${index.ifTruthy(context.ctr._oMonth.primaryCalendarType)}"
            @pressPrevious="${index.ifTruthy(context.ctr._header.onPressPrevious)}"
            @pressNext="${index.ifTruthy(context.ctr._header.onPressNext)}"
            @btn1Press="${index.ifTruthy(context.ctr._header.onBtn1Press)}"
            @btn2Press="${index.ifTruthy(context.ctr._header.onBtn2Press)}"
            data-sap-focus-ref
    ></ui5-calendar-header><div id="${index.ifTruthy(context.ctr._id)}-content" class="sapUiCalContent"><ui5-daypicker
                id="${index.ifTruthy(context.ctr._id)}-daypicker"
                format-pattern="${index.ifTruthy(context.ctr._oMonth.formatPattern)}"
                .selectedDates="${index.ifTruthy(context.ctr._oMonth.selectedDates)}"
                ._hidden="${index.ifTruthy(context.ctr._oMonth._hidden)}"
                .primaryCalendarType="${index.ifTruthy(context.ctr._oMonth.primaryCalendarType)}"
                timestamp="${index.ifTruthy(context.ctr._oMonth.timestamp)}"
                @selectedDatesChange="${index.ifTruthy(context.ctr._oMonth.onSelectedDatesChange)}"
                @navigate="${index.ifTruthy(context.ctr._oMonth.onNavigate)}"
        ></ui5-daypicker><ui5-month-picker
		        id="${index.ifTruthy(context.ctr._id)}-MP"
                ._hidden="${index.ifTruthy(context.ctr._monthPicker._hidden)}"
				.primaryCalendarType="${index.ifTruthy(context.ctr._oMonth.primaryCalendarType)}"
                timestamp="${index.ifTruthy(context.ctr._monthPicker.timestamp)}"
                @selectedMonthChange="${index.ifTruthy(context.ctr._monthPicker.onSelectedMonthChange)}"
        ></ui5-month-picker><ui5-year-picker
		        id="${index.ifTruthy(context.ctr._id)}-YP"
                ._hidden="${index.ifTruthy(context.ctr._yearPicker._hidden)}"
				.primaryCalendarType="${index.ifTruthy(context.ctr._oMonth.primaryCalendarType)}"
                timestamp="${index.ifTruthy(context.ctr._yearPicker.timestamp)}"
                @selectedYearChange="${index.ifTruthy(context.ctr._yearPicker.onSelectedYearChange)}"
        ></ui5-year-picker></div></div>`; };
const renderMe$7 = block0$7;

CalendarLitRenderer.render = renderMe$7;

var calendarCustomBelize = "";

ShadowDOM.registerStyle("sap_belize", "Calendar.css", calendarBelize);
ShadowDOM.registerStyle("sap_belize", "CalendarCustom.css", calendarCustomBelize);

const metadata$9 = {
	tag: "ui5-calendar",
	styleUrl: [
		"Button.css",
		"Calendar.css",
		"CalendarCustom.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.Calendar.prototype */ {
		/* It's a UNIX timestamp - seconds since 00:00:00 UTC on Jan 1, 1970 */
		timestamp: {
			type: Integer
		},
		/**
		 * Sets a calendar type used for display.
		 * If not set, the calendar type of the global configuration is used.
		 * @type {string}
		 * @public
		 */
		primaryCalendarType: {
			type: CalendarType$1
		},
		/**
		 * Sets the selected dates as UTC timestamps.
		 * @type {Array}
		 * @public
		 */
		selectedDates: {
			type: Integer,
			multiple: true
		},
		_header: {
			type: Object
		},
		_oMonth: {
			type: Object
		},
		_monthPicker: {
			type: Object
		},
		_yearPicker: {
			type: Object
		},
		formatPattern: {
			type: String
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.Calendar.prototype */ {
		selectedDatesChange: {}
	}
};

/**
 * @class
 *
 * It can be used for a date picker.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Calendar
 * @public
 */
class Calendar$1 extends WebComponent {

	static get metadata() {
		return metadata$9;
	}

	static get renderer() {
		return CalendarLitRenderer;
	}

	constructor(state) {
		super(state);
		this._oLocale = Core$1.getConfiguration().getFormatSettings().getFormatLocale();
		this._oLocaleData = new LocaleData(this._oLocale);
		this._header = {};
		this._header.onPressPrevious = this._handlePrevious.bind(this);
		this._header.onPressNext = this._handleNext.bind(this);
		this._header.onBtn1Press = this._handleMonthButtonPress.bind(this);
		this._header.onBtn2Press = this._handleYearButtonPress.bind(this);

		this._oMonth = {};
		this._oMonth.onSelectedDatesChange = this._handleSelectedDatesChange.bind(this);
		this._oMonth.onNavigate = this._handleMonthNavigate.bind(this);

		this._monthPicker = {};
		this._monthPicker._hidden = true;
		this._monthPicker.onSelectedMonthChange = this._handleSelectedMonthChange.bind(this);

		this._yearPicker = {};
		this._yearPicker._hidden = true;
		this._yearPicker.onSelectedYearChange = this._handleSelectedYearChange.bind(this);
	}

	onBeforeRendering() {
		const oYearFormat = DateFormat.getDateInstance({format: "y", calendarType: this._primaryCalendarType});

		this._oMonth.formatPattern = this._formatPattern;
		this._oMonth.timestamp = this._timestamp;
		this._oMonth.selectedDates = [...this._selectedDates];
		this._oMonth.primaryCalendarType = this._primaryCalendarType;

		this._header.monthText = this._oLocaleData.getMonths("wide", this._primaryCalendarType)[this._month];
		this._header.yearText = oYearFormat.format(this._localDate);

		this._monthPicker.primaryCalendarType = this._primaryCalendarType;
		this._monthPicker.timestamp = this._timestamp;
		this._yearPicker.primaryCalendarType = this._primaryCalendarType;
		this._yearPicker.timestamp = this._timestamp;
	}

	get _timestamp() {
		return this.timestamp !== undefined ? this.timestamp : Math.floor(new Date().getTime() / 1000);
	}

	get _localDate() {
		return new Date(this._timestamp * 1000);
	}

	get _calendarDate() {
		return CalendarDate.fromLocalJSDate(this._localDate, this._primaryCalendarType);
	}

	get _month() {
		return this._calendarDate.getMonth();
	}

	get _primaryCalendarType() {
		return this.primaryCalendarType || Core$1.getConfiguration().getCalendarType();
	}

	get _formatPattern() {
		return this.formatPattern || 'medium'; // get from config
	}

	get _isPattern() {
		return this._formatPattern !== "medium" && this._formatPattern !== "short" && this._formatPattern !== "long";
	}

	get _selectedDates() {
		return this.selectedDates || [];
	}

	_handleSelectedDatesChange(event) {
		this.selectedDates = [...event.detail.dates];

		this.fireEvent("selectedDatesChange", { dates: event.detail.dates });
	}

	_handleMonthNavigate(event) {
		this.timestamp = event.detail.timestamp;
	}

	_handleSelectedMonthChange(event) {
		const oNewDate = this._calendarDate;
		oNewDate.setMonth(CalendarDate.fromLocalJSDate(new Date(event.detail.timestamp * 1000), this._primaryCalendarType).getMonth());
		this.timestamp = oNewDate.valueOf() / 1000;

		this._hideMonthPicker();
	}

	_handleSelectedYearChange(event) {
		const oOldMonth = this._calendarDate.getMonth();
		const oOldDay = this._calendarDate.getDate();
		const oNewDate = CalendarDate.fromLocalJSDate(new Date(event.detail.timestamp * 1000), this._primaryCalendarType);
		oNewDate.setMonth(oOldMonth);
		oNewDate.setDate(oOldDay);

		this.timestamp = oNewDate.valueOf() / 1000;

		this._hideYearPicker();
	}

	_handleMonthButtonPress() {
		this._hideYearPicker();
		this._showMonthPicker();
	}

	_handleYearButtonPress() {
		this._hideMonthPicker();
		this._showYearPicker();
	}

	_handlePrevious() {
		let iNewMonth = this._month - 1,
			iNewYear = this._calendarDate.getYear();

		if (iNewMonth < 0) {
			iNewMonth = 11;
			iNewYear = this._calendarDate.getYear() - 1;
		}

		const oNewDate = this._calendarDate;
		oNewDate.setYear(iNewYear);
		oNewDate.setMonth(iNewMonth);

		this.timestamp = oNewDate.valueOf() / 1000;
	}

	_handleNext() {
		let iNewMonth = this._month + 1,
			iNewYear = this._calendarDate.getYear();

		if (iNewMonth > 11) {
			iNewMonth = 0;
			iNewYear = this._calendarDate.getYear() + 1;
		}

		const oNewDate = this._calendarDate;
		oNewDate.setYear(iNewYear);
		oNewDate.setMonth(iNewMonth);

		this.timestamp = oNewDate.valueOf() / 1000;
	}

	_showMonthPicker() {
		this._monthPicker = Object.assign({}, this._monthPicker);
		this._oMonth = Object.assign({}, this._oMonth);

		this._monthPicker.timestamp = this._timestamp;
		this._monthPicker._hidden = false;
		this._oMonth._hidden = true;
	}

	_showYearPicker() {
		this._yearPicker = Object.assign({}, this._yearPicker);
		this._oMonth = Object.assign({}, this._oMonth);

		this._yearPicker.timestamp = this._timestamp;
		this._yearPicker._hidden = false;
		this._oMonth._hidden = true;
	}

	_hideMonthPicker() {
		this._monthPicker = Object.assign({}, this._monthPicker);
		this._oMonth = Object.assign({}, this._oMonth);

		this._monthPicker._hidden = true;
		this._oMonth._hidden = false;
	}

	_hideYearPicker() {
		this._yearPicker = Object.assign({}, this._yearPicker);
		this._oMonth = Object.assign({}, this._oMonth);

		this._yearPicker._hidden = true;
		this._oMonth._hidden = false;
	}

	static get calculateTemplateContext() {
		return CalendarTemplateContext.calculate;
	}
}

Core$1.boot().then(async _ => {
	await Promise.all([
		CalendarHeader$1.define(),
		DayPicker.define(),
		MonthPicker.define(),
		YearPicker.define(),
	]);
	Calendar$1.define();
});

var ar = "643867d0cc390cb3.json";

var ar_EG = "62ff67d134efa546.json";

var ar_SA = "27fcbf450b125e74.json";

var bg = "ecee47a30883b1e2.json";

var ca = "7005f35111c7a6f6.json";

var cs = "4b475a23e7859733.json";

var da = "fbba66ff1ef7a34f.json";

var de = "2f4632cc6022c235.json";

var de_AT = "c1cb7037941bb678.json";

var de_CH = "5d92f2205b4bb6ea.json";

var el = "04f616e3e81048f5.json";

var el_CY = "15f598ee571301ed.json";

var en = "30c9b2a7b732f826.json";

var en_AU = "d7ff6b200e1788b8.json";

var en_GB = "4a5cb916c4c3de43.json";

var en_HK = "17c51688eefe21f9.json";

var en_IE = "f2fba947e5c7edcc.json";

var en_IN = "1f7af466534dec63.json";

var en_NZ = "8cbd9e6948908a22.json";

var en_PG = "9c64dd4461148bcc.json";

var en_SG = "8b5cebceed81faad.json";

var en_ZA = "3a625312d4de624f.json";

var es = "2d56c07195c5e08f.json";

var es_AR = "e975b033c38cbe5b.json";

var es_BO = "f268b5b1da9ccdf9.json";

var es_CL = "11773a4564ca6081.json";

var es_CO = "db1d7e9c990f3cbd.json";

var es_MX = "176053d4df4ec6a9.json";

var es_PE = "6ea8b5e716fcf660.json";

var es_UY = "bf175779e73f01e9.json";

var es_VE = "66705e94aae2ab08.json";

var et = "ee2f560ace099950.json";

var fa = "f49510ce6f632514.json";

var fi = "73556ee8c251629b.json";

var fr = "e1a968ad97215ae8.json";

var fr_BE = "b033f17dffa6889a.json";

var fr_CA = "d369e6aa21b42133.json";

var fr_CH = "9df80415adb69b7e.json";

var fr_LU = "a39788d228e43a5b.json";

var he = "561968864869000e.json";

var hi = "d2898a51a770601f.json";

var hr = "ac0cebdfc2ba0936.json";

var hu = "9a4e09faa50b2b0c.json";

var id = "87aede3d7aa89814.json";

var it = "55e5c90e2687e802.json";

var it_CH = "03a6a1b008263f24.json";

var ja = "4cae38afd1ef8059.json";

var kk = "1077e1ca1b298e63.json";

var ko = "b197c0272c107123.json";

var lt = "b20b33c988fb7581.json";

var lv = "e6ddc2f75c774572.json";

var ms = "6d02e73eca611eca.json";

var nb = "7d67b52e78401cf1.json";

var nl = "6b3134eaeb425a03.json";

var nl_BE = "d5e602bbbb0fbc99.json";

var pl = "ca8904e2e07b4d1d.json";

var pt = "6a6dcc06e0898dec.json";

var pt_PT = "0103704ffe52c682.json";

var ro = "e44e92767fe77cbb.json";

var ru = "779f0be30c526143.json";

var ru_UA = "15170b3de5593240.json";

var sk = "69a1ffd94352651b.json";

var sl = "143b4e44265065ef.json";

var sr = "17e99f15b90d1242.json";

var sv = "5b2a8c744f25ae28.json";

var th = "5a6cb8e424dd4ad8.json";

var tr = "be13b7931422deff.json";

var uk = "6609072e72b25c08.json";

var vi = "529c97307936131e.json";

var zh_CN = "a101d3919f382723.json";

var zh_HK = "31092e8cb92eba37.json";

var zh_SG = "0e9cf8f682983650.json";

var zh_TW = "0ad41c1e20b07ca5.json";

const resources = new Map();

sap.ui.loader = {
	_: {
		getModuleContent: (moduleName, url) => {
			return resources.get(moduleName) || resources.get(url) || "";
		}
	}
};

const registerModuleContent = (moduleName, content) => {
	resources.set(moduleName, content);
};

const cldrData = {
	ar,
	ar_EG,
	ar_SA,
	bg,
	ca,
	cs,
	da,
	de,
	de_AT,
	de_CH,
	el,
	el_CY,
	en,
	en_AU,
	en_GB,
	en_HK,
	en_IE,
	en_IN,
	en_NZ,
	en_PG,
	en_SG,
	en_ZA,
	es,
	es_AR,
	es_BO,
	es_CL,
	es_CO,
	es_MX,
	es_PE,
	es_UY,
	es_VE,
	et,
	fa,
	fi,
	fr,
	fr_BE,
	fr_CA,
	fr_CH,
	fr_LU,
	he,
	hi,
	hr,
	hu,
	id,
	it,
	it_CH,
	ja,
	kk,
	ko,
	lt,
	lv,
	ms,
	nb,
	nl,
	nl_BE,
	pl,
	pt,
	pt_PT,
	ro,
	ru,
	ru_UA,
	sk,
	sl,
	sr,
	sv,
	th,
	tr,
	uk,
	vi,
	zh_CN,
	zh_HK,
	zh_SG,
	zh_TW,
};

// date formatters from the core do not know about this new mechanism of fetching assets,
// but we can use the sap.ui.loader._.getModuleContent as a hook and provide the preloaded data,
// so that a sync request via jQuery is never triggered.

const fetchCldrData = async (language, region) => {
	// try language + region
	let localeId = language + "_" + region;
	if (!cldrData[localeId]) {
		// fallback to language only
		localeId = language;
	}
	if (!cldrData[localeId]) {
		// fallback to english
		localeId = "en";
	}

	if (typeof(cldrData[localeId]) === "object") {
		// inlined from build
		registerModuleContent(`sap/ui/core/cldr/${localeId}.json`, JSON.stringify(cldrData[localeId]));
		return cldrData[localeId];
	}

	const assetPath = Core$1.getAssetPath();
	const localeUrl = assetPath + cldrData[localeId];

	const data = await fetch(localeUrl);
	const cldrContent = await data.text();
	registerModuleContent(`sap/ui/core/cldr/${localeId}.json`, cldrContent);
	return cldrContent;
};

const dir = Core$1.getConfiguration().getRTL() ? "rtl" : "ltr";

	class DatePickerTemplateContext {

		static calculate(state) {

			let context = {
				ctr: state,
				classes: {
					main: {
						"sapMDP": true,
						"sapMInputBase": true,
						"sapMInputBaseWidthPadding": true,
						"sapMInputVH": true
					},
					wrapper: {
						"sapMInputDivWrapper": true
					},
					inner: {
						"sapMInputBaseInner": true
					}
				},
				styles: {
					main: {
						width: "100%"
					}
				},
				dir
			};

			return context;
		}
	}

var Properties = function () {
    this.mProperties = {};
    this.aKeys = null;
};
Properties.prototype.getProperty = function (sKey, sDefaultValue) {
    var sValue = this.mProperties[sKey];
    if (typeof sValue == 'string') {
        return sValue;
    } else if (sDefaultValue) {
        return sDefaultValue;
    }
    return null;
};
Properties.prototype.getKeys = function () {
    return this.aKeys || (this.aKeys = Object.keys(this.mProperties));
};
Properties.prototype.setProperty = function (sKey, sValue) {
    if (typeof sValue != 'string') {
        return;
    }
    if (typeof this.mProperties[sKey] != 'string' && this.aKeys) {
        this.aKeys.push(String(sKey));
    }
    this.mProperties[sKey] = sValue;
};
Properties.prototype.clone = function () {
    var oClone = new Properties();
    oClone.mProperties = Object.assign({}, this.mProperties);
    return oClone;
};
var flatstr = typeof chrome === 'object' || typeof v8 === 'object' ? function (s, iConcatOps) {
    if (iConcatOps > 2 && 40 * iConcatOps > s.length) ;
    return s;
} : function (s) {
    return s;
};
var rLines = /(?:\r\n|\r|\n|^)[ \t\f]*/;
var rEscapesOrSeparator = /(\\u[0-9a-fA-F]{0,4})|(\\.)|(\\$)|([ \t\f]*[ \t\f:=][ \t\f]*)/g;
var rEscapes = /(\\u[0-9a-fA-F]{0,4})|(\\.)|(\\$)/g;
var mEscapes = {
    '\\f': '\f',
    '\\n': '\n',
    '\\r': '\r',
    '\\t': '\t'
};
function parse(sText, oProp) {
    var aLines = sText.split(rLines), sLine, rMatcher, sKey, sValue, i, m, iLastIndex, iConcatOps;
    function append(s) {
        if (sValue) {
            sValue = sValue + s;
            iConcatOps++;
        } else {
            sValue = s;
            iConcatOps = 0;
        }
    }
    oProp.mProperties = {};
    for (i = 0; i < aLines.length; i++) {
        sLine = aLines[i];
        if (sLine === '' || sLine.charAt(0) === '#' || sLine.charAt(0) === '!') {
            continue;
        }
        rMatcher = rEscapesOrSeparator;
        rMatcher.lastIndex = iLastIndex = 0;
        sKey = null;
        sValue = '';
        while ((m = rMatcher.exec(sLine)) !== null) {
            if (iLastIndex < m.index) {
                append(sLine.slice(iLastIndex, m.index));
            }
            iLastIndex = rMatcher.lastIndex;
            if (m[1]) {
                if (m[1].length !== 6) {
                    throw new Error('Incomplete Unicode Escape \'' + m[1] + '\'');
                }
                append(String.fromCharCode(parseInt(m[1].slice(2), 16)));
            } else if (m[2]) {
                append(mEscapes[m[2]] || m[2].slice(1));
            } else if (m[3]) {
                sLine = aLines[++i];
                rMatcher.lastIndex = iLastIndex = 0;
            } else if (m[4]) {
                sKey = sValue;
                sValue = '';
                rMatcher = rEscapes;
                rMatcher.lastIndex = iLastIndex;
            }
        }
        if (iLastIndex < sLine.length) {
            append(sLine.slice(iLastIndex));
        }
        if (sKey == null) {
            sKey = sValue;
            sValue = '';
        }
        oProp.mProperties[sKey] = flatstr(sValue, sValue ? iConcatOps : 0);
    }
}
Properties.create = function (mParams) {
    mParams = Object.assign({
        url: undefined,
        headers: {}
    }, mParams);
    var bAsync = !!mParams.async, oProp = new Properties(), vResource;
    function _parse(sText) {
        if (typeof sText === 'string') {
            parse(sText, oProp);
            return oProp;
        }
        return mParams.returnNullIfMissing ? null : oProp;
    }
    if (typeof mParams.url === 'string') {
        vResource = LoaderExtensions.loadResource({
            url: mParams.url,
            dataType: 'text',
            headers: mParams.headers,
            failOnError: false,
            async: bAsync
        });
    }
    if (bAsync) {
        if (!vResource) {
            return Promise.resolve(_parse(null));
        }
        return vResource.then(function (oVal) {
            return _parse(oVal);
        }, function (oVal) {
            throw oVal instanceof Error ? oVal : new Error('Problem during loading of property file \'' + mParams.url + '\': ' + oVal);
        });
    }
    return _parse(vResource);
};

var rLocale$1 = /^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?((?:-[0-9A-Z]{5,8}|-[0-9][0-9A-Z]{3})*)((?:-[0-9A-WYZ](?:-[0-9A-Z]{2,8})+)*)(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;
var M_ISO639_NEW_TO_OLD = {
    'he': 'iw',
    'yi': 'ji',
    'id': 'in',
    'sr': 'sh'
};
var M_ISO639_OLD_TO_NEW$2 = {
    'iw': 'he',
    'ji': 'yi',
    'in': 'id',
    'sh': 'sr'
};
var M_SUPPORTABILITY_TO_XS = {
    'en_US_saptrc': '1Q',
    'en_US_sappsd': '2Q'
};
var rSAPSupportabilityLocales = /(?:^|-)(saptrc|sappsd)(?:-|$)/i;
function normalize(sLocale) {
    var m;
    if (typeof sLocale === 'string' && (m = rLocale$1.exec(sLocale.replace(/_/g, '-')))) {
        var sLanguage = m[1].toLowerCase();
        sLanguage = M_ISO639_NEW_TO_OLD[sLanguage] || sLanguage;
        var sScript = m[2] ? m[2].toLowerCase() : undefined;
        var sRegion = m[3] ? m[3].toUpperCase() : undefined;
        var sVariants = m[4] ? m[4].slice(1) : undefined;
        var sPrivate = m[6];
        if (sPrivate && (m = rSAPSupportabilityLocales.exec(sPrivate)) || sVariants && (m = rSAPSupportabilityLocales.exec(sVariants))) {
            return 'en_US_' + m[1].toLowerCase();
        }
        if (sLanguage === 'zh' && !sRegion) {
            if (sScript === 'hans') {
                sRegion = 'CN';
            } else if (sScript === 'hant') {
                sRegion = 'TW';
            }
        }
        return sLanguage + (sRegion ? '_' + sRegion + (sVariants ? '_' + sVariants.replace('-', '_') : '') : '');
    }
}
function defaultLocale() {
    var sLocale;
    if (window.sap && window.sap.ui && sap.ui.getCore) {
        sLocale = sap.ui.getCore().getConfiguration().getLanguage();
        sLocale = normalize(sLocale);
    }
    return sLocale || 'en';
}
function nextFallbackLocale(sLocale) {
    if (!sLocale) {
        return null;
    }
    if (sLocale === 'zh_HK') {
        return 'zh_TW';
    }
    var p = sLocale.lastIndexOf('_');
    if (p >= 0) {
        return sLocale.slice(0, p);
    }
    return sLocale !== 'en' ? 'en' : '';
}
function convertLocaleToBCP47(sLocale) {
    var m;
    if (typeof sLocale === 'string' && (m = rLocale$1.exec(sLocale.replace(/_/g, '-')))) {
        var sLanguage = m[1].toLowerCase();
        sLanguage = M_ISO639_OLD_TO_NEW$2[sLanguage] || sLanguage;
        return sLanguage + (m[3] ? '-' + m[3].toUpperCase() + (m[4] ? '-' + m[4].slice(1).replace('_', '-') : '') : '');
    }
}
var rUrl = /^((?:[^?#]*\/)?[^\/?#]*)(\.[^.\/?#]+)((?:\?([^#]*))?(?:#(.*))?)$/;
var A_VALID_FILE_TYPES = [
    '.properties',
    '.hdbtextbundle'
];
function splitUrl(sUrl) {
    var m = rUrl.exec(sUrl);
    if (!m || A_VALID_FILE_TYPES.indexOf(m[2]) < 0) {
        throw new Error('resource URL \'' + sUrl + '\' has unknown type (should be one of ' + A_VALID_FILE_TYPES.join(',') + ')');
    }
    return {
        url: sUrl,
        prefix: m[1],
        ext: m[2],
        query: m[4],
        hash: m[5] || '',
        suffix: m[2] + (m[3] || '')
    };
}
function ResourceBundle(sUrl, sLocale, bIncludeInfo, bAsync) {
    this.sLocale = this._sNextLocale = normalize(sLocale) || defaultLocale();
    this.oUrlInfo = splitUrl(sUrl);
    this.bIncludeInfo = bIncludeInfo;
    this.aCustomBundles = [];
    this.aPropertyFiles = [];
    this.aLocales = [];
    if (bAsync) {
        var resolveWithThis = function () {
            return this;
        }.bind(this);
        return loadNextPropertiesAsync(this).then(resolveWithThis, resolveWithThis);
    }
    loadNextPropertiesSync(this);
}
ResourceBundle.prototype._enhance = function (oCustomBundle) {
    if (oCustomBundle instanceof ResourceBundle) {
        this.aCustomBundles.push(oCustomBundle);
    } else {
        Log.error('Custom resource bundle is either undefined or not an instanceof sap/base/i18n/ResourceBundle. Therefore this custom resource bundle will be ignored!');
    }
};
ResourceBundle.prototype.getText = function (sKey, aArgs, bIgnoreKeyFallback) {
    var sValue = this._getTextFromProperties(sKey, aArgs);
    if (sValue != null) {
        return sValue;
    }
    sValue = this._getTextFromFallback(sKey, aArgs);
    if (sValue != null) {
        return sValue;
    }
    fnAssert(false, 'could not find any translatable text for key \'' + sKey + '\' in bundle \'' + this.oUrlInfo.url + '\'');
    if (bIgnoreKeyFallback) {
        return undefined;
    } else {
        return this._formatValue(sKey, sKey, aArgs);
    }
};
ResourceBundle.prototype._formatValue = function (sValue, sKey, aArgs) {
    if (typeof sValue === 'string') {
        if (aArgs) {
            sValue = fnFormatMessage(sValue, aArgs);
        }
        if (this.bIncludeInfo) {
            sValue = new String(sValue);
            sValue.originInfo = {
                source: 'Resource Bundle',
                url: this.oUrlInfo.url,
                locale: this.sLocale,
                key: sKey
            };
        }
    }
    return sValue;
};
ResourceBundle.prototype._getTextFromFallback = function (sKey, aArgs) {
    var sValue, i;
    for (i = this.aCustomBundles.length - 1; i >= 0; i--) {
        sValue = this.aCustomBundles[i]._getTextFromFallback(sKey, aArgs);
        if (sValue != null) {
            return sValue;
        }
    }
    while (typeof sValue !== 'string' && this._sNextLocale != null) {
        var oProperties = loadNextPropertiesSync(this);
        if (oProperties) {
            sValue = oProperties.getProperty(sKey);
            if (typeof sValue === 'string') {
                return this._formatValue(sValue, sKey, aArgs);
            }
        }
    }
    return null;
};
ResourceBundle.prototype._getTextFromProperties = function (sKey, aArgs) {
    var sValue = null, i;
    for (i = this.aCustomBundles.length - 1; i >= 0; i--) {
        sValue = this.aCustomBundles[i]._getTextFromProperties(sKey, aArgs);
        if (sValue != null) {
            return sValue;
        }
    }
    for (i = 0; i < this.aPropertyFiles.length; i++) {
        sValue = this.aPropertyFiles[i].getProperty(sKey);
        if (typeof sValue === 'string') {
            return this._formatValue(sValue, sKey, aArgs);
        }
    }
    return null;
};
ResourceBundle.prototype.hasText = function (sKey) {
    return this.aPropertyFiles.length > 0 && typeof this.aPropertyFiles[0].getProperty(sKey) === 'string';
};
function loadNextPropertiesAsync(oBundle) {
    if (oBundle._sNextLocale != null) {
        return tryToLoadNextProperties(oBundle, true).then(function (oProps) {
            return oProps || loadNextPropertiesAsync(oBundle);
        });
    }
    return Promise.resolve(null);
}
function loadNextPropertiesSync(oBundle) {
    while (oBundle._sNextLocale != null) {
        var oProps = tryToLoadNextProperties(oBundle, false);
        if (oProps) {
            return oProps;
        }
    }
    return null;
}
function isSupported(sLocale, aSupportedLocales) {
    return !aSupportedLocales || aSupportedLocales.length === 0 || aSupportedLocales.indexOf(sLocale) >= 0;
}
function tryToLoadNextProperties(oBundle, bAsync) {
    var sLocale = oBundle._sNextLocale;
    oBundle._sNextLocale = nextFallbackLocale(sLocale);
    var aSupportedLanguages = window.sap && window.sap.ui && sap.ui.getCore && sap.ui.getCore().getConfiguration().getSupportedLanguages();
    if (sLocale != null && isSupported(sLocale, aSupportedLanguages)) {
        var oUrl = oBundle.oUrlInfo, sUrl, mHeaders;
        if (oUrl.ext === '.hdbtextbundle') {
            if (M_SUPPORTABILITY_TO_XS[sLocale]) {
                sUrl = oUrl.prefix + oUrl.suffix + '?' + (oUrl.query ? oUrl.query + '&' : '') + 'sap-language=' + M_SUPPORTABILITY_TO_XS[sLocale] + (oUrl.hash ? '#' + oUrl.hash : '');
            } else {
                sUrl = oUrl.url;
            }
            mHeaders = { 'Accept-Language': convertLocaleToBCP47(sLocale) || '' };
        } else {
            sUrl = oUrl.prefix + (sLocale ? '_' + sLocale : '') + oUrl.suffix;
        }
        var vProperties = Properties.create({
            url: sUrl,
            headers: mHeaders,
            async: !!bAsync,
            returnNullIfMissing: true
        });
        var addProperties = function (oProps) {
            if (oProps) {
                oBundle.aPropertyFiles.push(oProps);
                oBundle.aLocales.push(sLocale);
            }
            return oProps;
        };
        return bAsync ? vProperties.then(addProperties) : addProperties(vProperties);
    }
    return bAsync ? Promise.resolve(null) : null;
}
ResourceBundle.create = function (mParams) {
    mParams = Object.assign({
        url: '',
        locale: undefined,
        includeInfo: false
    }, mParams);
    return new ResourceBundle(mParams.url, mParams.locale, mParams.includeInfo, !!mParams.async);
};
ResourceBundle._getFallbackLocales = function (sLocale, aSupportedLocales) {
    var sTempLocale = normalize(sLocale), aLocales = [];
    while (sTempLocale != null) {
        if (isSupported(sTempLocale, aSupportedLocales)) {
            aLocales.push(sTempLocale);
        }
        sTempLocale = nextFallbackLocale(sTempLocale);
    }
    return aLocales;
};

var SAP_ICON_FONT_FAMILY$1 = 'SAP-icons';
var ICON_PROTOCOL = 'sap-icon';
var mFontRegistry = {
    undefined: {
        config: { fontFamily: SAP_ICON_FONT_FAMILY$1 },
        metadataLoaded: true,
        inserted: false
    }
};
var mRegistry = {
    'undefined': {
        'accidental-leave': 57344,
        'account': 57345,
        'wrench': 57346,
        'windows-doors': 57347,
        'washing-machine': 57348,
        'visits': 57349,
        'video': 57350,
        'travel-expense': 122887,
        'temperature': 57352,
        'task': 122889,
        'synchronize': 57354,
        'survey': 122891,
        'settings': 57356,
        'search': 122893,
        'sales-document': 122894,
        'retail-store': 57359,
        'refresh': 57360,
        'product': 57361,
        'present': 57362,
        'ppt-attachment': 57363,
        'pool': 57364,
        'pie-chart': 57365,
        'picture': 57366,
        'photo-voltaic': 57367,
        'phone': 57368,
        'pending': 57369,
        'pdf-attachment': 57370,
        'past': 122907,
        'outgoing-call': 57372,
        'opportunity': 57373,
        'opportunities': 122910,
        'notes': 57375,
        'money-bills': 122912,
        'map': 57377,
        'log': 57378,
        'line-charts': 57379,
        'lightbulb': 57380,
        'leads': 57381,
        'lead': 122918,
        'laptop': 57383,
        'kpi-managing-my-area': 122920,
        'kpi-corporate-performance': 122921,
        'incoming-call': 57386,
        'inbox': 57387,
        'horizontal-bar-chart': 57388,
        'history': 57389,
        'heating-cooling': 57390,
        'gantt-bars': 57391,
        'future': 122928,
        'fridge': 57393,
        'fallback': 57394,
        'expense-report': 122931,
        'excel-attachment': 57396,
        'energy-saving-lightbulb': 57397,
        'employee': 57398,
        'email': 57399,
        'edit': 57400,
        'duplicate': 57401,
        'download': 57402,
        'doc-attachment': 57403,
        'dishwasher': 57404,
        'delete': 57405,
        'decline': 57406,
        'complete': 122943,
        'competitor': 57408,
        'collections-management': 57409,
        'chalkboard': 122946,
        'cart': 57411,
        'card': 57412,
        'camera': 57413,
        'calendar': 122950,
        'begin': 57415,
        'basket': 57416,
        'bar-chart': 57417,
        'attachment': 57418,
        'arrow-top': 57419,
        'arrow-right': 57420,
        'arrow-left': 57421,
        'arrow-bottom': 57422,
        'approvals': 122959,
        'appointment': 57424,
        'alphabetical-order': 122961,
        'along-stacked-chart': 57426,
        'alert': 57427,
        'addresses': 57428,
        'address-book': 122965,
        'add-filter': 57430,
        'add-favorite': 57431,
        'add': 57432,
        'activities': 122969,
        'action': 57434,
        'accept': 122971,
        'hint': 122972,
        'group': 57437,
        'check-availability': 122974,
        'weather-proofing': 57439,
        'payment-approval': 122976,
        'batch-payments': 122977,
        'bed': 57442,
        'arobase': 122979,
        'family-care': 57444,
        'favorite': 57445,
        'navigation-right-arrow': 57446,
        'navigation-left-arrow': 57447,
        'e-care': 57448,
        'less': 57449,
        'lateness': 57450,
        'lab': 57451,
        'internet-browser': 57452,
        'instance': 57453,
        'inspection': 57454,
        'image-viewer': 57455,
        'home': 57456,
        'grid': 57457,
        'goalseek': 57458,
        'general-leave-request': 57459,
        'create-leave-request': 57460,
        'flight': 57461,
        'filter': 57462,
        'favorite-list': 57463,
        'factory': 57464,
        'endoscopy': 57465,
        'employee-pane': 57466,
        'employee-approvals': 123003,
        'email-read': 57468,
        'electrocardiogram': 57469,
        'documents': 57470,
        'decision': 57471,
        'database': 57472,
        'customer-history': 57473,
        'customer': 57474,
        'credit-card': 57475,
        'create-entry-time': 57476,
        'contacts': 57477,
        'compare': 57478,
        'clinical-order': 57479,
        'chain-link': 57480,
        'pull-down': 57481,
        'cargo-train': 57482,
        'car-rental': 57483,
        'business-card': 57484,
        'bar-code': 57485,
        'folder-blank': 57486,
        'passenger-train': 57487,
        'question-mark': 123024,
        'world': 57489,
        'iphone': 57490,
        'ipad': 57491,
        'warning': 57492,
        'sort': 57493,
        'course-book': 57494,
        'course-program': 57495,
        'add-coursebook': 57496,
        'print': 57497,
        'save': 57498,
        'play': 123035,
        'pause': 57500,
        'record': 57501,
        'response': 57502,
        'pushpin-on': 57503,
        'pushpin-off': 57504,
        'unfavorite': 57505,
        'learning-assistant': 57506,
        'timesheet': 57507,
        'time-entry-request': 57508,
        'list': 57509,
        'action-settings': 57510,
        'share': 57511,
        'feed': 57512,
        'role': 57513,
        'flag': 123050,
        'post': 57515,
        'inspect': 57516,
        'inspect-down': 57517,
        'appointment-2': 57518,
        'target-group': 57519,
        'marketing-campaign': 57520,
        'notification': 57521,
        'message-error': 57521,
        'comment': 57522,
        'shipping-status': 57523,
        'collaborate': 57524,
        'shortcut': 57525,
        'lead-outdated': 123062,
        'tools-opportunity': 57527,
        'permission': 57528,
        'supplier': 57529,
        'table-view': 57530,
        'table-chart': 57531,
        'switch-views': 57532,
        'e-learning': 57533,
        'manager': 57534,
        'switch-classes': 57535,
        'simple-payment': 123072,
        'signature': 57537,
        'sales-order-item': 123074,
        'sales-order': 123075,
        'request': 57540,
        'receipt': 57541,
        'puzzle': 57542,
        'process': 57543,
        'private': 57544,
        'popup-window': 57545,
        'person-placeholder': 57546,
        'per-diem': 123083,
        'paper-plane': 57548,
        'paid-leave': 123085,
        'pdf-reader': 123086,
        'overview-chart': 57551,
        'overlay': 57552,
        'org-chart': 57553,
        'number-sign': 57554,
        'notification-2': 57555,
        'my-sales-order': 123092,
        'meal': 57557,
        'loan': 123094,
        'order-status': 123095,
        'customer-order-entry': 123096,
        'performance': 57561,
        'menu': 57562,
        'employee-lookup': 57563,
        'education': 57564,
        'customer-briefing': 57565,
        'customer-and-contacts': 57566,
        'my-view': 57567,
        'accelerated': 57568,
        'to-be-reviewed': 57569,
        'warning2': 57570,
        'feeder-arrow': 57571,
        'quality-issue': 57572,
        'workflow-tasks': 57573,
        'create': 57574,
        'home-share': 57575,
        'globe': 123112,
        'tags': 57577,
        'work-history': 57578,
        'x-ray': 57579,
        'wounds-doc': 57580,
        'web-cam': 57581,
        'waiver': 123118,
        'vertical-bar-chart': 57583,
        'upstacked-chart': 57584,
        'trip-report': 57585,
        'microphone': 57586,
        'unpaid-leave': 123123,
        'tree': 57588,
        'toaster-up': 57589,
        'toaster-top': 57590,
        'toaster-down': 57591,
        'time-account': 57592,
        'theater': 57593,
        'taxi': 57594,
        'subway-train': 57595,
        'study-leave': 57596,
        'stethoscope': 57597,
        'step': 57598,
        'sonography': 57599,
        'soccor': 57600,
        'physical-activity': 57601,
        'pharmacy': 57602,
        'official-service': 57603,
        'offsite-work': 57604,
        'nutrition-activity': 57605,
        'newspaper': 57606,
        'monitor-payments': 123143,
        'map-2': 57608,
        'machine': 57609,
        'mri-scan': 57610,
        'end-user-experience-monitoring': 57611,
        'unwired': 57612,
        'customer-financial-fact-sheet': 123149,
        'retail-store-manager': 57614,
        'Netweaver-business-client': 57615,
        'electronic-medical-record': 57616,
        'eam-work-order': 123153,
        'customer-view': 57618,
        'crm-service-manager': 57619,
        'crm-sales': 123156,
        'widgets': 123157,
        'commission-check': 123158,
        'collections-insight': 123159,
        'clinical-tast-tracker': 57624,
        'citizen-connect': 57625,
        'cart-approval': 123162,
        'capital-projects': 123163,
        'bo-strategy-management': 57628,
        'business-objects-mobile': 57629,
        'business-objects-explorer': 57630,
        'business-objects-experience': 57631,
        'bbyd-dashboard': 57632,
        'bbyd-active-sales': 123169,
        'business-by-design': 123170,
        'business-one': 123171,
        'sap-box': 57636,
        'manager-insight': 57637,
        'accounting-document-verification': 123174,
        'hr-approval': 123175,
        'idea-wall': 57640,
        'Chart-Tree-Map': 57641,
        'cart-5': 57642,
        'cart-4': 57643,
        'wallet': 57644,
        'vehicle-repair': 57645,
        'upload': 57646,
        'unlocked': 57647,
        'umbrella': 57648,
        'travel-request': 123185,
        'travel-expense-report': 123186,
        'travel-itinerary': 57651,
        'time-overtime': 123188,
        'thing-type': 57653,
        'technical-object': 57654,
        'tag': 57655,
        'syringe': 57656,
        'syntax': 57657,
        'suitcase': 57658,
        'simulate': 57659,
        'shield': 57660,
        'share-2': 57661,
        'sales-quote': 123198,
        'repost': 57663,
        'provision': 57664,
        'projector': 57665,
        'add-product': 57666,
        'pipeline-analysis': 57667,
        'add-photo': 57668,
        'palette': 57669,
        'nurse': 57670,
        'sales-notification': 123207,
        'mileage': 57672,
        'meeting-room': 57673,
        'media-forward': 123210,
        'media-play': 123211,
        'media-pause': 57676,
        'media-reverse': 123213,
        'media-rewind': 123214,
        'measurement-document': 57679,
        'measuring-point': 57680,
        'measure': 57681,
        'map-3': 57682,
        'locked': 57683,
        'letter': 57684,
        'journey-arrive': 57685,
        'journey-change': 57686,
        'journey-depart': 57687,
        'it-system': 57688,
        'it-instance': 57689,
        'it-host': 57690,
        'iphone-2': 57691,
        'ipad-2': 57692,
        'inventory': 57693,
        'insurance-house': 57694,
        'insurance-life': 57695,
        'insurance-car': 57696,
        'initiative': 57697,
        'incident': 123234,
        'group-2': 57699,
        'goal': 57700,
        'functional-location': 57701,
        'full-screen': 57702,
        'form': 57703,
        'fob-watch': 57704,
        'blank-tag': 57705,
        'family-protection': 57706,
        'folder': 57707,
        'fax-machine': 57708,
        'example': 57709,
        'eraser': 57710,
        'employee-rejections': 57711,
        'drop-down-list': 57712,
        'draw-rectangle': 57713,
        'document': 57714,
        'doctor': 57715,
        'discussion-2': 57716,
        'discussion': 57717,
        'dimension': 57718,
        'customer-and-supplier': 57719,
        'crop': 57720,
        'add-contact': 57721,
        'compare-2': 57722,
        'color-fill': 57723,
        'collision': 57724,
        'curriculum': 57725,
        'chart-axis': 57726,
        'full-stacked-chart': 57727,
        'full-stacked-column-chart': 57728,
        'vertical-bar-chart-2': 57729,
        'horizontal-bar-chart-2': 57730,
        'horizontal-stacked-chart': 57731,
        'vertical-stacked-chart': 57732,
        'choropleth-chart': 123269,
        'geographic-bubble-chart': 123270,
        'multiple-radar-chart': 57735,
        'radar-chart': 57736,
        'crossed-line-chart': 57737,
        'multiple-line-chart': 57738,
        'multiple-bar-chart': 57739,
        'line-chart': 57740,
        'line-chart-dual-axis': 57741,
        'bubble-chart': 57742,
        'scatter-chart': 57743,
        'multiple-pie-chart': 57744,
        'column-chart-dual-axis': 57745,
        'tag-cloud-chart': 57746,
        'area-chart': 57747,
        'cause': 57748,
        'cart-3': 57749,
        'cart-2': 57750,
        'bus-public-transport': 57751,
        'burglary': 57752,
        'building': 57753,
        'border': 57754,
        'bookmark': 57755,
        'badge': 57756,
        'attachment-audio': 57757,
        'attachment-video': 57758,
        'attachment-html': 57759,
        'attachment-photo': 57760,
        'attachment-e-pub': 57761,
        'attachment-zip-file': 57762,
        'attachment-text-file': 57763,
        'add-equipment': 57764,
        'add-activity': 123301,
        'activity-individual': 57766,
        'activity-2': 123303,
        'add-activity-2': 123304,
        'activity-items': 57769,
        'activity-assigned-to-goal': 57770,
        'status-completed': 57771,
        'status-positive': 57771,
        'status-error': 57772,
        'status-negative': 57772,
        'status-inactive': 57773,
        'status-in-process': 57774,
        'status-critical': 57774,
        'blank-tag-2': 57775,
        'cart-full': 57776,
        'locate-me': 57777,
        'paging': 57778,
        'company-view': 57779,
        'document-text': 57780,
        'explorer': 57781,
        'personnel-view': 57782,
        'sorting-ranking': 57783,
        'drill-down': 57784,
        'drill-up': 57785,
        'vds-file': 57786,
        'sap-logo-shape': 123323,
        'folder-full': 57788,
        'system-exit': 57789,
        'system-exit-2': 57790,
        'close-command-field': 57791,
        'open-command-field': 57792,
        'sys-enter-2': 123329,
        'sys-enter': 123330,
        'sys-help-2': 123331,
        'sys-help': 123332,
        'sys-back': 57797,
        'sys-back-2': 57798,
        'sys-cancel': 57799,
        'sys-cancel-2': 57800,
        'open-folder': 57801,
        'sys-find-next': 57802,
        'sys-find': 57803,
        'sys-monitor': 57804,
        'sys-prev-page': 57805,
        'sys-first-page': 57806,
        'sys-next-page': 57807,
        'sys-last-page': 57808,
        'generate-shortcut': 57809,
        'create-session': 57810,
        'display-more': 57811,
        'enter-more': 57812,
        'zoom-in': 57813,
        'zoom-out': 57814,
        'header': 57815,
        'detail-view': 57816,
        'show-edit': 57816,
        'collapse': 57817,
        'expand': 57818,
        'positive': 57819,
        'negative': 57820,
        'display': 57821,
        'menu2': 57822,
        'redo': 57823,
        'undo': 57824,
        'navigation-up-arrow': 57825,
        'navigation-down-arrow': 57826,
        'down': 57827,
        'up': 57828,
        'shelf': 57829,
        'background': 57830,
        'resize': 57831,
        'move': 57832,
        'show': 57833,
        'hide': 57834,
        'nav-back': 57835,
        'error': 57836,
        'slim-arrow-right': 57837,
        'slim-arrow-left': 57838,
        'slim-arrow-down': 57839,
        'slim-arrow-up': 57840,
        'forward': 57841,
        'overflow': 57842,
        'value-help': 57843,
        'multi-select': 123380,
        'exit-full-screen': 57845,
        'sys-add': 57846,
        'sys-minus': 57847,
        'dropdown': 57848,
        'expand-group': 57849,
        'collapse-group': 57856,
        'vertical-grip': 57850,
        'horizontal-grip': 57851,
        'sort-descending': 57852,
        'sort-ascending': 57853,
        'arrow-down': 57854,
        'legend': 57855,
        'message-warning': 57857,
        'message-information': 123394,
        'message-success': 123395,
        'restart': 57860,
        'stop': 57861,
        'add-process': 57862,
        'cancel-maintenance': 57863,
        'activate': 57864,
        'resize-horizontal': 57865,
        'resize-vertical': 57866,
        'connected': 57867,
        'disconnected': 57868,
        'edit-outside': 57869,
        'key': 57870,
        'minimize': 57871,
        'back-to-top': 57872,
        'hello-world': 57873,
        'outbox': 57874,
        'donut-chart': 57875,
        'heatmap-chart': 57876,
        'horizontal-bullet-chart': 57877,
        'vertical-bullet-chart': 57878,
        'call': 57879,
        'download-from-cloud': 57880,
        'upload-to-cloud': 57881,
        'jam': 57882,
        'sap-ui5': 57883,
        'message-popup': 57884,
        'cloud': 57885,
        'horizontal-waterfall-chart': 123422,
        'vertical-waterfall-chart': 123423,
        'broken-link': 57888,
        'headset': 57889,
        'thumb-up': 123426,
        'thumb-down': 123427,
        'multiselect-all': 123428,
        'multiselect-none': 123429,
        'scissors': 57894,
        'sound': 123431,
        'sound-loud': 123432,
        'sound-off': 123433,
        'date-time': 123434,
        'user-settings': 57899,
        'key-user-settings': 57900,
        'developer-settings': 57901,
        'text-formatting': 123438,
        'bold-text': 123439,
        'italic-text': 123440,
        'underline-text': 123441,
        'text-align-justified': 123442,
        'text-align-left': 123443,
        'text-align-center': 123444,
        'text-align-right': 123445,
        'bullet-text': 123446,
        'numbered-text': 123447,
        'co': 57912,
        'ui-notifications': 57913,
        'bell': 57914,
        'cancel-share': 57915,
        'write-new-document': 57916,
        'write-new': 57917,
        'cancel': 123454,
        'screen-split-one': 57919,
        'screen-split-two': 57920,
        'screen-split-three': 57921,
        'customize': 57922,
        'user-edit': 57923,
        'source-code': 57924,
        'copy': 57925,
        'paste': 57926,
        'line-chart-time-axis': 123463,
        'clear-filter': 57928,
        'reset': 57929,
        'trend-up': 57930,
        'trend-down': 57931,
        'cursor-arrow': 57932,
        'add-document': 57933,
        'create-form': 57934,
        'resize-corner': 57935,
        'chevron-phase': 57936,
        'chevron-phase-2': 57937,
        'rhombus-milestone': 57938,
        'rhombus-milestone-2': 57939,
        'circle-task': 57940,
        'circle-task-2': 57941,
        'project-definition-triangle': 57942,
        'project-definition-triangle-2': 57943,
        'master-task-triangle': 57944,
        'master-task-triangle-2': 57945,
        'program-triangles': 57946,
        'program-triangles-2': 57947,
        'mirrored-task-circle': 57948,
        'mirrored-task-circle-2': 57949,
        'checklist-item': 57950,
        'checklist-item-2': 57951,
        'checklist': 57952,
        'checklist-2': 57953,
        'chart-table-view': 57954,
        'filter-analytics': 57955,
        'filter-facets': 57956,
        'filter-fields': 57957,
        'indent': 57958,
        'outdent': 57959,
        'heading1': 123496,
        'heading2': 123497,
        'heading3': 123498,
        'decrease-line-height': 57963,
        'increase-line-height': 57964,
        'fx': 123501,
        'add-folder': 57966,
        'away': 57967,
        'busy': 57968,
        'appear-offline': 57969,
        'blur': 57970,
        'pixelate': 57971,
        'horizontal-combination-chart': 57972,
        'add-employee': 57973,
        'text-color': 123510,
        'browse-folder': 57975,
        'primary-key': 57976,
        'two-keys': 57977,
        'strikethrough': 57978,
        'text': 57979,
        'responsive': 57980,
        'desktop-mobile': 57981,
        'table-row': 57982,
        'table-column': 57983,
        'validate': 123520,
        'keyboard-and-mouse': 57985,
        'touch': 57986,
        'expand-all': 57987,
        'collapse-all': 57988,
        'combine': 57989,
        'split': 57990
    }
};
var oCoreResourceBundle;
function getCoreResourceBundle() {
    if (!oCoreResourceBundle) {
        oCoreResourceBundle = sap.ui.getCore().getLibraryResourceBundle('sap.ui.core');
    }
    return oCoreResourceBundle;
}
var Icon;
var IconPool = {};
IconPool.createControlByURI = function (setting, constructor) {
    if (typeof setting === 'string') {
        setting = { src: setting };
    }
    if (setting && setting.src) {
        var sSrc = setting.src, fnConstructor = constructor;
        if (IconPool.isIconURI(sSrc)) {
            Icon = Icon || sap.ui.requireSync('sap/ui/core/Icon');
            fnConstructor = Icon;
            if (setting.tap) {
                setting.press = setting.tap;
                delete setting.tap;
            }
        }
        if (typeof fnConstructor === 'function') {
            setting = fnConstructor.getMetadata().removeUnknownSettings(setting);
            return new fnConstructor(setting);
        }
    }
};
IconPool.addIcon = function (iconName, collectionName, iconInfo) {
    if (typeof iconInfo === 'string') {
        iconInfo = {
            fontFamily: arguments[2],
            content: arguments[3],
            overWrite: !!arguments[4],
            suppressMirroring: !!arguments[5]
        };
    }
    if (typeof collectionName !== 'string') {
        collectionName = String(collectionName);
    }
    collectionName = collectionName === 'undefined' ? undefined : collectionName;
    if (!mRegistry[collectionName]) {
        mRegistry[collectionName] = {};
    }
    var collection = mRegistry[collectionName], icon = collection[iconName], parts, sContent, sText, sKey;
    if (icon) {
        if (collectionName === undefined) {
            Log.warning('Icon with name \'' + iconName + '\' in built-in collection already exists and can not be overwritten.', 'sap.ui.core.IconPool');
            return;
        } else if (!iconInfo.overWrite) {
            Log.warning('Icon with name \'' + iconName + '\' in collection \'' + collectionName + '\' already exists. Specify \'iconInfo.overWrite\' in order to overwrite.', 'sap.ui.core.IconPool');
            return;
        }
    }
    parts = {
        protocol: ICON_PROTOCOL,
        hostname: collectionName || iconName,
        path: collectionName ? iconName : undefined
    };
    if (Array.isArray(iconInfo.content)) {
        sContent = iconInfo.content.map(makeChar).join('');
    } else {
        sContent = makeChar(iconInfo.content);
    }
    if (iconInfo.resourceBundle instanceof ResourceBundle) {
        sKey = 'Icon.' + iconName;
        if (iconInfo.resourceBundle.hasText(sKey)) {
            sText = iconInfo.resourceBundle.getText(sKey);
        }
    }
    icon = collection[iconName] = {
        name: iconName,
        collection: collectionName,
        uri: URI.build(parts),
        fontFamily: iconInfo.fontFamily,
        content: sContent,
        text: sText || '',
        suppressMirroring: iconInfo.suppressMirroring,
        skipMirroring: iconInfo.suppressMirroring
    };
    return icon;
};
IconPool.getIconURI = function (iconName, collectionName) {
    var icon = this.getIconInfo(iconName, collectionName);
    return icon && icon.uri;
};
IconPool.getIconInfo = function (iconName, collectionName, loadingMode) {
    var parts, info, async, nameIsURI = IconPool.isIconURI(iconName);
    if (!iconName) {
        return;
    }
    if (!loadingMode && nameIsURI) {
        loadingMode = collectionName;
    }
    loadingMode = loadingMode || 'sync';
    async = loadingMode === 'async' || loadingMode === 'mixed';
    function getInfo() {
        var collection = mRegistry[collectionName];
        var info = collection && collection[iconName];
        if (typeof info === 'number') {
            mRegistry[collectionName][iconName] = undefined;
            info = IconPool.addIcon(iconName, collectionName, {
                fontFamily: mFontRegistry[collectionName].config.fontFamily,
                content: info & 65535,
                suppressMirroring: !!(info & 65536),
                resourceBundle: getCoreResourceBundle()
            });
        }
        return info;
    }
    if (nameIsURI) {
        parts = URI.parse(iconName);
        if (parts.path.length === 1) {
            collectionName = undefined;
            iconName = parts.hostname;
        } else {
            collectionName = parts.hostname;
            iconName = parts.path.slice(1);
        }
        if (!iconName) {
            return;
        }
    }
    if (typeof collectionName !== 'string') {
        collectionName = String(collectionName);
    }
    collectionName = collectionName === 'undefined' ? undefined : collectionName;
    if (collectionName === undefined && !mFontRegistry[collectionName].inserted) {
        IconPool.insertFontFaceStyle();
    }
    info = getInfo();
    if (info === undefined && collectionName !== undefined) {
        var oLoaded = IconPool._loadFontMetadata(collectionName, async);
    }
    if (async) {
        if (oLoaded) {
            return oLoaded.then(function () {
                info = getInfo();
                if (!info) {
                    Log.warning('Icon info for icon \'' + iconName + '\' in collection \'' + collectionName + '\' could not be fetched');
                }
                return info;
            });
        } else {
            if (loadingMode === 'async') {
                return Promise.resolve(info);
            } else {
                info = getInfo();
            }
        }
    } else {
        info = getInfo();
    }
    if (!info) {
        Log.warning('Icon info for icon \'' + iconName + '\' in collection \'' + collectionName + '\' could not be fetched');
    }
    return info;
};
IconPool.fontLoaded = function (sCollectionName) {
    if (mFontRegistry[sCollectionName]) {
        if (mFontRegistry[sCollectionName].metadataLoaded instanceof Promise) {
            return mFontRegistry[sCollectionName].metadataLoaded;
        } else if (mFontRegistry[sCollectionName].metadataLoaded === true) {
            return Promise.resolve();
        }
    }
};
IconPool.isIconURI = function (uri) {
    if (!uri) {
        return false;
    }
    var parts = URI.parse(uri);
    return parts.protocol === ICON_PROTOCOL && !!parts.hostname;
};
IconPool.getIconCollectionNames = function () {
    return Object.keys(mRegistry);
};
IconPool.getIconNames = function (collectionName) {
    var collection = mRegistry[collectionName];
    return collection ? Object.keys(collection) : [];
};
IconPool.insertFontFaceStyle = function (sFontFace, sPath, sCollectionName) {
    sFontFace = sFontFace || SAP_ICON_FONT_FAMILY$1;
    if (sCollectionName === undefined && sFontFace !== SAP_ICON_FONT_FAMILY$1) {
        sCollectionName = sFontFace;
    }
    if (!mFontRegistry[sCollectionName]) {
        Log.error('Icon font \'' + sCollectionName + '\' has not been registered yet.');
        return;
    }
    if (mFontRegistry[sCollectionName].inserted) {
        if (sCollectionName === undefined) {
            Log.info('The font face style of standard icon font was already inserted.');
        } else {
            Log.info('The font face style of icon font \'' + sCollectionName + '\' was already inserted.');
        }
        return;
    }
    if (sFontFace === SAP_ICON_FONT_FAMILY$1 && sCollectionName !== undefined) {
        Log.error('Must not overwrite the standard icon set with \'' + sCollectionName + '\'.');
        return;
    }
    var sFontPath = sPath || sap.ui.require.toUrl('sap/ui/core/themes/base/fonts/');
    var sFontFaceCSS = '@font-face {' + 'font-family: \'' + sFontFace + '\';' + 'src: url(\'' + sFontPath + sFontFace + '.woff2\') format(\'woff2\'),' + 'url(\'' + sFontPath + sFontFace + '.woff\') format(\'woff\'),' + 'url(\'' + sFontPath + sFontFace + '.ttf\') format(\'truetype\'),' + 'local(\'' + sFontFace + '\');' + 'font-weight: normal;' + 'font-style: normal;' + '}';
    var style = document.createElement('style');
    style.type = 'text/css';
    style.textContent = sFontFaceCSS;
    document.head.appendChild(style);
    mFontRegistry[sCollectionName].inserted = true;
    mFontRegistry[sCollectionName].fontFace = sFontFace;
};
IconPool.registerFont = function (oConfig) {
    oConfig.collectionName = oConfig.collectionName || oConfig.fontFamily;
    if (!oConfig.fontURI) {
        Log.error('The configuration parameter fontURI is missing, cannot register the font \'' + oConfig.collectionName + '\'!');
        return;
    }
    if (oConfig.fontFamily === SAP_ICON_FONT_FAMILY$1) {
        Log.error('The font family' + SAP_ICON_FONT_FAMILY$1 + ' is already registered');
        return;
    }
    if (oConfig.fontURI.substr(oConfig.fontURI.length - 1) !== '/') {
        oConfig.fontURI += '/';
    }
    if (!mFontRegistry[oConfig.collectionName] || mFontRegistry[oConfig.collectionName].metadataLoaded === false) {
        mFontRegistry[oConfig.collectionName] = {
            config: oConfig,
            inserted: false
        };
    } else {
        Log.warning('The font \'' + oConfig.collectionName + '\' is already registered');
    }
    if (!oConfig.lazy) {
        IconPool._loadFontMetadata(oConfig.collectionName, true);
    }
};
IconPool._loadFontMetadata = function (collectionName, async) {
    var oConfig;
    if (mFontRegistry[collectionName]) {
        if (typeof mFontRegistry[collectionName].metadataLoaded === 'boolean') {
            return;
        }
        if (async && mFontRegistry[collectionName].metadataLoaded instanceof Promise) {
            return mFontRegistry[collectionName].metadataLoaded;
        }
        oConfig = mFontRegistry[collectionName].config;
    } else {
        if (!mRegistry[collectionName]) {
            Log.error('The font configuration for collection \'' + collectionName + '\' is not registered');
        }
        mFontRegistry[collectionName] = { metadataLoaded: false };
    }
    function loadFont(oFontMetadata) {
        for (var sKey in oFontMetadata) {
            oFontMetadata[sKey] = parseInt(oFontMetadata[sKey], 16);
        }
        mRegistry[collectionName] = oFontMetadata;
        IconPool.insertFontFaceStyle(oConfig.fontFamily, oConfig.fontURI, collectionName);
        mFontRegistry[collectionName].metadataLoaded = true;
    }
    if (oConfig) {
        if (oConfig.metadataURI === undefined) {
            oConfig.metadataURI = oConfig.fontURI + oConfig.fontFamily + '.json';
        }
        if (async && !oConfig.metadata) {
            if (mFontRegistry[collectionName].metadataLoaded instanceof Promise) {
                return mFontRegistry[collectionName].metadataLoaded;
            }
            var oPromise = new Promise(function (fnResolve) {
                if (mRegistry[collectionName] === undefined) {
                    mFontRegistry[collectionName].metadataLoadedResolve = fnResolve;
                    mFontRegistry[collectionName].metadataXhr = jQuery.ajax(oConfig.metadataURI, {
                        dataType: 'json',
                        success: function (oJSON) {
                            loadFont(oJSON);
                            delete mFontRegistry[collectionName].metadataXhr;
                            delete mFontRegistry[collectionName].metadataLoadedResolve;
                            fnResolve();
                        },
                        error: function (jqXHR, sStatus) {
                            if (sStatus !== 'abort') {
                                Log.error('An error occurred loading the font metadata for collection \'' + collectionName + '\'');
                                mFontRegistry[collectionName].metadataLoaded = false;
                                fnResolve();
                            }
                        }
                    });
                }
            });
            mFontRegistry[collectionName].metadataLoaded = oPromise;
            return oPromise;
        } else {
            if (oConfig.metadataURI) {
                if (mFontRegistry[collectionName].metadataXhr) {
                    mFontRegistry[collectionName].metadataXhr.abort('Replaced by sync request');
                    mFontRegistry[collectionName].metadataXhr = null;
                }
                Log.warning('Synchronous loading of font meta data in IconPool, due to .getIconInfo() call' + ' for \'' + collectionName + '\'. Use loading mode \'async\' to avoid this call.', 'SyncXHR', null, function () {
                    return {
                        type: 'SyncXHR',
                        name: 'IconPool'
                    };
                });
                jQuery.ajax(oConfig.metadataURI, {
                    dataType: 'json',
                    async: false,
                    success: function (oJSON) {
                        loadFont(oJSON);
                        if (mFontRegistry[collectionName].metadataLoadedResolve) {
                            mFontRegistry[collectionName].metadataLoadedResolve();
                            delete mFontRegistry[collectionName].metadataLoadedResolve;
                        }
                    },
                    error: function () {
                        if (mFontRegistry[collectionName].metadataLoadedResolve) {
                            mFontRegistry[collectionName].metadataLoadedResolve();
                            delete mFontRegistry[collectionName].metadataLoadedResolve;
                        }
                        Log.error('An error occurred loading the font metadata for collection \'' + collectionName + '\'');
                        mFontRegistry[collectionName].metadataLoaded = false;
                    }
                });
            } else {
                loadFont(oConfig.metadata);
            }
        }
    }
};
var mIconForMimeType = {
    'application/msword': 'sap-icon://doc-attachment',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'sap-icon://doc-attachment',
    'application/rtf': 'sap-icon://doc-attachment',
    'application/pdf': 'sap-icon://pdf-attachment',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'sap-icon://excel-attachment',
    'application/vnd.ms-excel': 'sap-icon://excel-attachment',
    'application/msexcel': 'sap-icon://excel-attachment',
    'application/vnd.ms-powerpoint': 'sap-icon://ppt-attachment',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'sap-icon://ppt-attachment',
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': 'sap-icon://ppt-attachment',
    'application/mspowerpoint': 'sap-icon://ppt-attachment',
    'application/xml': 'sap-icon://attachment-html',
    'application/xhtml+xml': 'sap-icon://attachment-html',
    'application/x-httpd-php': 'sap-icon://attachment-html',
    'application/x-javascript': 'sap-icon://attachment-html',
    'application/gzip': 'sap-icon://attachment-zip-file',
    'application/x-rar-compressed': 'sap-icon://attachment-zip-file',
    'application/x-tar': 'sap-icon://attachment-zip-file',
    'application/zip': 'sap-icon://attachment-zip-file',
    'audio/voxware': 'sap-icon://attachment-audio',
    'audio/x-aiff': 'sap-icon://attachment-audio',
    'audio/x-midi': 'sap-icon://attachment-audio',
    'audio/x-mpeg': 'sap-icon://attachment-audio',
    'audio/x-pn-realaudio': 'sap-icon://attachment-audio',
    'audio/x-pn-realaudio-plugin': 'sap-icon://attachment-audio',
    'audio/x-qt-stream': 'sap-icon://attachment-audio',
    'audio/x-wav': 'sap-icon://attachment-audio',
    'image/png': 'sap-icon://attachment-photo',
    'image/tiff': 'sap-icon://attachment-photo',
    'image/bmp': 'sap-icon://attachment-photo',
    'image/jpeg': 'sap-icon://attachment-photo',
    'image/gif': 'sap-icon://attachment-photo',
    'text/plain': 'sap-icon://attachment-text-file',
    'text/comma-separated-values': 'sap-icon://attachment-text-file',
    'text/css': 'sap-icon://attachment-text-file',
    'text/html': 'sap-icon://attachment-text-file',
    'text/javascript': 'sap-icon://attachment-text-file',
    'text/richtext': 'sap-icon://attachment-text-file',
    'text/rtf': 'sap-icon://attachment-text-file',
    'text/tab-separated-values': 'sap-icon://attachment-text-file',
    'text/xml': 'sap-icon://attachment-text-file',
    'video/mpeg': 'sap-icon://attachment-video',
    'video/quicktime': 'sap-icon://attachment-video',
    'video/x-msvideo': 'sap-icon://attachment-video',
    'application/x-shockwave-flash': 'sap-icon://attachment-video'
};
IconPool.getIconForMimeType = function (sMimeType) {
    return mIconForMimeType[sMimeType] || 'sap-icon://document';
};
function makeChar(code) {
    return String.fromCharCode(typeof code === 'number' ? code : parseInt(code, 16));
}

// monkey patch the real insert function, we insert the font face style here
IconPool.insertFontFaceStyle = () => {};

const IconColors = {
	/**
	 * Default color (brand color)
	 * @public
	 */
	Default: "Default",

	/**
	 * Positive color
	 * @public
	 */
	Positive: "Positive",

	/**
	 * Negative color
	 * @public
	 */
	Negative: "Negative",

	/**
	 * Critical color
	 * @public
	 */
	Critical: "Critical",

	/**
	 * Neutral color.
	 * @public
	 */
	Neutral: "Neutral"
};


class IconColor extends DataType {

	static isValid(value) {
		return !!IconColors[value];
	}
}

IconColor.generataTypeAcessors(IconColors);

class IconTemplateContext {

	static calculate(state) {

		const commonVars = {
			iconInfo: IconPool.getIconInfo(state.src) || {},
			displayColor: IconTemplateContext.getDisplayColor(state),
			displayBackgroundColor: IconTemplateContext.getDisplayBackgroundColor(state)
		};

		let role = state.functional? 'button' : 'presentation';

		let context = {
			ctr: state,
			iconContent: commonVars.iconInfo.content,
			// ACC
			role: state._customAttributes["role"] || role,
			label: state.functional? IconTemplateContext.getIconLabel(state, commonVars) : undefined,
			ariaHidden: state.functional ? undefined : 'true',
			ariaExpanded: state._customAttributes["aria-expanded"],
			ariaLabelledBy: state._customAttributes["aria-labelledby"],
			tabIndex: state.functional && !state.noTabStop ? '0' : undefined,
			tooltip: IconTemplateContext.getTooltip(state, commonVars) || undefined,
			classes: {
				main: IconTemplateContext.getMainClasses(state, commonVars)
			},
			styles: {
				main: IconTemplateContext.getMainStyles(state, commonVars)
			}
		};

		return context;
	}

	static getMainClasses(state, commonVars) {
		let mainClasses = {
			"sapUiIcon": true,
			"sapUiIconActive": !!state._active,
			"sapUiIconMirrorInRTL": !commonVars.iconInfo.suppressMirroring,
			"sapUiIconPointer": state.functional
		};

		if (commonVars.displayColor in IconColor) {
			mainClasses["sapUiIconColor" + commonVars.displayColor] = true;
		}

		if (commonVars.displayBackgroundColor in IconColor) {
			mainClasses["sapUiIconBGColor" + commonVars.displayBackgroundColor] = true;
		}

		return mainClasses;
	}

	static getMainStyles(state, commonVars) {
		return {
			"font-family": "'" + commonVars.iconInfo.fontFamily + "'",
			"color": commonVars.displayColor && !(commonVars.displayColor in IconColor) ? commonVars.displayColor : null,
			"background-color": commonVars.displayBackgroundColor && !(commonVars.displayBackgroundColor in IconColor) ? commonVars.displayBackgroundColor : null
		}
	}

	static getDisplayColor(state) {

		let displayColor = state.color;

		if (state._active) {
			displayColor = state.activeColor || (state._hover && state.hoverColor) || state.color;
		} else if (state._hover) {
			displayColor = state.hoverColor || state.color;
		}

		return displayColor;
	}

	static getDisplayBackgroundColor(state) {
		let displayBackgroundColor = state.backgroundColor;

		if (state._active) {
			displayBackgroundColor = state.activeBackgroundColor || (state._hover && state.hoverBackgroundColor) || state.backgroundColor;
		} else if (state._hover) {
			displayBackgroundColor = state.hoverBackgroundColor || state.backgroundColor;
		}

		return displayBackgroundColor;
	}

	static getIconLabel(state, commonVars) {
		let label = state.alt || state.tooltip || (!state.skipIconTooltip && (commonVars.iconInfo.text || commonVars.iconInfo.name));
		let tooltip = IconTemplateContext.getTooltip(state, commonVars);

		if (label && label !== tooltip) {
			return label;
		}
	}

	/**
	 * Returns the string which is set to the 'title' attribute of the DOM output
	 * */
	static getTooltip(state, commonVars) {
		let tooltip = state.tooltip;

		if (!tooltip && state.skipIconTooltip && commonVars.iconInfo.text) {
			tooltip = commonVars.iconInfo.text;
		}

		return tooltip;
	}
}

const html$9 = index.html;

const IconLitRenderer = {};

const block0$8 = (context) => { return html$9`<span 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
		class="${index.ifTruthy(context.classes.main)}"
		style="${index.ifTruthy(context.styles.main)}"
		role="${index.ifTruthy(context.role)}"
		aria-label="${index.ifTruthy(context.label)}"
		tabindex="${index.ifTruthy(context.tabIndex)}"
		title="${index.ifTruthy(context.tooltip)}"
		data-sap-ui-icon-content="${index.ifTruthy(context.iconContent)}"
		aria-expanded="${index.ifTruthy(context.ariaExpanded)}"
		aria-labelledby="${index.ifTruthy(context.ariaLabelledBy)}"
></span>`; };
const renderMe$8 = block0$8;

IconLitRenderer.render = renderMe$8;

var iconBelize = "";

var inputIconBelize = "";

ShadowDOM.registerStyle("sap_belize", "Icon.css", iconBelize);
ShadowDOM.registerStyle("sap_belize", "InputIcon.css", inputIconBelize);

const metadata$a = {
	tag: "ui5-icon",
	styleUrl: [
		"Icon.css",
		"InputIcon.css"
	],
	properties: {
		/**
		 * This property should be set by the return value of calling sap.ui.core.IconPool.getIconURI with an Icon name parameter and an optional collection parameter which is required when using application extended Icons. A list of standard FontIcon is available here.
		 */
		src: { type: URI$1, defaultValue: null },

		/**
		 * Since Icon uses font, this property will be applied to the css font-size property on the rendered DOM element.
		 */
		size: { type: CSSSize, defaultValue: null },

		/**
		 * The color of the Icon. If color is not defined here, the Icon inherits the color from its DOM parent.
		 */
		color: { type: String, defaultValue: null },

		/**
		 * This color is shown when icon is hovered. This property has no visual effect when run on mobile device.
		 */
		hoverColor: { type: String, defaultValue: null },

		/**
		 * This color is shown when icon is pressed/activated by the user.
		 */
		activeColor: { type: String, defaultValue: null },

		/**
		 * This is the width of the DOM element which contains the Icon. Setting this property doesn't affect the size of the font. If you want to make the font bigger, increase the size property.
		 */
		width: { type: CSSSize, defaultValue: null },

		/**
		 * This is the height of the DOM element which contains the Icon. Setting this property doesn't affect the size of the font. If you want to make the font bigger, increase the size property.
		 */
		height: { type: CSSSize, defaultValue: null },

		/**
		 * Background color of the Icon in normal state.
		 */
		backgroundColor: { type: String, defaultValue: null },

		/**
		 * Background color for Icon in hover state. This property has no visual effect when run on mobile device.
		 */
		hoverBackgroundColor: { type: String, defaultValue: null },

		/**
		 * Background color for Icon in active state.
		 */
		activeBackgroundColor: { type: String, defaultValue: null },

		/**
		 * A decorative icon is included for design reasons. Accessibility tools will ignore decorative icons.
		 * Tab stop isn't affected by this property anymore and it's now controlled by the existence
		 * of press event handler and the noTabStop property.
		 */
		functional: { type: Boolean },

		/**
		 * Decides whether a default Icon tooltip should be used if no tooltip is set.
		 */
		skipIconTooltip: { type: Boolean },

		/**
		 * This defines the alternative text which is used for outputting the aria-label attribute on the DOM.
		 */
		alt: { type: String, defaultValue: null },

		/**
		 * Defines whether the tab stop of icon is controlled by the existence of press event handler. When it's set to false, Icon control has tab stop when press event handler is attached.
		 * If it's set to true, Icon control never has tab stop no matter whether press event handler exists or not.
		 */
		noTabStop: { type: Boolean },

		/**
		 * Specifies the tooltip of the control.
		 */
		tooltip: { type: String, defaultValue: "" },

		_hover: { type: Boolean },

		_active: { type: Boolean }
	},
	events: {
		press: {}
	},
	renderer: IconLitRenderer
};

class Icon$2 extends WebComponent {

	static get metadata() {
		return metadata$a;
	}

	static get renderer() {
		return IconLitRenderer;
	}

	static get calculateTemplateContext() {
		return IconTemplateContext.calculate;
	}

	constructor(state) {
		super(state);
	}

	onBeforeRendering() {
		this._state._hasPressListeners = true; //this.hasListeners('press');
	}

	// TODO tap vs click (do as in real control)
	ontap(_event) {
		this.fireEvent("press", {});
	}

	onkeypress(event) {
		if (event.which === mKeyCodes.SPACE || event.which === mKeyCodes.ENTER) {
			this.fireEvent("press", {});
		}
	}

	ondown(_event) {
		this._state._visualState === 'Active';
		this._activeIcon();
	}

	onup(_event) {
		this._inactiveIcon();
	}

	onfocusout(_event) {
		this._inactiveIcon();
	}

	onkeydown(event) {
		if (event.which === mKeyCodes.SPACE || event.which === mKeyCodes.ENTER) {
			this._activeIcon();
		}
	}

	onkeyup(event) {
		if (event.which === mKeyCodes.SPACE || event.which === mKeyCodes.ENTER) {
			this._inactiveIcon();
		}
	}

	_activeIcon() {
		this._active = true;
	}

	_inactiveIcon() {
		this._active = false;
	}

	_hoverIcon() {
		this._hover = true;
	}

	_restoreIcon() {
		this._hover = false;
		this._active = false;
	}

	onmouseover() {
		this._hoverIcon();
	}

	onmouseout() {
		this._restoreIcon();
	}

}

Core$1.boot().then(_ => {
	Icon$2.define();
});

const PopoverPlacementTypes = {
	/**
	 * Popover will be placed at the left side of the reference control.
	 * @public
	 */
	Left: "Left",

	/**
	 * Popover will be placed at the right side of the reference control.
	 * @public
	 */
	Right: "Right",

	/**
	 * Popover will be placed at the top of the reference control.
	 * @public
	 */
	Top: "Top",

	/**
	 * Popover will be placed at the bottom of the reference control.
	 * @public
	 */
	Bottom: "Bottom"
};

class PopoverPlacementType extends DataType {
	static isValid(value) {
		return !!PopoverPlacementTypes[value];
	}
}

PopoverPlacementType.generataTypeAcessors(PopoverPlacementTypes);

class PopoverTemplateContext {

	static calculate(state) {

		let placementType = state._actualPlacementType;

		let context = {
			ctr: state,
			headerId: state.hideHeader ? undefined : state._id + '-header',
			classes: {
				frame: {
					sapMPopupFrame: true,
					sapMPopupFrameOpen: state._isOpen
				},
				main: {
					sapMPopup: true,
					sapMPopover: true
				},
				blockLayer: {
					sapUiBLy: true,
					sapMPopupBlockLayer: true,
					sapMPopupBlockLayerHidden: !state.modal || state._hideBlockLayer
				},
				arrow: {
					sapMPopoverArr: true,
					sapMPopoverArrHidden: state.hideArrow,
					sapMPopoverArrLeft: placementType === PopoverPlacementType.Right,
					sapMPopoverArrRight: placementType === PopoverPlacementType.Left,
					sapMPopoverArrUp: placementType === PopoverPlacementType.Bottom,
					sapMPopoverArrDown: placementType === PopoverPlacementType.Top
				}
			},
			styles: {
				main: {
					left: state._left + "px",
					top: state._top + "px",
					width: state._width,
					height: state._height,
					"max-width": state._maxWidth + "px",
					"max-height": state._maxHeight + "px",
					"z-index": state._zIndex + 1
				},
				content: {
					"max-height": state._maxContentHeight + "px",
					"overflow-x": state.disableHorizontalScrolling ? "hidden" : "",
					"overflow-y": state.disableVerticalScrolling ? "hidden" : ""
				},
				arrow: {
					transform: "translate(" + state._arrowTranslateX + "px, " + state._arrowTranslateY + "px)"
				},
				blockLayer: {
					"z-index": state._zIndex
				}
			}
		};

		return context;
	}
}

const PopoverVerticalAligns = {
	Center: "Center",
	Top: "Top",
	Bottom: "Bottom",
	Stretch: "Stretch"
};


class PopoverVerticalAlign extends DataType {

	static isValid(value) {
		return !!PopoverVerticalAligns[value];
	}
}

PopoverVerticalAlign.generataTypeAcessors(PopoverVerticalAligns);

const PopoverHorizontalAligns = {
	Center: "Center",
	Left: "Left",
	Right: "Right",
	Stretch: "Stretch"
};

class PopoverHorizontalAlign extends DataType {

	static isValid(value) {
		return !!PopoverHorizontalAligns[value];
	}
}

PopoverHorizontalAlign.generataTypeAcessors(PopoverHorizontalAligns);

var rFocusable = /^(?:input|select|textarea|button)$/i,
	rClickable = /^(?:a|area)$/i;

class FocusHelper {

	static hasTabIndex(domElement) {

		if (domElement.disabled) {
			return false;
		}

		let tabIndex = domElement.getAttribute("tabindex");
		if (tabIndex !== null && tabIndex !== undefined) {
			return parseInt(tabIndex, 10) >= 0;
		}

		return rFocusable.test(domElement.nodeName) ||
			rClickable.test(domElement.nodeName) &&
			domElement.href;
	}

	static isHidden(domElement) {

		if (domElement.nodeName === 'SLOT') {
			return false;
		}

		let rect = domElement.getBoundingClientRect();

		return (domElement.offsetWidth <= 0 && domElement.offsetHeight <= 0)
			|| domElement.style.visibility === "hidden"
			||  (rect.width === 0 &&  0 && rect.height === 0);
	}

	static isVisible(domElement) {
		return !FocusHelper.isHidden(domElement);
	}

	static getCorrectElement(element) {
		if (element instanceof WebComponent) {
			// Focus the CustomElement itself or provide getDomRef of each ?
			return element.getFocusDomRef();
		}

		return element;
	}

	static findFocusableElement(container, forward) {
		let child;
		if (container.assignedNodes && container.assignedNodes()) {
			let assignedElements = container.assignedNodes();
			child = forward ? assignedElements[0] : assignedElements[assignedElements.length - 1];
		} else {
			child = forward ? container.firstChild : container.lastChild;
		}

		let focusableDescendant;

		while (child) {
			child = FocusHelper.getCorrectElement(child);
			if (!child) {
				return null;
			}

			if (child.nodeType === 1 && !FocusHelper.isHidden(child)) {

				if (FocusHelper.hasTabIndex(child)) {
					return child;
				}

				focusableDescendant = FocusHelper.findFocusableElement(child, forward);
				if (focusableDescendant) {
					return focusableDescendant;
				}
			}

			child = forward ? child.nextSibling : child.previousSibling;
		}

		return null;
	}

	static findFirstFocusableElement(container) {

		if (!container || FocusHelper.isHidden(container)) {
			return null;
		}

		return FocusHelper.findFocusableElement(container, true);
	}

	static findLastFocusableElement(container) {

		if (!container || FocusHelper.isHidden(container)) {
			return null;
		}

		return FocusHelper.findFocusableElement(container, false);
	}

	static hasTabbableContent(node) {
		let hasTabableContent = false,
			content = node.children;

		if (content) {
			hasTabableContent = FocusHelper._hasTabbableContent(content);
		}

		// If the node is inside Custom Element,
		// check the content in the 'light' DOM.
		if (!hasTabableContent && FocusHelper._isInsideShadowRoot(node)) {
			let customElement = FocusHelper._getCustomElement(node);
			let content = customElement.children;

			if (content) {
				hasTabableContent = FocusHelper._hasTabbableContent(content);
			}
		}

		return hasTabableContent;
	}

	static getLastTabbableElement(node) {
		let tabbableContent = FocusHelper.getTabbableContent(node);
		return tabbableContent.length ?  tabbableContent[tabbableContent.length - 1] : null;
	}

	static getTabbableContent(node) {
		let aTabbableContent = [],
			content = node.children;

		if (content) {
			aTabbableContent = FocusHelper._getTabbableContent(content);
		}

		if (FocusHelper._isInsideShadowRoot(node)) {
			let customElement = FocusHelper._getCustomElement(node);
			let content = customElement.children;

			if (content) {
				aTabbableContent = [...aTabbableContent, ...FocusHelper._getTabbableContent(content)];
			}
		}

		return aTabbableContent;
	}

	static _getTabbableContent(nodes) {
		let aTabbableContent = [];

		Array.from(nodes).forEach(node => {
			let currentNode = node;

			while (currentNode) {
				if (FocusHelper._hasShadowRoot(currentNode)) {
					// as the content is in the <span> template and it is always 2nd child
					let children = currentNode.shadowRoot.children;
					currentNode = children.length === 1 ? children[0] : children[1];
				}

				if (FocusHelper._isNodeTabbable(currentNode)) {
					aTabbableContent.push(currentNode);
				}
				currentNode = currentNode.children && currentNode.children.length && currentNode.children[0];
			}
		});

		return aTabbableContent.filter(FocusHelper.isVisible);
	}

	static _hasTabbableContent(nodes) {
		let hasTabableContent = false;

		Array.from(nodes).forEach(node => {
			let currentNode = node;

			while (currentNode && !hasTabableContent) {
				if (FocusHelper._hasShadowRoot(currentNode)) {
					// as the content is in the <span> template and it is always 2nd child
					let children = currentNode.shadowRoot.children;
					currentNode = children.length === 1 ? children[0] : children[1];
				}

				hasTabableContent = FocusHelper._isNodeTabbable(currentNode);
				currentNode = currentNode.children.length && currentNode.children[0];
			}
		});

		return hasTabableContent;
	}

	static _isNodeTabbable(node) {
		if (!node) {
			return false;
		}

		let nodeName = node.nodeName.toLowerCase();

		if (node.hasAttribute("data-sap-no-tab-ref")) {
			return false;
		}

		// special tags
		if (nodeName === 'a') {
			return !!node.href;
		}

		if (/input|select|textarea|button|object/.test(nodeName)) {
			return !node.disabled;
		}

		return FocusHelper.hasTabIndex(node);
	}

	static _hasShadowRoot(node) {
		return !!(node && node.shadowRoot);
	}

	static _isInsideShadowRoot(node) {
		return !!(node && node.getRootNode() && node.getRootNode().host);
	}

	static _getCustomElement(node) {
		return node.getRootNode().host;
	}
}

var belizePopup = "";

ShadowDOM.registerStyle("sap_belize", "Popup.css", belizePopup);

/**
 * @public
 */
const metadata$b = {
	abstract: true,
	slots: {
		/**
		 * Defines the content of the control.
		 * @type {HTMLElement}
		 * @public
		 */
		content: {
			type: HTMLElement,
			multiple: true
		},
		/**
		 * Defines the header control.
		 * @type {HTMLElement}
		 * @public
		 */
		header: {
			type: HTMLElement
		},

		/**
		 * Defines the footer control.
		 * @type {HTMLElement}
		 * @public
		 */
		footer: {
			type: HTMLElement
		}
	},
	properties: /** @lends  sap.ui.webcomponents.main.Popup.prototype */ {

		/**
		 * Defines the control, which will be focused, when the control is open.
		 * @type {Object}
		 * @public
		 */
		initialFocus: {
			type: Object,
			defaultValue: null,
			association: true
		},
		/**
		 * Defines if the header is hidden.
		 * @type {Boolean}
		 * @public
		 */
		hideHeader: {
			type: Boolean
		},
		/**
		 * Defines the header text.
		 * @type {string}
		 * @public
		 */
		headerText: {
			type: String,
			defaultValue: ''
		},

		/**
		 * Defines if user can scroll horizontally inside the popover when the content is bigger than the content area.
		 * @type {Boolean}
		 * @public
		 */
		disableHorizontalScrolling: {
			type: Boolean
		},
		/**
		 * Defines if user can scroll vertically inside the popover when the content is bigger than the content area.
		 * @type {Boolean}
		 * @public
		 */
		disableVerticalScrolling: {
			type: Boolean
		},
		_isOpen: {
			type: Boolean
		},
		_zIndex: {
			type: Integer
		},
		_hideBlockLayer: {
			type: Boolean
		}
	},
	events: {
		/**
		 * Fired before the control is opened.
		 * @public
		 * @event
		 */
		beforeOpen: {},
		/**
		 * Fired after the control is opened.
		 * @public
		 * @event
		 */
		afterOpen: {},
		/**
		 * Fired before the control is closed.
		 * @public
		 * @event
		 * @param {Boolean} escPressed Indicate that ESC key triggered the event.
		 */
		beforeClose: {
			escPressed: { type: Boolean }
		},
		/**
		 * Fired after the control is closed.
		 * @public
		 * @event
		 */
		afterClose: {}
	}
};

let currentZIndex = 100;
let openedPopups = [];
let isBodyScrollingDisabled = false;
let customBLyBackStyleInserted = false;

function getParentHost(node) {

	while (node && !node.host) {
		node = node.parentNode;
	}

	return node && node.host;
}

function createBLyBackStyle() {
	if (customBLyBackStyleInserted) {
		return;
	}

	customBLyBackStyleInserted = true;

	let stylesheet = document.styleSheets[0];
	stylesheet.insertRule('.sapUiBLyBack {overflow: hidden;position: fixed;width:100%;height: 100%;}', 0);
}

function updateBlockLayers() {
	let popup,
		i,
		hasModal = false;

	for (i = openedPopups.length - 1; i >= 0; i--) {
		popup = openedPopups[i];
		if (hasModal) {
			popup._hideBlockLayer = true;
		} else {
			if (popup.isModal()) {
				popup._hideBlockLayer = false;
				hasModal = true;
			}
		}
	}

	updateBodyScrolling(hasModal);
}

function updateBodyScrolling(hasModal) {

	if (isBodyScrollingDisabled === hasModal) {
		return;
	}

	createBLyBackStyle();

	if (hasModal) {
		document.body.style.top = -window.pageYOffset + 'px';
		document.body.classList.add("sapUiBLyBack");
	} else {
		document.body.classList.remove("sapUiBLyBack");
		window.scrollTo(0, -parseFloat(document.body.style.top));
		document.body.style.top = '';
	}

	isBodyScrollingDisabled = hasModal;
}

/**
 * @class
 * Represents a base class for all popup controls.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Popup
 * @public
 */
class Popup$1 extends WebComponent {

	static get metadata() {
		return metadata$b;
	}

	static getNextZIndex() {
		return currentZIndex += 2;
	}

	static hitTest(popup, event) {
		let indexOf = openedPopups.indexOf(popup);
		let openedPopup;

		for (let i = indexOf; i < openedPopups.length; i++) {
			openedPopup = openedPopups[i];
			if (openedPopup.hitTest(event)) {
				return true;
			}
		}

		return false;
	}

	static hasModalPopup() {
		for (let i = 0; i < openedPopups.length; i++) {
			if (openedPopups[i].isModal()) {
				return true;
			}
		}

		return false;
	}

	constructor(state) {
		super(state);

		this._documentKeyDownHandler = this.documentKeyDown.bind(this);
	}

	isTopPopup() {
		return openedPopups.indexOf(this) === openedPopups.length - 1;
	}

	isModal() {
		return true;
	}

	documentKeyDown(event) {
		if (event.keyCode === 27 && // escape key
			this.isTopPopup()) {
			this.escPressed = true;
			this.close();
		}
	}

	getPopupDomRef() {
		let domRef = this.getDomRef();
		return domRef && domRef.querySelector(".sapMPopup");
	}

	hitTest(_event) {
		return true;
	}

	open() {
		let cancelled = !this.fireEvent("beforeOpen", { });
		if (cancelled) {
			return true;
		}

		this._isFirstTimeRendered = false;

		this._zIndex = Popup$1.getNextZIndex();
		openedPopups.push(this);

		updateBlockLayers();

		document.addEventListener("keydown", this._documentKeyDownHandler, true);
	}

	close() {
		let cancelled = !this.fireEvent("beforeClose", {
			escPressed: this.escPressed
		}, true);

		this.escPressed = false;

		if (cancelled) {
			return true;
		}

		document.removeEventListener("keydown", this._documentKeyDownHandler, true);

		const index = openedPopups.indexOf(this);
		openedPopups.splice(index, 1);

		updateBlockLayers();
	}

	initInitialFocus() {
		let initialFocus = this.initialFocus;
		let initialFocusDomRef = this.initialFocus;

		if (typeof initialFocus === "string") {
			initialFocusDomRef = document.getElementById(initialFocus);

			if (!initialFocusDomRef) {
				let parentHost = getParentHost(this);
				if (parentHost) {
					initialFocusDomRef = parentHost.shadowRoot.querySelector('#' + initialFocus);
				}
			}

		} else if (initialFocus instanceof WebComponent) {
			initialFocusDomRef = initialFocus.getFocusDomRef();
		} else if (initialFocus instanceof HTMLElement) {
			initialFocusDomRef = initialFocus;
		}

		this._initialFocusDomRef = initialFocusDomRef;
	}

	onFirstTimeAfterRendering() {
		setTimeout(function() {
			if (this.isTopPopup()) {
				this.initInitialFocus();
				this.setInitialFocus(this.getPopupDomRef());
			}

			this.fireEvent("afterOpen", { });
		}.bind(this), 0);
	}

	onAfterRendering() {
		if (!this._isOpen) {
			return;
		}

		if (!this._isFirstTimeRendered) {
			this.onFirstTimeAfterRendering();
			this._isFirstTimeRendered = true;
		}
	}

	setInitialFocus(container) {

		if (this._initialFocusDomRef) {
			if (this._initialFocusDomRef !== document.activeElement) {
				this._initialFocusDomRef.focus();
			}
			return;
		}

		if (!container) {
			return;
		}

		const focusableElement = FocusHelper.findFirstFocusableElement(container);

		if (focusableElement) {
			focusableElement.focus();
		} else {
			container.focus();
		}
	}

	onfocusin(event) {
		this.preserveFocus(event, this.getPopupDomRef());
	}

	preserveFocus(event, container) {

		if (!this.isTopPopup()) {
			return;
		}

		let target = event.target;

		while(target.shadowRoot) {
			target = target.shadowRoot.activeElement;
		}

		let focusableElement;
		let isSpecialCase = false;

		switch (target.id) {
			case this._id + '-firstfe':
				focusableElement = FocusHelper.findLastFocusableElement(container);
				isSpecialCase = true;
				break;
			case this._id + '-lastfe':
				focusableElement = FocusHelper.findFirstFocusableElement(container);
				isSpecialCase = true;
				break;
			case this._id + '-blocklayer':
				focusableElement = this._currentFocusedElement || FocusHelper.findFirstFocusableElement(container);
				isSpecialCase = true;
				break;
		}

		if (focusableElement) {
			focusableElement.focus();
		} else if (isSpecialCase) {
			container.focus();
		}

		this._currentFocusedElement = focusableElement || document.activeElement;
	}

	storeCurrentFocus() {
		this._lastFocusableElement = document.activeElement;
	}

	resetFocus() {
		if (!this._lastFocusableElement) {
			return;
		}

		let lastFocusableElement = this._lastFocusableElement;
		if (lastFocusableElement) {
			lastFocusableElement.focus();
		}

		this._lastFocusableElement = null;
	}
}

const html$a = index.html;
const repeat$a = index.repeat;

const PopoverLitRenderer = {};

const block0$9 = (context) => { return html$a`<span 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}" class="${index.ifTruthy(context.classes.frame)}"><span id="${index.ifTruthy(context.ctr._id)}-firstfe" tabindex="0"></span><div style="${index.ifTruthy(context.styles.main)}" role="dialog" aria-labelledby="${index.ifTruthy(context.headerId)}" tabindex="-1" class="${index.ifTruthy(context.classes.main)}">			${ !context.ctr.hideHeader ? block1$6(context) : undefined }<div id="${index.ifTruthy(context.ctr._id)}-content" role="application" style="${index.ifTruthy(context.styles.content)}" class="sapMPopupContent"><div class="sapMPopupScroll">					${ repeat$a(context.ctr.content, undefined, (item, index$$1) => block4(item, index$$1, context)) }</div></div>			${ context.ctr.footer ? block5(context) : undefined }<span id="${index.ifTruthy(context.ctr._id)}-arrow" style="${index.ifTruthy(context.styles.arrow)}" class="${index.ifTruthy(context.classes.arrow)}"></span></div><span id="${index.ifTruthy(context.ctr._id)}-lastfe" tabindex="0"></span><div tabindex="0" id="${index.ifTruthy(context.ctr._id)}-blocklayer" style="${index.ifTruthy(context.styles.blockLayer)}" class="${index.ifTruthy(context.classes.blockLayer)}"></div></span>`; };
const block1$6 = (context) => { return html$a`<header>			${ context.ctr.header ? block2$2(context) : block3$1(context) }</header>	`; };
const block2$2 = (context) => { return html$a`<div role="toolbar" class="sapMPopupHeader"><slot name="${index.ifTruthy(context.ctr.header._slot)}"></slot></div>			`; };
const block3$1 = (context) => { return html$a`<h2 role="toolbar" class="sapMPopupHeader sapMPopupHeaderText">${index.ifTruthy(context.ctr.headerText)}</h2>			`; };
const block4 = (item, index$$1, context) => { return html$a`<slot name="${index.ifTruthy(item._slot)}"></slot>					`; };
const block5 = (context) => { return html$a`<footer><div class="sapMPopupFooter"><slot name="${index.ifTruthy(context.ctr.footer._slot)}"></slot></div></footer>	`; };
const renderMe$9 = block0$9;

PopoverLitRenderer.render = renderMe$9;

var popoverBelize = "";

ShadowDOM.registerStyle("sap_belize", "Popover.css", popoverBelize);

/**
 * @public
 */
const metadata$c = {
	tag: "ui5-popover",
	//lazy: true,
	styleUrl: ["Popup.css", "Popover.css"],
	properties: /** @lends  sap.ui.webcomponents.main.Popover.prototype */ {
		/**
		 * This is the information about on which side will the popover be placed at.
		 * @type {PopoverPlacementType}
		 * @public
		 */
		placementType: {
			type: PopoverPlacementType,
			defaultValue: PopoverPlacementType.Right
		},
		/**
		 * Defines the horizontal align of the Popover.
		 * @type {PopoverHorizontalAlign}
		 * @public
		 */
		horizontalAlign: {
			type: PopoverHorizontalAlign,
			defaultValue: PopoverHorizontalAlign.Center
		},
		/**
		 * Defines the vertical align of the Popover.
		 * @type {PopoverVerticalAlign}
		 * @public
		 */
		verticalAlign: {
			type: PopoverVerticalAlign,
			defaultValue: PopoverVerticalAlign.Center
		},
		/**
		 * Defines if the popover will be closed when tapping outside the popover.
		 * It also blocks any interaction with the background.
		 * @type {boolean}
		 * @public
		 */
		modal: {
			type: Boolean
		},
		/**
		 * Defines if Popover arrow is hidden.
		 * @type {boolean}
		 * @public
		 */
		hideArrow: {
			type: Boolean
		},

		_left: {
			type: Integer
		},
		_top: {
			type: Integer
		},

		_width: {
			type: String
		},
		_height: {
			type: String
		},

		_maxWidth: {
			type: Integer
		},
		_maxHeight: {
			type: Integer
		},

		_maxContentHeight: {
			type: Integer
		},

		_arrowTranslateX: {
			type: Integer,
			defaultValue: 0
		},

		_arrowTranslateY: {
			type: Integer,
			defaultValue: 0
		},
		_actualPlacementType: {
			type: PopoverPlacementType,
			defaultValue: PopoverPlacementType.Right
		}
	}
};

const diffTolerance = 32;
const dockInterval = 200;
const arrowSize = 8;

/**
 * @class
 * Displays additional information for an object in a compact way.
 *
 * <h3>Overview</h3>
 * The Popover displays additional information for an object in a compact way and without leaving the page.
 * The Popover can contain various UI elements such as fields, tables, images, and charts.
 * It can also include actions in the footer.
 *
 * <h3>Structure</h3>
 * The popover has three main areas:
 * <ul>
 * <li>Header (optional) - with a back button and a title</li>
 * <li>Content - holds all the controls</li>
 * <li>Footer (optional) - with additional action buttons</li>
 * </ul>
 *
 * <h4>Guidelines</h4>
 * <ul>
 * <li>Do not overlap popovers.</li>
 * <li>You can determine the PlacementType of the popover relative to the control that opens it.</li>
 * <li>Ensure that the content has a basic design and shows only the most important information.</li>
 * </ul>
 * The popover is closed when the user clicks or taps outside the popover
 * or selects an action within the popover. You can prevent this with the <code>modal</code> property.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Popover
 * @public
 */
class Popover$1 extends Popup$1 {

	static get metadata() {
		return metadata$c;
	}

	static get renderer() {
		return PopoverLitRenderer;
	}

	constructor(state) {
		super(state);

		this._documentMouseDownHandler = this.documentMouseDown.bind(this);
	}

	isModal() {
		return this.modal;
	}

	static isInRect(x, y, rect) {
		return x >= rect.left && x <= rect.right &&
			y >= rect.top && y <= rect.bottom;
	}

	static getClientRect(domRef) {
		let rect = domRef.getBoundingClientRect();
		let computedStyle = window.getComputedStyle(domRef);

		let offsetLeft = parseFloat(computedStyle.marginLeft) + parseFloat(computedStyle.paddingLeft);
		let offsetRight = parseFloat(computedStyle.marginRight) + parseFloat(computedStyle.paddingRight);
		let offsetTop = parseFloat(computedStyle.marginTop) + parseFloat(computedStyle.paddingTop);
		let offsetBottom = parseFloat(computedStyle.marginBottom) + parseFloat(computedStyle.paddingBottom);

		return {
			left: rect.left + offsetLeft,
			right: rect.right - offsetRight,
			top: rect.top + offsetTop,
			bottom: rect.bottom - offsetBottom,
			width: rect.width - offsetLeft - offsetRight,
			height: rect.height - offsetTop - offsetBottom
		};
	}

	hitTest(event) {
		let domRef = this.getPopupDomRef();
		let rect = domRef.getBoundingClientRect();
		let x, y;

		if (event.touches) {
			let touch = event.touches[0];
			x = touch.clientX;
			y = touch.clientY;
		} else {
			x = event.clientX;
			y = event.clientY;
		}

		// don't close the popover if the "initial focus" is outside the popover
		// and the user click/touch on it
		if (this.initialFocus && this._initialFocusDomRef) {
			let initialFocusRect = this._initialFocusDomRef.getBoundingClientRect();
			if (Popover$1.isInRect(x, y, initialFocusRect)) {
				return true;
			}
		}

		return Popover$1.isInRect(x, y, rect);
	}

	documentMouseDown(event) {
		if (!this.modal && !Popup$1.hitTest(this, event)) {
			this.close();
		}
	}

	checkDocking() {
		if (this.isTargetControlMoved()) {
			this.close();
		}

		let popoverDomRef = this.getPopupDomRef();

		let popoverSize = {
			width: popoverDomRef.offsetWidth,
			height: popoverDomRef.offsetHeight
		};

		let targetRect = Popover$1.getClientRect(this._targetControl);

		this.setLocation(targetRect, popoverSize);
	}

	getVerticalLeft(targetRect, popoverSize) {
		let left;

		switch (this.horizontalAlign) {
			case PopoverHorizontalAlign.Center:
			case PopoverHorizontalAlign.Stretch:
				left = targetRect.left - (popoverSize.width - targetRect.width) / 2;
				break;
			case PopoverHorizontalAlign.Left:
				left = targetRect.left;
				break;
			case PopoverHorizontalAlign.Right:
				left = targetRect.right - popoverSize.width;
				break;
		}

		return left;
	}

	getHorizontalTop(targetRect, popoverSize) {
		let top;

		switch (this.verticalAlign) {
			case PopoverVerticalAlign.Center:
			case PopoverVerticalAlign.Stretch:
				top = targetRect.top - (popoverSize.height - targetRect.height) / 2;
				break;
			case PopoverVerticalAlign.Top:
				top = targetRect.top;
				break;
			case PopoverVerticalAlign.Bottom:
				top = targetRect.bottom - popoverSize.height;
				break;
		}

		return top;
	}

	getActualPlacementType(targetRect, popoverSize) {

		let placementType = this.placementType;
		let actualPlacementType = placementType;

		let clientWidth = document.documentElement.clientWidth;
		let clientHeight = document.documentElement.clientHeight;

		switch (placementType) {
			case PopoverPlacementType.Top:
				if (targetRect.top < popoverSize.height &&
					targetRect.top < clientHeight - targetRect.bottom) {
					actualPlacementType = PopoverPlacementType.Bottom;
				}
				break;
			case PopoverPlacementType.Bottom:
				if (clientHeight - targetRect.bottom < popoverSize.height &&
					clientHeight - targetRect.bottom < targetRect.top) {
					actualPlacementType = PopoverPlacementType.Top;
				}
				break;
			case PopoverPlacementType.Left:
				if (targetRect.left < popoverSize.width &&
					targetRect.left < clientWidth - targetRect.right) {
					actualPlacementType = PopoverPlacementType.Right;
				}
				break;
			case PopoverPlacementType.Right:
				if (clientWidth - targetRect.right < popoverSize.width &&
					clientWidth - targetRect.right < targetRect.left) {
					actualPlacementType = PopoverPlacementType.Left;
				}
				break;
		}

		this._actualPlacementType = actualPlacementType;

		return actualPlacementType;
	}

	setLocation(targetRect, popoverSize) {

		let left = 0;
		let top = 0;

		let clientWidth = document.documentElement.clientWidth;
		let clientHeight = document.documentElement.clientHeight;

		let maxWidth = clientWidth;
		let maxHeight = clientHeight;

		let width = '';
		let height = '';

		let placementType = this.getActualPlacementType(targetRect, popoverSize);

		let isVertical = placementType === PopoverPlacementType.Top ||
			placementType === PopoverPlacementType.Bottom;

		if (this.horizontalAlign === PopoverHorizontalAlign.Stretch && isVertical) {
			popoverSize.width = targetRect.width;
			width = targetRect.width + "px";
		} else if (this.verticalAlign === PopoverVerticalAlign.Stretch && !isVertical) {
			popoverSize.height = targetRect.height;
			height = targetRect.height + "px";
		}

		this._width = width;
		this._height = height;

		let arrowOffset = this.hideArrow ? 0 : arrowSize;

		// calc popover positions
		switch (placementType) {
			case PopoverPlacementType.Top:
				left = this.getVerticalLeft(targetRect, popoverSize);
				top = Math.max(targetRect.top - popoverSize.height - arrowOffset, 0);

				maxHeight = targetRect.top - arrowOffset;
				break;
			case PopoverPlacementType.Bottom:

				left = this.getVerticalLeft(targetRect, popoverSize);
				top = targetRect.bottom + arrowOffset;

				maxHeight = clientHeight - targetRect.bottom - arrowOffset;
				break;
			case PopoverPlacementType.Left:
				left = Math.max(targetRect.left - popoverSize.width - arrowOffset, 0);
				top = this.getHorizontalTop(targetRect, popoverSize);

				maxWidth = targetRect.left - arrowOffset;
				break;
			case PopoverPlacementType.Right:
				left = targetRect.left + targetRect.width + arrowOffset;
				top = this.getHorizontalTop(targetRect, popoverSize);

				maxWidth = clientWidth - targetRect.right - arrowOffset;
				break;
		}

		// correct popover positions
		if (isVertical) {
			if (popoverSize.width > clientWidth || left < 0) {
				left = 0;
			} else if (left + popoverSize.width > clientWidth) {
				left -= left + popoverSize.width - clientWidth;
			}
		} else {
			if (popoverSize.height > clientHeight || top < 0) {
				top = 0;
			} else if (top + popoverSize.height > clientHeight) {
				top -= top + popoverSize.height - clientHeight;
			}
		}

		this._maxWidth = Math.round(maxWidth);
		this._maxHeight = Math.round(maxHeight);

		let maxContentHeight = this._maxHeight;

		if (!this.hideHeader) {
			let headerDomRef = this.getPopupDomRef().querySelector(".sapMPopoverTitle");
			if (headerDomRef) {
				maxContentHeight = Math.round(maxHeight - headerDomRef.offsetHeight);
			}
		}

		this._maxContentHeight = maxContentHeight;

		let arrowTranslateX = isVertical ? targetRect.left + targetRect.width / 2 - left - popoverSize.width / 2 : 0;
		let arrowTranslateY = !isVertical ? targetRect.top + targetRect.height / 2 - top - popoverSize.height / 2 : 0;

		this._arrowTranslateX = Math.round(arrowTranslateX);
		this._arrowTranslateY = Math.round(arrowTranslateY);

		if (this._left === undefined || Math.abs(this._left - left) > 1.5) {
			this._left = Math.round(left);
		}

		if (this._top === undefined || Math.abs(this._top - top) > 1.5) {
			this._top = Math.round(top);
		}
	}

	/**
	 * Opens the <code>Popover</code>.
	 * @param {object} control This is the control to which the Popover will be placed.
	 * The side of the placement depends on the placementType property set in the <code>Popover</code>.
	 * @public
	 **/
	openBy(control) {
		if (this._isOpen) {
			return;
		}

		let cancelled = super.open();
		if (cancelled) {
			return true;
		}

		this.storeCurrentFocus();

		let targetDomRef = control;

		/*
		if (control instanceof Control) {
			targetDomRef = control.getDomRef();
		} else if (control instanceof CustomElement) {
			targetDomRef = control.internalControl.getDomRef();
		}
		*/
		targetDomRef = control;

		let popoverSize = this.getPopoverSize();
		let targetRect = Popover$1.getClientRect(targetDomRef);

		this._targetControl = targetDomRef;
		this._targetRect = targetRect;

		this.setLocation(targetRect, popoverSize);

		this._isOpen = true;

		setTimeout(function () {
			if (this._isOpen) {
				this._dockInterval = setInterval(this.checkDocking.bind(this), dockInterval);
			}
		}.bind(this), 0);

		setTimeout(function () {
			if (this._isOpen) {
				document.addEventListener("mousedown", this._documentMouseDownHandler, true);
				document.addEventListener("touchstart", this._documentMouseDownHandler, true);
			}
		}.bind(this), 400);
	}

	/**
	 * Closes the <code>Popover</code>.
	 * @public
	 **/
	close() {
		if (!this._isOpen) {
			return;
		}

		let cancelled = super.close();
		if (cancelled) {
			return;
		}

		this._isOpen = false;

		clearInterval(this._dockInterval);

		document.removeEventListener("mousedown", this._documentMouseDownHandler, true);
		document.removeEventListener("touchstart", this._documentMouseDownHandler, true);

		this.resetFocus();

		this.fireEvent("afterClose", {});
	}

	getPopoverSize() {
		let popoverFrameDomRef = this.shadowRoot.querySelector(".sapMPopupFrame"); //this.getDomRef();
		let popoverDomRef = popoverFrameDomRef.querySelector(".sapMPopover");

		popoverFrameDomRef.style.visibility = "hidden";
		popoverFrameDomRef.style.display = "block";

		let width = popoverDomRef.offsetWidth;
		let height = popoverDomRef.offsetHeight;

		popoverFrameDomRef.style.display = "";
		popoverFrameDomRef.style.visibility = "visible";

		return {
			width: width,
			height: height
		}
	}

	isTargetControlMoved() {
		let newRect = this._targetControl.getBoundingClientRect();
		let targetRect = this._targetRect;

		return Math.abs(newRect.left - targetRect.left) > diffTolerance ||
			Math.abs(newRect.top - targetRect.top) > diffTolerance;
	}

	static get calculateTemplateContext() {
		return PopoverTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	Popover$1.define();
});

const InputTypes = {

	Text: "Text",

	Email: "Email",

	Number: "Number",

	Password: "Password",

	Tel: "Tel",

	URL: "URL"
};

class InputType extends DataType {

	static isValid(value) {
		return !!InputTypes[value];
	}
}

InputType.generataTypeAcessors(InputTypes);

const html$b = index.html;
const repeat$b = index.repeat;

const InputLitRenderer = {};

const block0$a = (context) => { return html$b`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"	aria-invalid="${index.ifTruthy(context.ariaInvalid)}"	aria-labelledBy="${index.ifTruthy(context.ariaLabelledBy)}"><div id="${index.ifTruthy(context.ctr._id)}-wrapper"	class="${index.ifTruthy(context.classes.wrapper)}"><input id="${index.ifTruthy(context.ctr._id)}-inner"			class="sapMInputBaseInner"			type="${index.ifTruthy(context.type)}"			?disabled="${index.ifTruthy(context.ctr.disabled)}"			?readonly="${index.ifTruthy(context._readOnly)}"			.value="${index.ifTruthy(context.ctr.value)}"			name="${index.ifTruthy(context.ctr.name)}"			placeholder="${index.ifTruthy(context.ctr.placeholder)}"			data-sap-no-tab-ref			data-sap-focus-ref	/>		${ context.ctr.icon ? block1$7(context) : undefined }</div>	${ context.ctr.showSuggestion ? block2$3(context) : undefined }</div>`; };
const block1$7 = (context) => { return html$b`<slot name="${index.ifTruthy(context.ctr.icon._slot)}"></slot>		`; };
const block2$3 = (context) => { return html$b`<ui5-popover				placement-type="Bottom"				hide-header="true"				hide-arrow="true"				horizontal-align="Stretch"				initial-focus="${index.ifTruthy(context.ctr._id)}-inner"			><ui5-list>						${ repeat$b(context.ctr.suggestionItems, undefined, (item, index$$1) => block3$2(item, index$$1, context)) }</ui5-list></ui5-popover>	`; };
const block3$2 = (item, index$$1, context) => { return html$b`<slot name="${index.ifTruthy(item._slot)}"></slot>						`; };
const renderMe$a = block0$a;

InputLitRenderer.render = renderMe$a;

class InputTemplateContext {

	static calculate(state) {
		let mainClasses = InputTemplateContext.getMainClasses(state);
		let wrapperClasses = InputTemplateContext.getWrapperClasses(state);

		let context = {
			ctr: state,
			_readOnly: state.readOnly && !state.disabled,
			classes: { main: mainClasses, wrapper: wrapperClasses},
			styles: {
				main: {"width": "100%"}
			},
			type: state.type.toLowerCase(),
			ariaInvalid: state.valueState === 'Error' ? 'true' : undefined
		};

		return context;
	}

	static getMainClasses(state) {
		return {
			"sapMInputBase": true,
			"sapMInputBaseWidthPadding": true,
			"sapMInputBaseDisabled": state.disabled,
			"sapMInputBaseReadonly": state.readOnly,
			"sapMInput": true,
			"sapMInputFocused": state._focused,
			"sapMFocus": state._focused
		};
	}

	static getWrapperClasses(state) {
		let hasState = state.valueState !== "None";

		let classes = {
			"sapMInputBaseContentWrapper": true,
			"sapMInputBaseDisabledWrapper": state.disabled,
			"sapMInputBaseReadonlyWrapper": state.readOnly && !state.disabled,
			"sapMInputBaseContentWrapperState": hasState
		};

		if (hasState) {
			classes[`sapMInputBaseContentWrapper${state.valueState}`] = true;
		}

		return classes;
	}
}

var inputBelize = "";

ShadowDOM.registerStyle("sap_belize", "Input.css", inputBelize);

/**
 * @public
 */
const metadata$d = {
	tag: "ui5-input",
	styleUrl: [
		"Input.css"
	],
	defaultSlot: "suggestionItems",
	slots: {

		/**
		 * Defines the <code>Icon</code> to be displayed in the <code>Input</code>.
		 * @type {Icon}
		 * @public
		 */
		icon: {
			type: Icon$2
		},

		/**
		 * Defines the <code>Input</code> suggestion items.
		 * <b>Note:</b> the suggestion items will be displayed,
		 * if the <code>showSuggestion</code> is set to true.
		 * @type {ListItem}
		 * @public
		 */
		suggestionItems: {
			type: HTMLElement,
			multiple: true
		}
	},
	properties: /** @lends  sap.ui.webcomponents.main.Input.prototype */  {

		/**
		 * Defines the disabled state of the <code>Input</code>.
		 * @type {boolean}
		 * @public
		 */
		disabled: {
			type: Boolean
		},

		/**
		 * Defines the <code>name</code> of the <code>Icon</code> for the purposes of form submission.
		 * @type {string}
		 * @public
		 */
		name: {
			defaultValue: null,
			type: String
		},

		/**
		 * Defines a short hint,
		 * intended to aid the user with data entry when the <code>Input</code> has no value.
		 * @type {string}
		 * @public
		 */
		placeholder: {
			defaultValue: null,
			type: String
		},

		/**
		 * Defines if the <code>Input</code> is read only, e.g. editable or not.
		 * @type {boolean}
		 * @public
		 */
		readOnly: {
			type: Boolean
		},

		/**
		 * Defines if the <code>Input</code> should show suggestions.
		 * @type {boolean}
		 * @public
		 */
		showSuggestion: {
			type: Boolean
		},

		/**
		 * Defines the minimum typed symbols in the <code>Input</code>,
		 * before the suggestion items are displayed.
		 * <b>Note:</> if set to 0, suggestion items will be dispalyed, when the <code>Input</code> gets focused.
		 * @type {number}
		 * @public
		 */
		startSuggestion: {
			type: Integer,
			defaultValue: 1
		},

		/**
		 * Defines the HTML type of the <code>Input</code> <code>type</code>.
		 * Available options are: Text: <code>Text</code>, <code>Email</code>, <code>Number</code>, <code>Password</code>, <code>Tel</code> and <code>URL</code>.
		 * <b>Note:</b> the particular effect of this property differs depending on the browser
		 * and the current language settings,especially for the type 'Number'.
		 * <b>Note:</b> this property is intended to be used with touch devices,
		 * that use different soft keyboard layouts depending on the given  <code>InpuType</code>.
		 * @type {string}
		 * @public
		 */
		type: {
			defaultValue: InputType.Text,
			type: InputType
		},

		/**
		 * Defines the value of the <code>Input</code>.
		 * @type {string}
		 * @public
		 */
		value: {
			defaultValue: "",
			type: String
		},

		/**
		 * Defines the value state of the <code>Input</code>.
		 * Available options are: None: <code>None</code>, <code>Success</code>, <code>Warning</code> and <code>Error</code>.
		 * @type {string}
		 * @public
		 */
		valueState: {
			type: ValueState,
			defaultValue: ValueState.None
		},

		_focused: {
			type: Boolean
		},

		_popover: {
			type: Object
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.Input.prototype */ {
		/**
		 * Fired, when the text in the <code>Input</code> value has changed
		 * and the focus leaves the input field or the <code>Enter</code> key is pressed.
		 * @event
		 * @param {string} value The current value of the <code>Input</code>.
		 * @public
		 */
		change: {
			detail : {
				value : {type : String}
			}
		},

		/**
		 * Fired, when the value of the <code>Input</code> changes at each keystroke
		 * and when <code>suggestionItem</code> has been selected.
		 * @event
		 * @param {string} value The current value of the <code>Input</code>.
		 * @public
		 */
		liveChange: {

			detail : {
				value : {type : String}
			}
		},

		/**
		 * Fired, when user presses the <code>Enter</code> key on the <code>Input</code>.
		 *
		 * <b>Note:</b>
		 * The event is fired independent of whether there was a change before or not.
		 * If change was performed, the event is fired after the change event.
		 * The event is also fired when an item of the select list is selected via <code>Enter</code>.
		 *
		 * @event
		 * @param {string} value The current value of the <code>Input</code>.
		 * @public
		 */
		submit: {
			detail : {
				value : {type : String}
			}
		},

		/**
		 * Fired, when a <code>suggestionItem</code>, displayed in suggestion popup is selected.
		 *
		 * @event
		 * @param {HTMLElement} the selected item.
		 * @public
		 */
		suggestionItemSelect: {
			detail : {
				item : {type : HTMLElement}
			}
		},

		/**
		 * Fired, when the user presses the <code>Icon</code> in the <code>Input</code>.
		 * @event
		 * @public
		 */
		iconPress: {}
	}
};

/**
 * @class
 * A class to represent an <code>Input</code>.
 *
 * <h3>Overview</h3>
 *
 * Allows the user to enter and edit text or numeric values in one line.
 * You can enable showSuggestion option to easily enter a valid value.
 * The suggestions are stored in two aggregations <code>suggestionItems</code>.
 *
 * <h3>Guidelines</h3>
 *
 * <ul>
 * <li> Always provide a meaningful label for any input field </li>
 * <li> Limit the length of the input field. This will visually emphasize the constraints for the field. </li>
 * <li> Do not use the <code>placeholder</code> property as a label.</li>
 * </ul>
 *
 * <h3>Usage</h3>
 *
 * <b>When to use:</b>
 * Use the control for short inputs like emails, phones, passwords, fields for assisted value selection.
 *
 * <b>When not to use:</b>
 * Don't use the control for long texts, dates, designated search fields, fields for multiple selection.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Input
 * @public
 */
class Input$1 extends WebComponent {

	static get metadata() {
		return metadata$d;
	}

	static get renderer() {
		return InputLitRenderer;
	}

	static get calculateTemplateContext() {
		return InputTemplateContext.calculate;
	}

	constructor(state) {
		super(state);

		this.iconPressHandler = this.iconPress.bind(this);

		// Indicates if there is selected suggestionItem.
		this.hasSuggestionItemSelected = false;

		// Indicates if there is focused suggestionItem.
		// Used to ignore the Input 'focusedOut' and this preventing firing 'change' event.
		this.hasSuggestionItemFocused = false;

		// A temporary value of the Input, stored between 'focusedOut' events.
		// Used to register and fire 'change' event,
		// Note: the property 'value' is updated upon each user input and can`t be used.
		this.tempValue = "";

		// Represents the value before user moves selection between the suggestion items.
		// Used to register and fire 'liveChange' event upon [SPACE] [ENTER].
		// Note: the property 'value' is updated selection move and can`t be used.
		this.valueBeforeItemSelection;

		// Indicates if the Input lost the focus.
		this.lostFocus = false;

		this.firstRendering = true;
	}

	onBeforeRendering() {
		this.initIcon();

		if (this.showSuggestion) {
			this.enableSuggestions();
		}
	}

	onAfterRendering() {
		if (!this.firstRendering && this.InputSuggestion) {
			this.InputSuggestion.updateSuggestionList(this.suggestionItems || []);
		}

		this.handleFocusOut();
		this.firstRendering = false;
	}

	onsapup(event) {
		if (this.InputSuggestion && this.InputSuggestion.isSuggestionListOpened()) {
			event.preventDefault();
			this.InputSuggestion.handleSuggestioItemsNavigation(false /* forward */);
		}
	}

	onsapdown(event) {
		if (this.InputSuggestion && this.InputSuggestion.isSuggestionListOpened()) {
			event.preventDefault();
			this.InputSuggestion.handleSuggestioItemsNavigation(true /* forward */);
		}
	}

	onsapright(event) {
		this.onsapdown(event);
	}

	onsapleft(event) {
		this.onsapup(event);
	}

	onsapspace(event) {
		if (this.InputSuggestion && this.InputSuggestion.isSuggestionItemOnTarget()) {
			event.preventDefault();
			this.InputSuggestion.onSuggestionItemSelected(null, true /* keyboardUsed */);
		}
	}

	onsapenter() {
		if (this.InputSuggestion && this.InputSuggestion.isSuggestionItemOnTarget()) {
			this.InputSuggestion.onSuggestionItemSelected(null, true /* keyboardUsed */);
			return;
		}

		this.onChange("submit");
	}

	onfocusin() {
		this._focused = true; // invalidating property
		this.lostFocus = false;
		this.hasSuggestionItemFocused = false;
	}

	onfocusout() {
		this._focused = false; // invalidating property
		this.lostFocus = true;
	}

	oninput() {
		this.onChange("input");
		this.hasSuggestionItemSelected = false;
		if (this.InputSuggestion) {
			this.InputSuggestion.selectedSuggestionItemIndex = null;
		}
	}

	onChange(eventType) {
		if (this.disabled || this.readonly) {
			return;
		}

		const inputValue = this.getInputValue();
		const valueChanged = this.tempValue !== inputValue;
		const isSubmit = eventType === "submit";

		this.value = inputValue;

		if (eventType === 'input') {
			this.fireEvent("liveChange", { value: inputValue });
			return;
		}

		if ((isSubmit || eventType === "focusOut") && valueChanged) {
			this.fireEvent("change", { value: inputValue });
			this.tempValue = inputValue;
		}

		if (isSubmit) {
			this.fireEvent("submit", { value: inputValue });
		}
	}

	handleFocusOut() {
		if (this.lostFocus && !this.hasSuggestionItemFocused) {
			this.onChange("focusOut");
		}
	}

	initIcon() {
		if (this.icon) {
			this.icon.removeEventListener("press", this.iconPressHandler);
			this.icon.addEventListener("press", this.iconPressHandler);
			this.icon._customClasses = ['sapMInputBaseIcon', 'sapMInputBaseIconPressed'];
		}
	}

	iconPress() {
		this.fireEvent('iconPress');
	}

	getInputValue() {
		const inputDOM = this.getDomRef();

		if (inputDOM) {
			return this.getInputDOMRef().value;
		}

		return "";
	}

	getInputDOMRef() {
		return this.getDomRef().querySelector(`#${this.getInputId()}`);
	}

	getLabelableElementId() {
		return this.getInputId();
	}

	getInputId() {
		return this._id + "-inner";
	}

	/* ================================= */
	/* InputSuggestion  handling         */
	/* ================================= */
	enableSuggestions() {
		if (this.InputSuggestion) {
			return;
		}

		try {
			this.InputSuggestion = Input$1.getInputSuggestion();
			this.InputSuggestion.enableSuggestionsFor(this);
		} catch(err) {
			throw new Error(`You have to import @openui5/sap.ui.webcomponents.main/src/sap/ui/webcomponents/main/InputSuggestion module to use input suggestions:: ${err}`);
		}
	}

	onSuggestionItemFocus() {
		this.hasSuggestionItemFocused = true;
	}

	onSuggestionItemSelected(item, keyboardUsed) {
		const itemText = item._nodeText;
		const fireLiveChange = keyboardUsed ? this.valueBeforeItemSelection !== itemText : this.value !== itemText;

		this.hasSuggestionItemSelected = true;
		this.fireEvent('suggestionItemSelect', { item: item });

		if (fireLiveChange) {
			this.fireEvent('liveChange', { value: itemText });
			this.value = itemText;
			this.valueBeforeItemSelection = itemText;
		}
	}

	onSuggestionItemPreview(previewText) {
		this.valueBeforeItemSelection = this.value;
		this.value = previewText;
	}
}

Core$1.boot().then(_ => {
	Input$1.define();
});

const html$c = index.html;

const DatePickerLitRenderer = {};

const block0$b = (context) => { return html$c`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
        class="${index.ifTruthy(context.classes.main)}"
        style="${index.ifTruthy(context.styles.main)}"
        dir="${index.ifTruthy(context.dir)}"
><!-- INPUT --><ui5-input
            id="${index.ifTruthy(context.ctr._id)}-inner"
            placeholder="${index.ifTruthy(context.ctr._input.placeholder)}"
            type="${index.ifTruthy(context.ctr._input.type)}"
            value="${index.ifTruthy(context.ctr._input.value)}"
            ?disabled="${index.ifTruthy(context.ctr._input.disabled)}"
            ?read-only="${index.ifTruthy(context.ctr._input.readonly)}"
            value-state="${index.ifTruthy(context.ctr._input.valueState)}"
            @iconPress="${index.ifTruthy(context.ctr._input.onIconPress)}"
            @change="${index.ifTruthy(context.ctr._input.onChange)}"
            @liveChange="${index.ifTruthy(context.ctr._input.onLiveChange)}"
    ><ui5-icon
                data-ui5-slot="icon"
                src="${index.ifTruthy(context.ctr._input.icon.src)}"
                functional="${index.ifTruthy(context.ctr._input.icon.functional)}"
                no-tab-stop="true"
        ></ui5-icon></ui5-input><!-- POPOVER --><ui5-popover
            id="${index.ifTruthy(context.ctr._id)}-popover"
            placement-type="${index.ifTruthy(context.ctr._popover.placementType)}"
            hide-header="${index.ifTruthy(context.ctr._popover.hideHeader)}"
            hide-arrow="${index.ifTruthy(context.ctr._popover.hideArrow)}"
            horizontal-align="${index.ifTruthy(context.ctr._popover.horizontalAlign)}"
            .customClasses="${index.ifTruthy(context.ctr._popover._customClasses)}"
            initial-focus="${index.ifTruthy(context.ctr._id)}-calendar"
    ><ui5-calendar
                id="${index.ifTruthy(context.ctr._id)}-calendar"
                data-ui5-slot="content"
                primary-calendar-type="${index.ifTruthy(context.ctr._calendar.primaryCalendarType)}"
                format-pattern="${index.ifTruthy(context.ctr._calendar.formatPattern)}"
                timestamp="${index.ifTruthy(context.ctr._calendar.timestamp)}"
                .selectedDates="${index.ifTruthy(context.ctr._calendar.selectedDates)}"
                @selectedDatesChange="${index.ifTruthy(context.ctr._calendar.onSelectedDatesChange)}"
        ></ui5-calendar></ui5-popover></div>`; };
const renderMe$b = block0$b;

DatePickerLitRenderer.render = renderMe$b;

var datepickerBelize = "";

var Gregorian = UniversalDate.extend("sap.ui.core.date.Gregorian", {
  constructor: function () {
    this.oDate = this.createDate(Date, arguments);
    this.sCalendarType = CalendarType.Gregorian;
  }
});
Gregorian.UTC = function () {
  return Date.UTC.apply(Date, arguments);
};
Gregorian.now = function () {
  return Date.now();
};
CalendarClassRegistry.setCalendarClass(CalendarType.Gregorian, Gregorian);

ShadowDOM.registerStyle("sap_belize", "DatePicker.css", datepickerBelize);

/**
 * @public
 */
const metadata$e = {
	tag: "ui5-datepicker",
	styleUrl: [
		"DatePicker.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.DatePicker.prototype */ {
		/**
		 * Defines a formatted date value.
		 * @type {string}
		 * @public
		 */
		value: {
			type: String,
			defaultValue: ""
		},
		/**
		 * Visualizes the validation state of the control, e.g. <code>Error</code>, <code>Warning</code>, <code>Success</code>.
		 * @type {string}
		 * @public
		 */
		valueState: {
			type: ValueState,
			defaultValue: ValueState.None
		},
		/**
		 * Determines the format, displayed in the input field.
		 * @type {string}
		 * @public
		 */
		formatPattern: {
			type: String
		},
		/**
		 * Determines the calendar type.
		 * The input value is formated according to the calendar type and the picker shows
		 * months and years from the specified calendar.
		 * @type {string}
		 * @public
		 */
		primaryCalendarType: {
			type: CalendarType$1,
			defaultValue: CalendarType$1.Gregorian
		},
		/**
		 * Defines the disabled state of the <code>DatePicker</code>.
		 * @type {boolean}
		 * @public
		 */
		disabled: {
			type: Boolean
		},
		/**
		 * Defines if the <code>DatePicker</code> is read only, e.g. editable or not.
		 * @type {boolean}
		 * @public
		 */
		readOnly: {
			type: Boolean
		},
		/**
		* Defines a short hint,
		* intended to aid the user with data entry when the <code>DatePicker</code> has no value.
		* @type {string}
		* @public
		*/
		placeholder: {
			defaultValue: null,
			type: String
		},
		_input: {
			type: Object
		},
		_popover: {
			type: Object
		},
		_calendar: {
			type: Object
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.DatePicker.prototype */ {

		/**
		 * @event
		 * @public
		*/
		change: {},
		/**
		 * Fired, whenever the <code>DatePicker</code> value is changed.
		 * @event
		 * @public
		*/
		liveChange: {}
	}
};

/**
 * @class
 *
 * A class to represent a <code>DatePicker</code>.
 *
 * Enables the users to select a localized date.
 *
 * <h3>Overview</h3>
 *
 * The <code>DatePicker</code> lets the users select a localized date using touch,
 * mouse, or keyboard input. It consists of two parts: the date input field and the
 * date picker.
 *
 * <h3>Usage</h3>
 *
 * The user can enter a date by:
 * <ul><li>Using the calendar that opens in a popup</li>
 * <li>Typing it in directly in the input field</li></ul>
 *
 * <h3>Formatting</h3>
 *
 * If a date is entered by typing it into
 * the input field, it must fit to the used date format.
 *
 * Supported format options are pattern-based on Unicode LDML Date Format notation.
 * See {@link http://unicode.org/reports/tr35/#Date_Field_Symbol_Table}
 *
 * For example, if the <code>format-pattern</code> is "yyyy-MM-dd",
 * a valid value string is "2015-07-30", the same is displayed in the input.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.DatePicker
 * @public
 */
class DatePicker$1 extends WebComponent {

	static get metadata() {
		return metadata$e;
	}

	static get renderer() {
		return DatePickerLitRenderer;
	}

	static get calculateTemplateContext() {
		return DatePickerTemplateContext.calculate;
	}


	constructor(state) {
		super(state);

		this._input = {};
		this._input.type = InputType.Text;
		this._input.icon = {};
		this._input.icon.src = IconPool.getIconURI("appointment-2");
		this._input.icon.functional = true;
		this._input.onIconPress = this._iconPress.bind(this);
		this._input.onChange = this.fireChange.bind(this);
		this._input.onLiveChange = this.fireLiveChange.bind(this);

		this._popover = {
			placementType: PopoverPlacementType.Bottom,
			hideHeader: true,
			hideArrow: true,
			horizontalAlign: PopoverHorizontalAlign.Right
		};

		this._calendar = {
			onSelectedDatesChange: this._handleCalendarSelectedDatesChange.bind(this),
			selectedDates: []
		};
	}

	onBeforeRendering() {
		this._popover._customClasses = [];

		if (this.isValid(this.value)) {
			this._input.value = this.normalizeValue(this.value);
		} else {
			this._input.value = this.value;
		}
		this._input.disabled = this.disabled;
		this._input.readonly = this.readOnly;
		this._input.placeholder = this.placeholder || "Enter Date ...";
		this._input.valueState = this.valueState;

		this._calendar.primaryCalendarType = this._primaryCalendarType;
		this._calendar.formatPattern = this._formatPattern;
	}

	_getInput() {
		return this.shadowRoot.querySelector("ui5-input");
	}

	onfocusin() {}

	fireChange() {
		let inputValue = this._getInput().getInputValue();
		let isValid = this.isValid(inputValue);

		if (isValid) {
			this.value = this.normalizeValue(inputValue);
		}

		this.fireEvent("change", {value: inputValue, valid: isValid});
	}

	fireLiveChange() {
		let inputValue = this._getInput().getInputValue();
		let isValid = this.isValid(inputValue);

		this.fireEvent("liveChange", {value: inputValue, valid: isValid});
	}

	isValid(sValue) {
		return !!this.getFormat().parse(sValue);
	}

	//because the parser understands more than one format
	//but we need values in one format
	normalizeValue(sValue) {
		return this.getFormat().format(this.getFormat().parse(sValue));
	}

	get validValue() {
		if (this.isValid(this.value)) {
			return this.value;
		} else {
			return this.getFormat().format(new Date());
		}
	}

	get _calendarDate() {
		const oCalDate = CalendarDate.fromLocalJSDate(this.getFormat().parse(this.validValue), this._primaryCalendarType);
		return oCalDate;
	}

	get _primaryCalendarType() {
		return this.primaryCalendarType || Core$1.getConfiguration().getCalendarType();
	}

	get _formatPattern() {
		return this.formatPattern || 'medium'; // get from config
	}

	get _isPattern() {
		return this._formatPattern !== "medium" && this._formatPattern !== "short" && this._formatPattern !== "long";
	}

	getFormat() {
		if (this._isPattern) {
			this._oDateFormat = DateFormat.getInstance({ pattern: this._formatPattern, calendarType: this._primaryCalendarType });
		} else {
			this._oDateFormat = DateFormat.getInstance({ style: this._formatPattern, calendarType: this._primaryCalendarType });
		}
		return this._oDateFormat;
	}

	_getPopover() {
		return this.shadowRoot.querySelector("ui5-popover");
	}

	_iconPress() {
		if (!this.disabled) {
			this._openPicker();
		}
	}

	_handleCalendarSelectedDatesChange(event) {
		const iNewValue = event.detail.dates && event.detail.dates[0];
		this.value = this.getFormat().format(CalendarDate.fromLocalJSDate(new Date(iNewValue * 1000), this._primaryCalendarType).toLocalJSDate());
		this._calendar.timestamp = iNewValue;
		this._calendar.selectedDates = event.detail.dates;
		this.fireEvent("change", {value: this.value, valid: true});
	}

	_openPicker() {

		const oCalDate = this._calendarDate;
		const timestamp = oCalDate.valueOf() / 1000;

		this._calendar = Object.assign({}, this._calendar);
		this._calendar.timestamp = timestamp;
		this._calendar.selectedDates = [timestamp];

		this._getPopover().openBy(this);
	}
}

Core$1.boot().then(async _ => {
	await Promise.all([
		fetchCldrData(Core$1.getConfiguration().getLocale().getLanguage(), Core$1.getConfiguration().getLocale().getRegion()),
		Icon$2.define(),
		Popover$1.define(),
		Calendar$1.define(),
		Input$1.define(),
	]);
	DatePicker$1.define();
});

class DialogTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			headerId: state.hideHeader ? undefined : state.id + '-header',
			classes: {
				frame: {
					sapMPopupFrame: true,
					sapMPopupFrameOpen: state._isOpen
				},
				dialogParent: {
					sapMDialogParent: true
				},
				main: {
					sapMPopup: true,
					sapMDialog: true,
					sapMDialogStretched: state.stretch
				},
				blockLayer: {
					sapUiBLy: true,
					sapMPopupBlockLayer: true,
					sapMPopupBlockLayerHidden: state._hideBlockLayer
				}
			},
			styles: {
				zindex: {
					"z-index": state._zIndex + 1
				},
				content: {
					"overflow-x": state.disableHorizontalScrolling ? "hidden" : "",
					"overflow-y": state.disableVerticalScrolling ? "hidden" : ""
				},
				blockLayer: {
					"z-index": state._zIndex
				}
			}
		};

		return context;
	}
}

const html$d = index.html;
const repeat$d = index.repeat;

const DialogLitRenderer = {};

const block0$c = (context) => { return html$d`<span 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}" class="${index.ifTruthy(context.classes.frame)}"><span id="${index.ifTruthy(context.ctr._id)}-firstfe" tabindex="0"></span><div style="${index.ifTruthy(context.styles.zindex)}" class="${index.ifTruthy(context.classes.dialogParent)}"><div tabindex="-1" aria-labelledby="${index.ifTruthy(context.headerId)}" role="dialog" class="${index.ifTruthy(context.classes.main)}">			${ !context.ctr.hideHeader ? block1$8(context) : undefined }<section class="sapMDialogSection"><div style="${index.ifTruthy(context.styles.content)}" class="sapMPopupContent"><div class="sapMPopupScroll">						${ repeat$d(context.ctr.content, undefined, (item, index$$1) => block4$1(item, index$$1, context)) }</div></div></section>			${ context.ctr.footer ? block5$1(context) : undefined }</div></div><span id="${index.ifTruthy(context.ctr._id)}-lastfe" tabindex="0"></span><div tabindex="0" id="${index.ifTruthy(context.ctr._id)}-blocklayer" style="${index.ifTruthy(context.styles.blockLayer)}" class="${index.ifTruthy(context.classes.blockLayer)}"></div></span>`; };
const block1$8 = (context) => { return html$d`<header>			${ context.ctr.header ? block2$4(context) : block3$3(context) }</header>	`; };
const block2$4 = (context) => { return html$d`<div role="heading" class="sapMPopupHeader"><slot name="${index.ifTruthy(context.ctr.header._slot)}"></slot></div>			`; };
const block3$3 = (context) => { return html$d`<h2 role="heading" class="sapMPopupHeader sapMPopupHeaderText">${index.ifTruthy(context.ctr.headerText)}</h2>			`; };
const block4$1 = (item, index$$1, context) => { return html$d`<slot name="${index.ifTruthy(item._slot)}"></slot>						`; };
const block5$1 = (context) => { return html$d`<footer><div class="sapMPopupFooter"><slot name="${index.ifTruthy(context.ctr.footer._slot)}"></slot></div></footer>	`; };
const renderMe$c = block0$c;

DialogLitRenderer.render = renderMe$c;

/**
 * @public
 */
const metadata$f = {
	tag: "ui5-dialog",
	styleUrl: [
		"Popup.css",
		"Dialog.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.Dialog.prototype */ {
		/**
		 * Determines if the Dialog will be stretched to full screen on mobile.
		 * On desktop, the Dialog will be stretched to 93% of the viewport.
		 * @type {Boolean}
		 * @public
		 */
		stretch: {
			type: Boolean
		}
	}
};

/**
 * @class
 * A popup that interrupts the current processing and prompts the user for an action or an input in a modal mode.
 *
 * <h3>Overview</h3>
 * The Dialog control is used to prompt the user for an action or a confirmation.
 * It interrupts the current app processing as it is the only focused UI element and the main screen is dimmed/blocked.
 * The content of the Dialog is fully customizable.
 *
 * <h3>Structure</h3>
 * A Dialog consists of a title, optional subtitle, content area and a footer for action buttons.
 * The Dialog is usually displayed at the center of the screen.
 *
 * <h3>Usage</h3>
 * <h4>When to use:</h4>
 * <ul>
 * <li>You want to display a system message.</li>
 * <li>You want to interrupt the user’s action.</li>
 * <li>You want to show a message with a short and a long description.</li>
 * </ul>
 * <h4>When not to use:</h4>
 * <ul>
 * <li>You just want to confirm a successful action.</li>
 * </ul>
 * <h3>Responsive Behavior</h3>
 * <ul>
 * <li>If the <code>stretch</code> property is set to <code>true</code>, the Dialog displays on full screen.</li>
 * </ul>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Dialog
 * @public
 */
class Dialog$2 extends Popup$1 {

	static get metadata() {
		return metadata$f;
	}

	static get renderer() {
		return DialogLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	/**
	* Opens the <code>Dialog</code>.
	* @public
	**/
	open() {
		if (this._isOpen) {
			return;
		}

		let cancelled = super.open();
		if (cancelled) {
			return true;
		}

		this.storeCurrentFocus();

		this._isOpen = true;
	}

	/**
	* Closes the <code>Dialog</code>.
	* @public
	**/
	close() {
		if (!this._isOpen) {
			return;
		}

		let cancelled = super.close();
		if (cancelled) {
			return;
		}

		this._isOpen = false;

		this.resetFocus();

		this.fireEvent("afterClose", { });
	}

	static get calculateTemplateContext() {
		return DialogTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	Dialog$2.define();
});

const ListModes = {
	/**
	 * Default mode (no selection).
	 * @public
	 */
	None: "None",

	/**
	 * Right-positioned single selection mode (only one list item can be selected).
	 * @public
	 */
	SingleSelect: "SingleSelect",

	/**
	 * Left-positioned single selection mode (only one list item can be selected).
	 * @public
	 */
	SingleSelectBegin: "SingleSelectBegin",

	/**
	 * Selected item is highlighted but no selection control is visible (only one list item can be selected).
	 * @public
	 */
	SingleSelectEnd: "SingleSelectEnd",

	/**
	 * Multi selection mode (more than one list item can be selected).
	 * @public
	 */
	MultiSelect: "MultiSelect",

	/**
	 * Delete mode (only one list item can be deleted via provided delete button)
	 * @public
	 */
	Delete: "Delete"
};

class ListMode extends DataType {

	static isValid(value) {
		return !!ListModes[value];
	}
}

ListMode.generataTypeAcessors(ListModes);

const BackgroundDesigns = {

	Solid: "Solid",

	Transparent: "Transparent",

	Translucent: "Translucent"
};

class BackgroundDesign extends DataType {
	static isValid(value) {
		return !!BackgroundDesigns[value];
	}
}

BackgroundDesign.generataTypeAcessors(BackgroundDesigns);

const ListSeparatorsTypes = {
	/**
	 * Separators between the items including the last and the first one.
	 * @public
	 */
	All: "All",

	/**
	 * Separators between the items.
	 * <b>Note:</b> This enumeration depends on the theme.
	 * @public
	 */
	Inner: "Inner",

	/**
	 * No item separators.
	 * @public
	 */
	None: "None"
};

class ListSeparators extends DataType {

	static isValid(value) {
		return !!ListSeparatorsTypes[value];
	}
}

ListSeparators.generataTypeAcessors(ListSeparatorsTypes);

/**
 * Different types of ListItem.
 */
const ListItemTypes = {
	/**
	 * Indicates the list item does not have any active feedback when item is pressed.
	 * @public
	 */
	Inactive: "Inactive",

	/**
	 * Indicates that the item is clickable via active feedback when item is pressed.
	 * @public
	 */
	Active: "Active"
};

class ListItemType extends DataType {
	static isValid(value) {
		return !!ListItemTypes[value];
	}
}

ListItemType.generataTypeAcessors(ListItemTypes);

const html$e = index.html;
const repeat$e = index.repeat;

const ListLitRenderer = {};

const block0$d = (context) => { return html$e`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"><!-- header toolbar -->	${ context.ctr.headerToolbar ? block1$9(context) : undefined }${ context.shouldRenderH1 ? block2$5(context) : undefined }<div id="${index.ifTruthy(context.ctr._id)}-before" tabindex="0" class="sapMListDummyArea"></div><ul id="${index.ifTruthy(context.ctr._id)}-listUl" class="${index.ifTruthy(context.classes.ul)}">		${ repeat$e(context.ctr.items, undefined, (item, index$$1) => block3$4(item, index$$1, context)) }${ context.showNoDataText ? block4$2(context) : undefined }</ul>	${ context.ctr.footerText ? block5$2(context) : undefined }<div id="${index.ifTruthy(context.ctr._id)}-after" tabindex="0" class="sapMListDummyArea"></div></div>`; };
const block1$9 = (context) => { return html$e`<slot name="${index.ifTruthy(context.ctr.headerToolbar._slot)}" />	`; };
const block2$5 = (context) => { return html$e`<header id="${index.ifTruthy(context.ctr._id)}-header" class="sapMListHdr sapMListHdrText">			${index.ifTruthy(context.ctr.headerText)}</header>	`; };
const block3$4 = (item, index$$1, context) => { return html$e`<slot name="${index.ifTruthy(item._slot)}" />		`; };
const block4$2 = (context) => { return html$e`<li id="${index.ifTruthy(context.ctr._id)}-nodata" class="${index.ifTruthy(context.classes.noData)}" tabindex="${index.ifTruthy(context.noDataTabIndex)}"><div id="${index.ifTruthy(context.ctr._id)}-nodata-text" class="sapMListNoDataText">					${index.ifTruthy(context.ctr.noDataText)}</div></li>		`; };
const block5$2 = (context) => { return html$e`<footer id="${index.ifTruthy(context.ctr._id)}-footer" class="sapMListFtr">			${index.ifTruthy(context.ctr.footerText)}</footer>	`; };
const renderMe$d = block0$d;

ListLitRenderer.render = renderMe$d;

class ListTemplateContext {

	static calculate(state) {
		const context = {
			ctr: state,
			classes: {
				main: ListTemplateContext.getMainClasses(state),
				ul: ListTemplateContext.getULClasses(state),
				noData: ListTemplateContext.getNoDataClasses(state)
			},
			styles: {
				main: {

				}
			},
			shouldRenderH1: !state.headerToolbar && state.headerText,
			showNoDataText: state.items.length === 0 && state.noDataText
		};

		return context;
	}

	static getMainClasses(state) {
		return {
			"sapMList": true,
			"sapMListInsetBG": state.inset,
			[`sapMListBG${state.backgroundDesign}`]: true
		};
	}

	static getULClasses(state) {
		return {
			"sapMListItems": true,
			"sapMListUl": true,
			[`sapMListShowSeparators${state.separators}`]: true,
			[`sapMListMode${state.mode}`]: true,
			"sapMListInset": state.inset
		}
	}

	static getNoDataClasses() {
		return {
			"sapMLIB": true,
			"sapMListNoData": true,
			"sapMLIBTypeInactive": true,
			"sapMLIBFocusable": Device.system.desktop
		}
	}
}

/**
 * @public
 */
const metadata$g = {
	tag: "ui5-list",
	styleUrl: [
		"List.css"
	],
	defaultSlot: "items",
	slots: {
		/**
		 * Defines the header area. The use can use <code>Toolbar</code>  and add extra controls for user interactions.
		 * <b>Note:</b> When set, the <code>headerText</code> property will be ignored.
		 * @type {HTMLElement}
		 * @public
		 */
		headerToolbar: {
			type: HTMLElement
		},

		/**
		 * Defines the items of the <code>List</code>.
		 * @type {HTMLElement}
		 * @public
		 */
		items: {
			type: HTMLElement,
			multiple: true
		}
	},
	properties: /** @lends  sap.ui.webcomponents.main.List.prototype */ {

		/**
		 * Defines the background design of the <code>List</code>.
		 * @type {string}
		 * @public
		 */
		backgroundDesign: {
			type: BackgroundDesign,
			defaultValue: BackgroundDesign.Solid
		},

		/**
		 * Defines the <code>List</code> header text.
		 * <b>Note:</b> If <code>headerToolbar</code> is set, then this property is ignored.
		 * @type {string}
		 * @public
		 */
		headerText: {
			type: String,
			defaultValue: ""
		},

		/**
		 * Defines the footer text.
		 * @type {string}
		 * @public
		 */
		footerText: {
			type: String,
			defaultValue: ""
		},

		/**
		 * Defines the indentation of the container.
		 * Setting it to <code>true</code> indents the list.
		 * @type {boolean}
		 * @public
		 */
		inset: {
			type: Boolean
		},

		/**
		 * Defines the mode of the <code>List</code>.
		 * Avalaible options are: <code>None</code>, <code>SingleSelect</code>, <code>MultiSelect</code> and <code>Delete</code>.
		 * @type {string}
		 * @public
		 */
		mode: {
			type: ListMode,
			defaultValue: ListMode.None
		},

		/**
		 * Defines the text, displayed when the <code>List</code> contains no items.
		 * @type {string}
		 * @public
		 */
		noDataText: {
			type: String,
			defaultValue: ""
		},

		/**
		 * Defines the item separator style, that will be used.
		 * @type {string}
		 * @public
		 */
		separators: {
			type: ListSeparators,
			defaultValue: ListSeparators.All
		}
	},
	events: /** @lends  sap.ui.webcomponents.main.List.prototype */ {
		/**
		 * Fired, when an item is pressed,
		 * unless the item's <code>type</code> property is <code>Inactive</code>.
		 * @event
		 * @param {HTMLElement} the pressed item.
		 * @public
		 */
		itemPress: {
			detail: {
				item: {type : HTMLElement}
			}
		},

		/**
		 * Fired, when the delete button of any item is pressed.
		 * <b>Note:</b> a delete button is displayed on each item,
		 * when the <code>List</List> <code>mode</code> property is set to <code>Delete</code>.
		 * @event
		 * @param {HTMLElement} the deleted item.
		 * @public
		 */
		itemDelete: {
			detail: {
				item: {type : HTMLElement}
			}
		},

		/**
		 * Fired, when selection is changed via user interaction
		 * in <code>SingleSelect</code> and <code>MultiSelect</code> modes.
		 * @event
		 * @param {Array} an array of the selected items.
		 * @public
		 */
		selectionChange: {
			detail: {
				items: {type : Array}
			}
		}
	}
};

/**
 * @class
 *
 * A class to represent a new <code>List</code>.
 *
 * <h3> Overview </h3>
 * The <code>List</code> provides a container for all types of list items.
 * For mobile devices, the recommended limit of list items is 100 to assure proper performance.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.List
 * @public
 */
class List$2 extends WebComponent {

	static get metadata() {
		return metadata$g;
	}

	static get renderer() {
		return ListLitRenderer;
	}

	constructor(state) {
		super(state);

		this.initItemNavigation();

		// Stores the last focused item within the internal ul element.
		this._previouslyFocusedItem = null;

		// Indicates that the List is forwarding the focus before or after the internal ul.
		this._forwardingFocus = false;

		this._previouslySelectedItem = null;

		this.fnOnItemPress = this.onItemPress.bind(this);
		this.fnOnItemFocused = this.onItemFocused.bind(this);
		this.fnOnForwardAfter = this.onForwardAfter.bind(this);
		this.fnOnForwardBefore = this.onForwardBefore.bind(this);
		this.fnOnSelectionRequested = this.onSelectionRequested.bind(this);
	}

	onBeforeRendering() {
		this.prepareListItems();

		this._itemNavigation.init();
	}

	initItemNavigation() {
		this._itemNavigation = new ItemNavigation(this);
		this._itemNavigation.getItemsCallback = () => this.items;

		this._delegates.push(this._itemNavigation);
	}

	prepareListItems() {

		this.items.forEach((item, key) => {
			const isLastChild = key === this.items.length - 1;
			const showBottomBorder = this.separators === ListSeparators.All || (this.separators === ListSeparators.Inner && !isLastChild);
			item.removeEventListener('_press', this.fnOnItemPress);
			item.addEventListener('_press', this.fnOnItemPress);
			item.removeEventListener('_focused', this.fnOnItemFocused);
			item.addEventListener('_focused', this.fnOnItemFocused);
			item.removeEventListener('_forwardAfter', this.fnOnForwardAfter);
			item.addEventListener('_forwardAfter', this.fnOnForwardAfter);
			item.removeEventListener('_forwardBefore', this.fnOnForwardBefore);
			item.addEventListener('_forwardBefore', this.fnOnForwardBefore);
			item.removeEventListener('_selectionRequested', this.fnOnSelectionRequested);
			item.addEventListener('_selectionRequested', this.fnOnSelectionRequested);
			item._mode = this.mode;
			item._background = this.backgroundDesign;
			item.hideBorder = !showBottomBorder;
		});

		this._previouslySelectedItem = null;
	}

	/*
	* ITEM SELECTION BASED ON THE CURRENT MODE
	*/

	onSelectionRequested(event) {
		let selectionChange = false;
		this._selectionRequested = true;

		if (this[`handle${this.mode}`]) {
			selectionChange = this[`handle${this.mode}`](event.detail.item, event.selected);
		}

		if (selectionChange) {
			this.fireEvent("selectionChange", { items: this.getSelectedItems() });
		}
	}

	handleSingleSelect(item) {
		if (item.selected) {
			return false;
		}

		this.deselectSelectedItems();
		item.selected = true;

		return true;
	}

	handleSingleSelectBegin(item) {
		return this.handleSingleSelect(item);
	}

	handleSingleSelectEnd(item) {
		return this.handleSingleSelect(item);
	}

	handleMultiSelect(item, selected) {
		item.selected = selected;
		return true;
	}

	handleDelete(item) {
		this.fireEvent("itemDelete", { item: item });
	}

	deselectSelectedItems() {
		this.getSelectedItems().forEach(item => { item.selected = false; });
	}

	getSelectedItems() {
		return this.items.filter(item => item.selected);
	}

	getFirstSelectedItem() {
		let firstSelectedItem = null;

		for (let i = 0; i < this.items.length; i++) {
			if (this.items[i].selected) {
				firstSelectedItem = this.items[i];
				break;
			}
		}

		return firstSelectedItem;
	}

	onItemPress(event) {
		const pressedItem = event.detail.item;

		if (pressedItem.type === ListItemType.Active) {
			this.fireEvent('itemPress', { item: pressedItem });
		}

		if (!this._selectionRequested && this.mode !== ListMode.Delete) {
			this._selectionRequested = true;
			this.onSelectionRequested({
				detail: {
					item: pressedItem
				},
				selected: !pressedItem.selected
			});
		}

		this._selectionRequested = false;
	}

	/*
	* KEYBOARD SUPPORT
	*/
	onsaptabnext(event) {
		// If forward navigation is performed, we check if the List has headerToolbar.
		// If yes - we check if the target is at the last tabbable element of the headerToolbar
		// to forward correctly the focus to the selected, previously focused or to the first list item.
		let lastTabbableEl, target = this.getNormalizedTarget(event.target);

		if (this.headerToolbar) {
			lastTabbableEl = this.getHeaderToolbarLastTabbableElement();
		}

		if (!lastTabbableEl) {
			return;
		}

		if (lastTabbableEl === target) {

			if (this.getFirstSelectedItem()) {
				this.focusFirstSelectedItem();

			} else if (this.getPreviouslyFocusedItem()) {
				this.focusPreviouslyFocusedItem();

			} else {
				this.focusFirstItem();
			}

			event.stopImmediatePropagation();
			event.preventDefault();
			return;
		}
	}

	onfocusin(event) {
		// If the focusin event does not origin from one of the 'triggers' - ignore it.
		if (!this.isForwardElement(this.getNormalizedTarget(event.target))) {
			event.stopImmediatePropagation();
			return;
		}

		// The focus arrives in the List for the first time.
		// If there is selected item - focus it or focus the first item.
		if (!this.getPreviouslyFocusedItem()) {

			if (this.getFirstSelectedItem()) {
				this.focusFirstSelectedItem();
			} else {
				this.focusFirstItem();
			}

			event.stopImmediatePropagation();
			return;
		}

		// The focus returns to the List,
		// focus the first selected item or the previously focused element.
		if (!this.getForwardingFocus()) {
			if (this.getFirstSelectedItem()) {
				this.focusFirstSelectedItem();
			} else {
				this.focusPreviouslyFocusedItem();
			}
		}

		this.setForwardingFocus(false);
	}

	isForwardElement(node) {
		let nodeId = node.id;

		if (this._id === nodeId) {
			return true;
		} else if (this.getBeforeElement().id === nodeId) {
			return true;
		}

		return this.getAfterElement().id === nodeId;
	}

	onItemFocused(event) {
		const target = event.target;

		this._itemNavigation.update(target);
		this.fireEvent('itemFocused', { item: target });
	}

	onForwardBefore(event) {
		this.setPreviouslyFocusedItem(event.target);
		this.focusBeforeElement();
	}

	onForwardAfter(event) {
		this.setPreviouslyFocusedItem(event.target);
		this.focusAfterElement();
	}

	focusBeforeElement() {
		this.setForwardingFocus(true);
		this.getBeforeElement().focus();
	}

	focusAfterElement() {
		this.setForwardingFocus(true);
		this.getAfterElement().focus();
	}

	focusFirstItem() {
		let firstItem = this.getFirstItem();

		if (firstItem) {
			firstItem.focus();
		}
	}

	focusPreviouslyFocusedItem() {
		let previouslyFocusedItem = this.getPreviouslyFocusedItem();

		if (previouslyFocusedItem) {
			previouslyFocusedItem.focus();
		}
	}

	focusFirstSelectedItem() {
		let firstSelectedItem = this.getFirstSelectedItem();

		if (firstSelectedItem) {
			firstSelectedItem.focus();
		}
	}

	setForwardingFocus(forwardingFocus) {
		this._forwardingFocus = forwardingFocus;
	}

	getForwardingFocus() {
		return this._forwardingFocus;
	}

	setPreviouslyFocusedItem(item) {
		this._previouslyFocusedItem = item;
	}

	getPreviouslyFocusedItem() {
		return this._previouslyFocusedItem;
	}

	getFirstItem() {
		return !!this.items.length && this.items[0];
	}

	getAfterElement() {
		if (!this._afterElement) {
			this._afterElement = this.shadowRoot.querySelector("#" + this._id + '-after');
		}
		return this._afterElement;
	}

	getBeforeElement() {
		if (!this._beforeElement) {
			this._beforeElement = this.shadowRoot.querySelector("#" + this._id + '-before');
		}
		return this._beforeElement;
	}

	getHeaderToolbarLastTabbableElement() {
		return this.getLastTabbableELement(this.headerToolbar.getDomRef()) || this.headerToolbar.getDomRef();
	}

	getLastTabbableELement(node) {
		return FocusHelper.getLastTabbableElement(node);
	}

	getNormalizedTarget(target) {
		let focused = target;

		if (target.shadowRoot && target.shadowRoot.activeElement) {
			focused = target.shadowRoot.activeElement;
		}

		return focused;
	}

	static get calculateTemplateContext() {
		return ListTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	List$2.define();
});

/**
 * A class to enable showSuggestion of <code>Input</code>.
 *
 * @class
 * @private
 * @author SAP SE
 */
class InputSuggestion {

	static enableSuggestionsFor(input) {
		this.input = input;

		this.fnOnSuggestionItemPress = this.onSuggestionItemPress.bind(this);
		this.fnOnSuggestionItemFocus = this.onSuggestionItemFocus.bind(this);

		// An integer value to store the currently suggestionItem position,
		// that is navigated to via the ARROW keys.
		this.selectedSuggestionItemIndex = null;
	}

	static updateSuggestionList() {
		this.attachItemHandlers();
		this.toggleSuggestionList(this.shouldOpenSuggestionList());
	}

	static shouldOpenSuggestionList() {
		const input = this.getInput();

		return !!(input.showSuggestion
			&& input.suggestionItems.length
			&& input.value.length >= input.startSuggestion
			&& input._focused
			&& !input.hasSuggestionItemSelected);
	}

	static onSuggestionItemPress(oEvent) {
		this.onSuggestionItemSelected(oEvent.detail.item);
	}

	static onSuggestionItemFocus() {
		this.getInput().onSuggestionItemFocus();
	}

	static onSuggestionItemSelected(selectedItem, keyboardUsed) {
		const items = this.getSuggestionItems();
		const item = selectedItem ? selectedItem : items[this.selectedSuggestionItemIndex];

		this.getInput().onSuggestionItemSelected(item, keyboardUsed);

		this.toggleSuggestionList(false);
	}

	static toggleSuggestionList(bToggle) {
		if (bToggle) {
			this.openSuggestionList();
		} else {
		}
	}

	static openSuggestionList() {
		this.getPopover().openBy(this.getInput());
	}

	static closeSuggestionList() {
		//this.getPopover().close();
	}

	static isSuggestionItemOnTarget() {
		return this.isSuggestionListOpened() && this.selectedSuggestionItemIndex !== null;
	}

	static isSuggestionListOpened() {
		return this.getPopover()._isOpen;
	}

	static handleSuggestioItemsNavigation(forward) {
		if (!this.isSuggestionListOpened()) {
			return;
		}

		if (!this.getSuggestionItems().length) {
			return;
		}

		if (forward) {
			this.selectNextSuggestionItem();
		} else {
			this.selectPreviousSuggestionItem();
		}
	}

	static selectNextSuggestionItem() {
		const itemsCount = this.getSuggestionItems().length;
		const previousSelectedIdx = this.selectedSuggestionItemIndex;

		if ((this.selectedSuggestionItemIndex === null) || (++this.selectedSuggestionItemIndex > itemsCount - 1)) {
			this.selectedSuggestionItemIndex = 0;
		}

		this.moveItemSelection(previousSelectedIdx, this.selectedSuggestionItemIndex);
	}

	static selectPreviousSuggestionItem() {
		const itemsCount = this.getSuggestionItems().length;
		const previousSelectedIdx = this.selectedSuggestionItemIndex;

		if ((this.selectedSuggestionItemIndex === null) || (--this.selectedSuggestionItemIndex < 0)) {
			this.selectedSuggestionItemIndex = itemsCount - 1;
		}

		this.moveItemSelection(previousSelectedIdx, this.selectedSuggestionItemIndex);
	}

	static moveItemSelection(previousIdx, nextIdx) {
		const input = this.getInput();
		const items = input.suggestionItems;

		let currentItem = items[nextIdx];
		let previousItem = items[previousIdx];

		if (previousItem) {
			previousItem.selected = false;
		}
		if (currentItem) {
			currentItem.selected = true;
		}

		input.onSuggestionItemPreview(currentItem._nodeText);

		if (!this.isSuggestionItemIntoView(currentItem)) {
			this.scrollItemIntoView(currentItem);
		}
	}

	static isSuggestionItemIntoView(item) {
		const rectItem = item.getDomRef().getBoundingClientRect();
		const rectInput = this.getInput().getDomRef().getBoundingClientRect();
		const windowHeight = (window.innerHeight || document.documentElement.clientHeight);

		return (rectItem.top <= windowHeight) && (rectItem.top >= rectInput.top);
	}

	static scrollItemIntoView(item) {
		const pos = item.getDomRef().offsetTop - InputSuggestion.SCROLL_STEP;
		this.getScrollContainer().scrollTop = pos;
	}

	static getScrollContainer() {
		if (!this._scrollContainer) {
			const popover = this.getPopover();
			this._scrollContainer = popover.getDomRef().querySelector('.sapMPopupContent');
		}

		return this._scrollContainer;
	}

	static getSuggestionItems() {
		return this.getInput().suggestionItems;
	}

	static attachItemHandlers () {
		const list = this.getList();
		list.removeEventListener('itemPress', this.fnOnSuggestionItemPress);
		list.addEventListener('itemPress', this.fnOnSuggestionItemPress);
		list.removeEventListener('itemFocused', this.fnOnSuggestionItemFocus);
		list.addEventListener('itemFocused', this.fnOnSuggestionItemFocus);
	}

	static getInput() {
		return this.input;
	}

	static getList() {
		return this.input.shadowRoot.querySelector("ui5-list");
	}

	static getPopover() {
		return this.input.shadowRoot.querySelector("ui5-popover");
	}
}

InputSuggestion.INPUT_FIELD_HIGHT = 10;
InputSuggestion.SCROLL_STEP = 48;

// will be rendered by the input template
List$2.define();
Popover$1.define();

Input$1.getInputSuggestion = () => InputSuggestion;

const getElementToLabel = (id) => /*ControlRenderer.byId(id) ||*/ document.getElementById(id);

class LabelEnablement {

	static labelElement(labelFor) {
		let elementToLabel = getElementToLabel(labelFor);

		if (elementToLabel) {
			elementToLabel.focus();
		}
	}

	static getLabelableElementId(labelFor) {
		let elementToLabel = getElementToLabel(labelFor);

		if (elementToLabel) {
			return (elementToLabel.getLabelableElementId && elementToLabel.getLabelableElementId()) || labelFor;
		}

		return labelFor;
	}
}

const LabelDesigns = {
	/**
	 * Displays the label in bold.
	 */
	Bold: "Bold",

	/**
	 * Displays the label in normal mode.
	 */
	Standard: "Standard"
};

class LabelDesign extends DataType {
	static isValid(value) {
		return !!LabelDesigns[value];
	}
}

LabelDesign.generataTypeAcessors(LabelDesigns);

/**
 * Different states.
 */
const TextAlignTypes = {
	/**
	 * Locale-specific positioning at the beginning of the line.
	 */
	Begin: "Begin",

	/**
	 * Locale-specific positioning at the end of the line.
	 */
	End: "End",

	/**
	 * Hard option for left alignment.
	 */
	Left: "Left",

	/**
	 * Hard option for right alignment.
	 */
	Right: "Right",

	/**
	 * Centered text alignment.
	 */
	Center: "Center",

	/**
	 * Sets no text align, so the browser default is used.
	 */
	Initial: "Initial"
};

class TextAlign extends DataType {
	static isValid(value) {
		return !!TextAlignTypes[value];
	}
}

TextAlign.generataTypeAcessors(TextAlignTypes);

const html$f = index.html;

const LabelLitRenderer = {};

const block0$e = (context) => { return html$f`<label 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"	dir="${index.ifTruthy(context.dir)}"	for="${index.ifTruthy(context.labelFor)}"><bdi id="${index.ifTruthy(context.ctr._id)}-bdi">			${index.ifTruthy(context.ctr._nodeText)}</bdi></label>`; };
const renderMe$e = block0$e;

LabelLitRenderer.render = renderMe$e;

class TemplateHelper {
	static getTextAlign(textAlign, textDirection) {

		let resultTextAlign = "";
		const bRTL = sap.ui.getCore().getConfiguration().getRTL();

		switch (textAlign) {
			case TextAlign.End:
				switch (textDirection) {
				case TextDirection.LTR:
					resultTextAlign = "right";
					break;
				case TextDirection.RTL:
					resultTextAlign = "left";
					break;
				default:
					// this is really only influenced by the SAPUI5 configuration. The browser does not change alignment with text-direction
					resultTextAlign = bRTL ? "left" : "right";
					break;
				}
				break;
			case TextAlign.Begin:
				switch (textDirection) {
				case TextDirection.LTR:
					resultTextAlign = "left";
					break;
				case TextDirection.RTL:
					resultTextAlign = "right";
					break;
				default:
					resultTextAlign = bRTL ? "right" : "left";
					break;
				}
				break;
			case TextAlign.Right:
				if (!bRTL || textDirection == TextDirection.LTR) {
					resultTextAlign = "right";
				}
				break;
			case TextAlign.Center:
				resultTextAlign = "center";
				break;
			case TextAlign.Left:
				if (bRTL || textDirection == TextDirection.RTL) {
					resultTextAlign = "left";
				}
				break;
			// no default
			}
		return resultTextAlign;
	}
}

class LabelTemplateContext {

	static calculate(state) {
		let mainClasses = LabelTemplateContext.getMainClasses(state),
			textDir = "",
			labelFor = "";

		if (state.textDirection !== TextDirection.Inherit) {
			textDir = state.textDirection.toLowerCase();
		}

		if (state.for) {
			labelFor = LabelEnablement.getLabelableElementId(state.for);
		}

		let context = {
			dir: textDir,
			ctr: state,
			labelFor: labelFor,
			classes: { main: mainClasses},
			styles: {
				main: {
					"width": state.width
				}
			}
		};

		if (state.design === LabelDesign.Bold) {
			context.styles.main["font-weight"] = LabelDesign.Bold;
		}

		let textAlign = textDir && TemplateHelper.getTextAlign(state.textAlign, state.textDirection);
		if (textAlign) {
			context.styles.main["text-align"] = textAlign;
		}

		return context;
	}

	static getMainClasses(state) {
		return {
			"sapMLabel": true,
			"sapMLabelMaxWidth": true,
			"sapMLabelNoText": !state._nodeText,
			"sapMLabelWrapped": state.wrap,
			"sapMLabelRequired": state.required
		};
	}

	static getInnerClasses() {}
}

/**
 * @public
 */
const metadata$h = {
	tag: "ui5-label",
	styleUrl: [
		"Label.css"
	],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.Label.prototype */  {

		/**
		 * Defines the <code>Label</code> design.
		 * Available options are: 'Standard' and 'Bold'.
		 * @type {string}
		 * @public
		 */
		design : {
			"defaultValue": LabelDesign.Standard,
			"type": LabelDesign
		},

		/**
		 * Defines that user input is required.
		 * <b>Note:</b> an asterisk character is added to the <code>Label</code> text.
		 * @type {boolean}
		 * @public
		 */
		required: {
			"type": Boolean
		},

		/**
		 * Defines the text direction of the <code>Label</code>.
		 * Available pptions for the text direction are: 'RTL' and 'LTR'.
		 * <b>Note:</b> alternatively, the control can inherit the text direction from its parent container.
		 * @type {string}
		 * @public
		 */
		textDirection: {
			"defaultValue": TextDirection.Inherit,
			"type": TextDirection
		},

		/**
		 * Defines the text alignment of the <code>Label</code>.
		 * Available options are: "Begin", "Center", "End", "Left", and "Right".
		 * @type {string}
		 * @public
		 */
		textAlign: {
			"defaultValue": TextAlign.Begin,
			"type": TextAlign
		},

		/**
		 * Defines if the <code>Label</code> is wrapping or not.
		 * @type {boolean}
		 * @public
		 */
		wrap : {
			"type": Boolean
		},

		/**
		 * Defines the width of the <code>Label</code>.
		 * @type {string}
		 * @public
		 */
		width : {
			"defaultValue": "",
			"type": CSSSize
		},

		/**
		 * Defines the laballed input by providing its ID.
		 * @type {string}
		 * @public
		 */
		for: {
			"defaultValue": "",
			"type": String
		}
	},
	renderer: LabelLitRenderer
};

const isCustomElement = (id) => {
	const element = document.getElementById(id);// Should discuss this line;
	return !!(element && element.tagName.toLowerCase().startsWith('ui5-'));
};


/**
 * @class
 *
 * A class to represent Label.
 *
 * <h3>Overview</h3>
 * Labels are used as titles for single controls or groups of controls.
 * Labels for required fields are marked with an asterisk.
 *
 * Label appearance can be influenced by properties, such as <code>textAlign</code>,
 * <code>design</code> and <code>wrapping</code>.
 *
 * <h3>Usage</h3>
 *
 * <h4>When to use</h4>
 * <ul>
 * <li>It's recommended to use the <code>Label</code> in Form controls.</li>
 * <li>Use title case for labels.</li>
 * </ul>
 *
 * <h4>When not to use</h4>
 * <ul>
 * <li> It is not recommended to use labels in Bold.</li>
 * </ul>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Label
 * @public
 */
class Label$2 extends WebComponent {

	static get metadata() {
		return metadata$h;
	}

	constructor(state) {
		super(state);
	}

	static get renderer() {
		return LabelLitRenderer;
	}

	ontap() {
		const labelFor = this.for;

		if (labelFor && isCustomElement(labelFor)) {
			LabelEnablement.labelElement(labelFor);
		}
	}

	static get calculateTemplateContext() {
		return LabelTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	Label$2.define();
});

const html$g = index.html;

const LinkLitRenderer = {};

const block0$f = (context) => { return html$g`<a 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"	role="link"	href="${index.ifTruthy(context.ctr.href)}"	target="${index.ifTruthy(context.ctr.target)}"	tabindex="${index.ifTruthy(context.tabIndex)}"	title="${index.ifTruthy(context.ctr.tooltip)}"	?disabled="${index.ifTruthy(context.ctr.disabled)}"	aria-disabled="${index.ifTruthy(context.ariaDisabled)}">	${index.ifTruthy(context.ctr._nodeText)}</a>`; };
const renderMe$f = block0$f;

LinkLitRenderer.render = renderMe$f;

class LinkTemplateContext {

	static calculate(state) {
		let mainClasses = LinkTemplateContext.getMainClasses(state);

		let context = {
			tabIndex: (state.disabled || !state._nodeText.length) ? '-1' : '0',
			ctr: state,
			classes: { main: mainClasses},
			styles: {
				main: {"width": state.width}
			},
			ariaDisabled: state.disabled ? "true" : undefined
		};

		return context;
	}

	static getMainClasses(state) {
		return {
			"sapMLnk": true,
			"sapMLnkSubtle": state.subtle,
			"sapMLnkEmphasized": state.emphasized,
			"sapMLnkWrapping": state.wrapping,
			"sapMLnkDsbl": state.disabled,
			"sapMLnkMaxWidth": !state.width
		};
	}

	static getInnerClasses() {}
}

/**
 * @public
 */
const metadata$i = {
	tag: "ui5-link",
	styleUrl: ['Link.css'],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.Link.prototype */  {

		/**
		 * Defines if the <code>Link</code> is disabled.
		 * <b>Note:</b> when disabled, the link can not be triggered by the user.
		 * @type {boolean}
		 * @public
		 */
		disabled: {
			"type": Boolean
		},

		/**
		 * Defines the emphasized state of the <code>Link</code>.
		 * <b>Note:</b> emphasized links look visually more important than regular links.
		 * @type {boolean}
		 * @public
		 */
		emphasized: {
			"type": Boolean
		},

		/**
		 * Defines the <code>Link</code> target URI.
		 * Standard hyperlink behavior is supported.
		 * @type {string}
		 * @public
		 */
		href: {
			"type": URI$1,
			"defaultValue": ""
		},

		/**
		 * Defines the subtle state of the <code>Link</code>.
		 * <b>Note:</b> subtle links look more like standard text than like links.
		 * @type {boolean}
		 * @public
		 */
		subtle: {
			"type": Boolean
		},

		/**
		 * Defines a target.
		 * Available options are the standard values:
		 * <code>_self</code>, <code>_top</code>, <code>_blank</code>, <code>_parent</code>, <code>_search</code>.
		 * <b>Note:</b> this property must be only used when the <code>href</code> property is set.
		 * @type {string}
		 * @public
		 */
		target: {
			"type": String,
			"defaultValue": ""
		},

		/**
		 * Defines the tooltip of the <code>Link</code>.
		 * @type {string}
		 * @public
		 */
		tooltip: {
			"defaultValue": undefined,
			"type": String
		},

		/**
		 * Defines the width of the <code>Link</code>.
		 * @type {string}
		 * @public
		 */
		width: {
			"defaultValue": "",
			"type": CSSSize
		},

		/**
		 * Defines whether the <code>Link</code>ink text is allowed to wrap,
		 * when there is no sufficient space.
		 * @type {boolean}
		 * @public
		 */
		wrapping: {
			"type": Boolean
		}
	},
	events: /** @lends sap.ui.webcomponents.main.Link.prototype */ {
		/**
		 * Fired, when the <code>Link</code> is triggered.
		 * @event
		 * @public
		 */
		press: {}
	}
};

/**
 * @class
 *
 * A class to represent a <code>Link</code>.
 *
 * A hyperlink control used to navigate to other apps and web pages or to trigger actions.
 *
 * <h3>Overview</h3>
 *
 * The <code>Link</code> control is a clickable text element visualized in such a way that it stands out
 * from the standard text. On hover, it changes its style to underlined text to provide
 * additional feedback to the user.
 *
 * <h3>Usage</h3>
 *
 * You can set the <code>Link</code> to be enabled or disabled.
 *
 * To create a visual hierarchy in large lists of links, you can set the less important links as
 * <code>subtle</code> or the more important ones as <code>emphasized</code>.
 *
 * To specify where the linked content is opened, you can use the <code>target</code> property.
 *
 * <h3>Responsive behavior</h3>
 *
 * If there is not enough space, the text of the <code>Link</code> becomes truncated.
 * If the <code>wrapping</code> property is set to <code>true</code>, the text will be
 * displayed on several lines, instead of being truncated.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Link
 * @public
 */
class Link$2 extends WebComponent {

	static get metadata() {
		return metadata$i;
	}

	static get renderer() {
		return LinkLitRenderer;
	}

	constructor(state) {
		super(state);
	}


	ontap(event) {
		if (this.disabled) {
			event.preventDefault();
			return;
		}

		this.fireEvent('press', {});
	}

	onkeydown(event) {
		const eventKeyCode = event.keyCode;

		if (this.disabled) {
			return;
		}

		if (eventKeyCode === mKeyCodes.SPACE) {
			event.preventDefault();
		} else if (eventKeyCode === mKeyCodes.ENTER) {
			this.fireEvent('press', {});
		}
	}

	onkeyup(event) {
		if (this.disabled) {
			return;
		}

		if (event.keyCode === mKeyCodes.SPACE) {
			this.fireEvent('press', {});

			// Simulate click event
			const oClickEvent = document.createEvent('MouseEvents');
			oClickEvent.initEvent('click' /* event type */, false/* no-bubbling */, true /* cancelable */);
			this.getDomRef().dispatchEvent(oClickEvent);
		}
	}

	static get calculateTemplateContext() {
		return LinkTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	Link$2.define();
});

var animationConfig = {
	defaultDuration: 400,
	element: document.createElement("DIV"),
	identity: () => {}
};

const tasks = new WeakMap();

class AnimationQueue {
	static get tasks() {
		return tasks;
	}

	static enqueue (element, task) {
		if (!tasks.has(element)) {
			tasks.set(element, []);
		}

		tasks.get(element).push(task);
	}

	static run (element, task) {
		if (!tasks.has(element)) {
			tasks.set(element, []);
		}

		return task().then(_ => {
			const elementTasks = tasks.get(element);

			if (elementTasks.length > 0) {
				return AnimationQueue.run(element, elementTasks.shift());
			} else {
				tasks.delete(element);
			}
		});
	}

	static push (element, task) {
		const elementTasks = tasks.get(element);

		if (elementTasks) {
			AnimationQueue.enqueue(element, task);
		} else {
			AnimationQueue.run(element, task);
		}
	}
}

var animate = ({
		beforeStart = animationConfig.identity,
		duration = animationConfig.defaultDuration,
		element = animationConfig.element,
		progress: progressCallback = animationConfig.identity
}) => {
	let start = null;
	let stopped = false;
	let animationFrame;
	let stop;
	let animate;

	const promise = new Promise((resolve, reject) => {
		animate = timestamp => {
			start = start || timestamp;

			const timeElapsed = timestamp - start;
			const remaining = duration - timeElapsed;

			if (timeElapsed <= duration) {
				const progress = 1 - remaining / duration; // easing formula (currently linear)
				progressCallback(progress);
				animationFrame = !stopped && requestAnimationFrame(animate);
			} else {
				progressCallback(1);
				resolve();
			}
		};

		stop = () => {
			stopped = true;
			cancelAnimationFrame(animationFrame);
			reject(new Error("animation stopped"));
		};
	}).catch(oReason => oReason);

	AnimationQueue.push(element, _ => {
		beforeStart();
		requestAnimationFrame(animate);

		return new Promise(resolve => {
			promise.then(_ => resolve());
		});
	});

	return {
		promise: _=> promise,
		stop: _ => stop
	};
};

var slideDown = ({
	element = animationConfig.element,
	duration = animationConfig.defaultDuration,
	progress: progressCallback = animationConfig.identity
}) => {
	let computedStyles, paddingTop, paddingBottom, marginTop, marginBottom, height;
	let storedOverflow, storedPaddingTop, storedPaddingBottom, storedMarginTop, storedMarginBottom, storedHeight;

	const animation = animate({
		beforeStart: _ => {
			// Show the element to measure its properties
			element.style.display = "block";

			// Get Computed styles
			computedStyles = getComputedStyle(element);
			paddingTop = parseFloat(computedStyles.paddingTop);
			paddingBottom = parseFloat(computedStyles.paddingBottom);
			marginTop = parseFloat(computedStyles.marginTop);
			marginBottom = parseFloat(computedStyles.marginBottom);
			height = parseFloat(computedStyles.height);

			// Store inline styles
			storedOverflow = element.style.overflow;
			storedPaddingTop = element.style.paddingTop;
			storedPaddingBottom = element.style.paddingBottom;
			storedMarginTop = element.style.marginTop;
			storedMarginBottom = element.style.marginBottom;
			storedHeight = element.style.height;

			element.style.overflow = "hidden";
			element.style.paddingTop = 0;
			element.style.paddingBottom = 0;
			element.style.marginTop = 0;
			element.style.marginBottom = 0;
			element.style.height = 0;
		},
		duration: duration,
		element: element,
		progress: function (progress) {
			progressCallback(progress);

			// WORKAROUND
			element.style.display = "block";
			// END OF WORKAROUND

			element.style.paddingTop = 0 + (paddingTop * progress) + "px";
			element.style.paddingBottom = 0 + (paddingBottom * progress) + "px";
			element.style.marginTop = 0 + (marginTop * progress) + "px";
			element.style.marginBottom = 0 + (marginBottom * progress) + "px";
			element.style.height = 0 + (height * progress) + "px";
		}
	});

	animation.promise().then(_ => {
		element.style.overflow = storedOverflow;
		element.style.paddingTop = storedPaddingTop;
		element.style.paddingBottom = storedPaddingBottom;
		element.style.marginTop = storedMarginTop;
		element.style.marginBottom = storedMarginBottom;
		element.style.height = storedHeight;
	});

	return animation;
};

var slideUp = ({
	element = animationConfig.element,
	duration = animationConfig.defaultDuration,
	progress: progressCallback = animationConfig.identity
}) => {
	// Get Computed styles
	let computedStyles, paddingTop, paddingBottom, marginTop, marginBottom, height;

	// Store inline styles
	let storedOverflow, storedPaddingTop, storedPaddingBottom, storedMarginTop, storedMarginBottom, storedHeight;

	const animation = animate({
		beforeStart: _ => {
			// Get Computed styles
			computedStyles = getComputedStyle(element);
			paddingTop = parseFloat(computedStyles.paddingTop);
			paddingBottom = parseFloat(computedStyles.paddingBottom);
			marginTop = parseFloat(computedStyles.marginTop);
			marginBottom = parseFloat(computedStyles.marginBottom);
			height = parseFloat(computedStyles.height);

			// Store inline styles
			storedOverflow = element.style.overflow;
			storedPaddingTop = element.style.paddingTop;
			storedPaddingBottom = element.style.paddingBottom;
			storedMarginTop = element.style.marginTop;
			storedMarginBottom = element.style.marginBottom;
			storedHeight = element.style.height;

			element.style.overflow = "hidden";
		},
		duration: duration,
		element: element,
		progress: function (progress) {
			progressCallback(progress);

			element.style.paddingTop = paddingTop - (paddingTop * progress) + "px";
			element.style.paddingBottom = paddingBottom - (paddingBottom * progress) + "px";
			element.style.marginTop = marginTop - (marginTop * progress) + "px";
			element.style.marginBottom = marginBottom - (marginBottom * progress) + "px";
			element.style.height = height - (height * progress) + "px";
		}
	});

	animation.promise().then(oReason => {
		if (!(oReason instanceof Error)) {
			element.style.overflow = storedOverflow;
			element.style.paddingTop = storedPaddingTop;
			element.style.paddingBottom = storedPaddingBottom;
			element.style.marginTop = storedMarginTop;
			element.style.marginBottom = storedMarginBottom;
			element.style.height = storedHeight;
			element.style.display = "none";
		}
	});

	return animation;
};

class PanelTemplateContext {

	static calculate(state) {
		let context = {
			ctr: state,
			accRole: state.accessibleRole.toLowerCase(),
			classes: {
				main: {
					"sapMPanel": true
				},
				header: {
					"sapMPanelWrappingDivTb": state.headerToolbar,
					"sapMPanelWrappingDivTbExpanded": state.headerToolbar && state.collapsed,
					"sapMPanelWrappingDiv": !state.headerToolbar,
					"sapMPanelWrappingDivExpanded": !state.headerToolbar && !state.collapsed
				},
				icon: {
					"sapMPanelIconExpanded": !state.collapsed
				},
				info: {
					"sapMPanelExpandablePart": !!state.infoToolbar && !state.fixed
				},
				content: {
					"sapMPanelContent": true,
					"sapMPanelExpandablePart": !state.fixed,
					[`sapMPanelBG${state.backgroundDesign}`]: true
				}
			},
			styles: {
				main: {
				},
				info: {
					"display": state._contentExpanded ? "block" : "none"
				},
				content: {
					"display": state._contentExpanded ? "block" : "none"
				}
			},
			shouldRenderH1: !state.headerToolbar && (state.headerText || !state.fixed)
		};

		return context;
	}
}

const PanelAccessibleRoles = {

	Complementary: "Complementary",

	Form: "Form",

	Region: "Region"
};

class PanelAccessibleRole extends DataType {
	static isValid(value) {
		return !!PanelAccessibleRoles[value];
	}
}

PanelAccessibleRole.generataTypeAcessors(PanelAccessibleRoles);

const html$h = index.html;
const repeat$h = index.repeat;

const PanelLitRenderer = {};

const block0$g = (context) => { return html$h`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
		data-sap-ui-fastnavgroup="true"
		class="${index.ifTruthy(context.classes.main)}"
		style="${index.ifTruthy(context.styles.main)}"
		role="${index.ifTruthy(context.accRole)}"
><!-- header: either header toolbar, or h1 with header text -->
	${ context.ctr.fixed ? block1$a(context) : block4$3(context) }<!-- info toolbar -->
	${ context.ctr.infoToolbar ? block7(context) : undefined }<!-- content area --><div class="${index.ifTruthy(context.classes.content)}" tabindex="-1" style="${index.ifTruthy(context.styles.content)}">
		${ repeat$h(context.ctr.content, undefined, (item, index$$1) => block8(item, index$$1, context)) }</div></div>

`; };
const block1$a = (context) => { return html$h`${ context.ctr.headerToolbar ? block2$6(context) : undefined }${ context.shouldRenderH1 ? block3$5(context) : undefined }`; };
const block2$6 = (context) => { return html$h`<div class="sapMPanelHdrToolbar"><slot name="${index.ifTruthy(context.ctr.headerToolbar._slot)}"></slot></div>
	`; };
const block3$5 = (context) => { return html$h`<h1 id="${index.ifTruthy(context.ctr._id)}-header" class="sapMPanelHdr">
			${index.ifTruthy(context.ctr.headerText)}</h1>
	`; };
const block4$3 = (context) => { return html$h`<header class="${index.ifTruthy(context.classes.header)}"><ui5-icon
					functional
					class="${index.ifTruthy(context.classes.icon)}"
					src="${index.ifTruthy(context.ctr._icon.src)}"
					@press="${index.ifTruthy(context.ctr._icon.onPress)}"
			></ui5-icon>
			${ context.ctr.headerToolbar ? block5$3(context) : undefined }${ context.shouldRenderH1 ? block6(context) : undefined }</header>
	`; };
const block5$3 = (context) => { return html$h`<div class="sapMPanelHdrToolbar"><slot name="${index.ifTruthy(context.ctr.headerToolbar._slot)}"></slot></div>
	`; };
const block6 = (context) => { return html$h`<h1 id="${index.ifTruthy(context.ctr._id)}-header" class="sapMPanelHdr">
			${index.ifTruthy(context.ctr.headerText)}</h1>
	`; };
const block7 = (context) => { return html$h`<div class="${index.ifTruthy(context.classes.info)}" style="${index.ifTruthy(context.styles.info)}"><slot name="${index.ifTruthy(context.ctr.infoToolbar._slot)}"></slot></div>
	`; };
const block8 = (item, index$$1, context) => { return html$h`<slot name="${index.ifTruthy(item._slot)}"></slot>
		`; };
const renderMe$g = block0$g;

PanelLitRenderer.render = renderMe$g;

/**
 * @public
 */
const metadata$j = {
	tag: "ui5-panel",
	styleUrl: [
		"Icon.css",
		"Panel.css"
	],
	defaultSlot: "content",
	slots: {
		/**
		 * A custom <code>Toolbar</code> as header for the <code>Panel</code>.
		 * The <code>headerToolbar</code> is visible in both expanded and collapsed state.
		 * Use it when you want to add extra controls for user interactions in the header.
		 * Note: This overwrites <code>headerText</code> property.
		 * @type {Control}
		 * @public
		 */
		headerToolbar: {
			type: HTMLElement
		},
		/**
		 * A custom <code>Toolbar</code> as information bar for the <code>Panel</code>.
		 * The <code>infoToolbar</code> is placed below the header and is visible only in expanded state.
		 * Use it when you want to show extra information to the user.
		 * @type {Control}
		 * @public
		 */
		infoToolbar: {
			type: HTMLElement
		},
		/**
		 * Determines the content of the <code>Panel</code>.
		 * The content will be visible only when the <code>Panel</code> is expanded.
		 * @type {Control}
		 * @public
		 */
		content: {
			type: HTMLElement,
			multiple: true
		}
	},
	properties: /** @lends sap.ui.webcomponents.main.Panel.prototype */ {
		/**
		 * This property is used to set the header text of the <code>Panel</code>.
		 * The <code>headerText</code> is visible in both expanded and collapsed state.
		 * Note: This property is overwritten by the "headerToolbar".
		 * @type {string}
		 * @public
		 */
		headerText: {
			type: String,
			defaultValue: ""
		},
		width: {
			defaultValue: "100%",
			type: CSSSize
		},
		height: {
			defaultValue: "auto",
			type: CSSSize
		},
		/**
		 * Specifies whether the control is expandable.
		 * This allows for collapsing or expanding the infoToolbar (if available) and content of the Panel.
		 * Note: If fixed is set, the <code>Panel</code> will always be rendered expanded.
		 * @type {boolean}
		 * @public
		 */
		fixed: {
			type: Boolean
		},
		/**
		 * Indicates whether the <code>Panel</code> is collapsed or not.
		 * If collapsed is not set, then both the infoToolbar (if available) and the content are rendered.
		 * If collapsed is set, then only the headerText or headerToolbar is rendered.
		 * @type {boolean}
		 * @public
		 */
		collapsed: {
			type: Boolean
		},
		/**
		 * This property is used to set the background color of the <code>Panel</code>.
		 * Depending on the theme you can change the state of the background from "Solid" over "Translucent" to "Transparent".
		 * @type {BackgroundDesign}
		 * @public
		 */
		backgroundDesign: {
			type: BackgroundDesign,
			defaultValue: BackgroundDesign.Translucent
		},
		/**
		 * This property is used to set the accessible aria role of the <code>Panel</code>.
		 * Depending on the usage you can change the role from the default <code>Form</code> to <code>Region</code> or <code>Complementary</code>.
		 * @type {PanelAccessibleRole}
		 * @public
		 */
		accessibleRole: {
			type: PanelAccessibleRole,
			defaultValue: PanelAccessibleRole.Form
		},
		_icon: {
			type: Object
		},
		_contentExpanded: {
			type: Boolean
		},
		_animationRunning: {
			type: Boolean
		}
	},
	events: {
		expand: {
			expand: {type : Boolean}
		}
	}
};

/**
 * @class
 *
 * Constructor for a new Panel.
 *
 * A container control which has a header and content.
 * <h3>Overview</h3>
 * The panel is a container for grouping and displaying information. It can be collapsed to save space on the screen.
 * <h4>Guidelines:</h4>
 * <ul>
 * <li>Nesting two or more panels is not recommended.</li>
 * <li>Do not stack too many panels on one page.</li>
 * </ul>
 * <h3>Structure</h3>
 * A panel consists of a title bar with a header text or header toolbar, an info toolbar (optional), and a content area.
 *
 * <h3>Usage</h3>
 * <h4>When to use:</h4>
 * <ul>
 * <li>You need to group or display information and want to give users the option of hiding this information.</li>
 * <li>You want to show additional information on demand (for example, a panel could show optional input fields for an advanced search).</li>
 * <li>You want to create a panel with controls that do not require user interaction and are not part of a form.</li>
 * </ul>
 * <h3>Responsive Behavior</h3>
 * <ul>
 * <li>If the width of the panel is set to 100% (default), the panel and its children are resized responsively, depending on its parent container.</li>
 * <li>If the panel has a fixed defined height, it will take up the space, even if the panel is collapsed.</li>
 * <li>When the panel is expandable, an arrow icon (pointing to the right) appears in front of the header.</li>
 * <li>When the animation is activated, expand/collapse uses a smooth animation to open or close the content area.</li>
 * <li>When the panel expands/collapses, the arrow icon rotates 90 degrees clockwise/counter-clockwise.</li>
 * </ul>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Panel
 * @public
 */
class Panel$2 extends WebComponent {

	static get metadata() {
		return metadata$j;
	}

	static get renderer() {
		return PanelLitRenderer;
	}

	static get calculateTemplateContext() {
		return PanelTemplateContext.calculate;
	}

	constructor(state) {
		super(state);
		this._icon = {};
		this._icon.id = this.id + "-CollapsedImg";
		this._icon.src = IconPool.getIconURI("navigation-right-arrow");
		// rework once globalisation is ready
		// this._icon.tooltip = sap.ui.getCore().getLibraryResourceBundle("sap.m").getText("PANEL_ICON");
		this._icon.functional = true;
		this._icon.onPress = this._iconPress.bind(this);
	}

	onBeforeRendering() {
		// If the animation is running, it will set the content expanded state at the end
		if (!this._animationRunning) {
			this._contentExpanded = !this.collapsed;
		}

		this._icon._customAttributes = {
			"aria-expanded": !this.collapsed,
			"aria-labelledby": this.headerToolbar ? undefined : this.id + "-header"
		};
	}

	_iconPress() {
		this.collapsed = !this.collapsed;
		this._animationRunning = true;

		let elements = this.getDomRef().querySelectorAll(".sapMPanelExpandablePart");
		let animations = [];

		[].forEach.call(elements, oElement => {
			if (this.collapsed) {
				animations.push(slideUp({
					element: oElement
				}).promise());
			} else {
				animations.push(slideDown({
					element: oElement
				}).promise());
			}
		});

		Promise.all(animations).then(_ => {
			this._animationRunning = false;
			this._contentExpanded = !this.collapsed;
			this._fireExpandEvent();
		});
	}

	_fireExpandEvent() {
		this.fireEvent("expand", {
			expand: !this.collapsed
		});
	}
}

Core$1.boot().then(_ => {
	Panel$2.define();
});

class RadioButtonGroup {

	static hasGroup(groupName) {
		return this.groups.has(groupName);
	}

	static getGroup(groupName) {
		return this.groups.get(groupName);
	}

	static removeGroup(groupName) {
		return this.groups.delete(groupName);
	}

	static addToGroup(control, groupName) {
		if (this.hasGroup(groupName)) {
			this.getGroup(groupName).push(control);
		} else {
			this.createGroup(control, groupName);
		}
	}

	static removeFromGroup(control, groupName) {
		if (!this.hasGroup(groupName)) {
			return;
		}

		const group = this.getGroup(groupName);

		// Remove the control from the given group
		group.forEach((_control, idx, arr) => {
			if (control._id === _control._id) {
				return arr.splice(idx, 1);
			}
		});

		// Remove the group if it is empty
		if (!group.length) {
			this.removeGroup(groupName);
		}
	}

	static createGroup(control, groupName) {
		if (!this.hasGroup(groupName)) {
			this.groups.set(groupName, [control]);
		}
	}

	static selectNextItem(item, groupName) {
		const group = this.getGroup(groupName),
			groupLength = group.length,
			currentItemPosition = group.indexOf(item);

		if (groupLength <= 1) {
			return;
		}

		const nextItemToSelect = this._nextSelectable(currentItemPosition, group);

		// de-select all the rest
		group.forEach(radio => {
			if (radio._id !== nextItemToSelect._id) {
				radio.selected = false;
				radio.fireEvent("select", {selected: radio.selected});
			}
		});

		// select the next item
		this._selectItem(nextItemToSelect);
	}

	static selectPreviousItem(item, groupName) {
		const group = this.getGroup(groupName),
			groupLength = group.length,
			currentItemPosition = group.indexOf(item);

		if (groupLength <= 1) {
			return;
		}

		const previousItemToSelect = this._previousSelectable(currentItemPosition, group);

		// de-select all the rest
		group.forEach(radio => {
			if (radio._id !== previousItemToSelect._id) {
				radio.selected = false;
				radio.fireEvent("select", {selected: radio.selected});
			}
		});

		// select the next item
		this._selectItem(previousItemToSelect);
	}

	static selectItem(item, groupName) {
		const group = this.getGroup(groupName);

		// de-select all the rest
		group.forEach(radio => {
			if (radio._id !== item._id) {
				radio.selected = false;
				radio.fireEvent("select", {selected: radio.selected});
			}
		});

		this._selectItem(item);
	}

	static get groups(){
		if (!this._groups) {
			this._groups = new Map();
		}
		return this._groups;
	}

	static _selectItem(item) {
		item.focus();
		item.selected = true;
		item.fireEvent("select", {selected: item.selected});
	}

	static _nextSelectable(pos, group) {
		const groupLength = group.length;
		let nextItemToSelect = null;

		if (pos === groupLength - 1) {

			if (!group[0].disabled) {
				nextItemToSelect = group[0];
			} else {
				return this._nextSelectable(0, group);
			}

		} else if (!group[++pos].disabled) {
				nextItemToSelect = group[pos];
		} else {
			return this._nextSelectable(pos, group);
		}

		return nextItemToSelect;
	}

	static _previousSelectable(pos, group) {
		const groupLength = group.length;
		let previousSelectable = null;

		if (pos === 0) {

			if (!group[groupLength - 1].disabled) {
				previousSelectable = group[groupLength - 1];
			} else {
				return this._nextSelectable(groupLength - 1, group);
			}

		} else if (!group[--pos].disabled) {
			previousSelectable = group[pos];
		} else {
			return this._previousSelectable(pos, group);
		}

		return previousSelectable;
	}
}

const html$i = index.html;

const RadioButtonLitRenderer = {};

const block0$h = (context) => { return html$i`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
	class="${index.ifTruthy(context.classes.main)}"
	style="${index.ifTruthy(context.styles.main)}"
	role="radio"
	aria-checked="${index.ifTruthy(context.ctr.selected)}"
	aria-readonly="${index.ifTruthy(context.readOnly)}"
	tabindex="${index.ifTruthy(context.tabIndex)}"
	title="${index.ifTruthy(context.tooltip)}"><div class='${index.ifTruthy(context.classes.inner)}'><svg class="sapMRbSvg" focusable="false"><circle class="sapMRbSvgOuter" cx="24" cy="24" r="10" stroke-width="2" fill="none" /><circle class="sapMRbSvgInner" cx="24" cy="24" r="5" stroke-width="10" /></svg><input type='radio' ?checked="${index.ifTruthy(context.ctr.selected)}" ?readonly="${index.ifTruthy(context.ctr.readOnly)}" ?disabled="${index.ifTruthy(context.ctr.readOnly)}" name="${index.ifTruthy(context.ctr.group)}" data-sap-no-tab-ref/></div>

	${ context.ctr._label.text ? block1$b(context) : undefined }</div>`; };
const block1$b = (context) => { return html$i`<ui5-label class="labelInRadioButton">${index.ifTruthy(context.ctr._label.text)}</ui5-label>
	`; };
const renderMe$h = block0$h;

RadioButtonLitRenderer.render = renderMe$h;

class RadioButtonTemplateContext {

	static calculate(state) {
		let mainClasses = RadioButtonTemplateContext.getMainClasses(state);
		let innerClasses = RadioButtonTemplateContext.getInnerClasses(state);
		let tooltip = ValueStateSupport.getEnrichedTooltip(state.tooltip, state.valueState);

		let context = {
			tooltip: tooltip,
			ctr: state,
			readOnly: state.disabled || state.readOnly,
			tabIndex: state.disabled ? undefined : "0",
			classes: { main: mainClasses, inner: innerClasses},
			styles: {
				main: {"width": state.width}
			}
		};

		return context;
	}

	static getMainClasses(state) {
		return {
			"sapMRb": true,
			"sapMRbHasLabel": state.text && state.text.length > 0,
			"sapMRbSel": state.selected,
			"sapMRbDis": state.disabled,
			"sapMRbRo": state.readOnly,
			"sapMRbErr": state.valueState === "Error",
			"sapMRbWarn": state.valueState === "Warning"
		};
	}

	static getInnerClasses(state) {
		let hoverable = !state.disabled && !state.readOnly && Device.system.desktop;

		return {
			"sapMRbInner": true,
			"sapMRbHoverable": hoverable
		};
	}
}

/**
 * @public
 */
const metadata$k = {
	tag: "ui5-radiobutton",
	styleUrl: [
		"RadioButton.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.RadioButton.prototype */  {

		/**
		 * Defines the <code>displayOnly</code> state of the <code>RadioButton</code>.
		 * Takes effect when the <code>RadioButton</code> is not disabled.
		 * @type {boolean}
		 * @public
		 */
		disabled: {
			"type": Boolean
		},

		/**
		 * Defines if the <code>RadioButton</code> is read only, e.g. editable or not
		 * @type {boolean}
		 * @public
		 */
		readOnly: {
			"type": Boolean
		},

		/**
		 * Defines if the <code>RadioButton</code> is selected or not.
		 * @type {boolean}
		 * @public
		 */
		selected: {
			"type": Boolean
		},

		/**
		 * Defines the text of the <code>RadioButton</code>.
		 * @type  {string}
		 * @public
		 */
		text : {
			"defaultValue": null,
			"type": String
		},

		/**
		 * Defines the tooltip of the <code>RadioButton</code>.
		 * @type  {string}
		 * @public
		 */
		tooltip : {
			"defaultValue": "",
			"type": String
		},

		/**
		 * Defines the value state of the <code>RadioButton</code>.
		 * Available options are: 'Warning', 'Error' and 'None' (by default).
		 * @type {string}
		 * @public
		 */
		valueState : {
			"defaultValue": ValueState.None,
			"type": ValueState
		},

		/**
		 * Defines the width of the CheckBox text.
		 * @type {string}
		 * @public
		 */
		width : {
			"defaultValue": "",
			"type": CSSSize
		},

		/**
		 * Defines which group the <code>RadioButton</code> belongs.
		 * @type {string}
		 * @public
		 */
		group : {
			"defaultValue": "",
			"type": String
		},

		_label: {
			"type": Object
		}
	},
	events: /** @lends sap.ui.webcomponents.main.RadioButton.prototype */ {
		/**
		 * Fired, whenever the <code>RadioButton</code> selected state changes.
		 * @event
		 * @param {boolean} selected Whether the <code>RadioButton</code> is  or not.
		 * @public
		 */
		select: {
			detail : {
				selected : {type : "boolean"}
			}
		}
	}
};

/**
 * @class
 * A class to represent a <code>RadioButton</code>.
 *
 * <b> Overview </b>
 * Enables users to select a single option from a set of options.
 * <h3>Use the <code>RadioButton</code> when you quickly need to choose between at least two alternatives.</li>
 *
 * <h3>When not to use:</h4>
 * <ul>
 * <li>You want to select multiple values for the same option - use CheckBox instead.</li>
 * <li>When the options are mutually exclusive</li>
 * </ul>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.RadioButton
 * @public
 */
class RadioButton$2 extends WebComponent {

	static get metadata() {
		return metadata$k;
	}

	static get renderer() {
		return RadioButtonLitRenderer;
	}

	constructor(state) {
		super(state);
		this._label = {};
	}

	onBeforeRendering() {
		this.syncLabel();
		this.syncGroup();
	}

	syncLabel() {
		this._label = Object.assign({}, this._label);
		this._label.text = this.text;
	}

	syncGroup() {
		const oldGroup = this._group;
		const currentGroup = this.group;

		if (currentGroup === oldGroup) {
			return;
		}

		if (oldGroup) {
			// remove the control from the previous group
			RadioButtonGroup.removeFromGroup(this, oldGroup);
		}

		if (currentGroup) {
			// add the control to the existing group
			RadioButtonGroup.addToGroup(this, currentGroup);
		}

		this._group = this.group;
	}

	ontap() {
		return this.toggle();
	}

	onsapdown(event){
		const currentGroup = this.group;

		if (!currentGroup) {
			return;
		}

		event.preventDefault();
		RadioButtonGroup.selectNextItem(this, currentGroup);
	}

	onsapup(event){
		const currentGroup = this.group;

		if (!currentGroup) {
			return;
		}

		event.preventDefault();
		RadioButtonGroup.selectPreviousItem(this, currentGroup);
	}

	onsapleft(event){
		this.onsapup(event);
	}

	onsapright(event){
		this.onsapdown(event);
	}

	onkeydown(event) {
		if (event.keyCode === mKeyCodes.SPACE ) {
			event.preventDefault();
		}

		if (event.keyCode === mKeyCodes.ENTER) {
			this.toggle();
		}
	}

	onkeyup(event) {
		if (event.keyCode === mKeyCodes.SPACE) {
			this.toggle();
		}
	}

	toggle() {
		if (!this.canToggle()) {
			return this;
		}

		if (!this.group) {
			this.selected = !this.selected;
			this.fireEvent("select", {selected: this.selected});
			return this;
		}

		RadioButtonGroup.selectItem(this, this.group);
		return this;
	}

	canToggle() {
		return !(this.disabled || this.readOnly || this.selected);
	}

	static get calculateTemplateContext() {
		return RadioButtonTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	RadioButton$2.define();
});

var scroll = ({
	element = animationConfig.element,
	duration = animationConfig.duration,
	progress: progressCallback = animationConfig.identity,
	dx = 0,
	dy = 0
}) => {
	let scrollLeft;
	let scrollTop;

	return animate({
		beforeStart: _ => {
			scrollLeft = element.scrollLeft;
			scrollTop = element.scrollTop;
		},
		duration: duration,
		element: element,
		progress: progress => {
			progressCallback(progress);

			element.scrollLeft = scrollLeft + (progress * dx); // easing - linear
			element.scrollTop = scrollTop + (progress * dy); // easing - linear
		}
	});
};

const scrollEventName = 'scroll';

class ScrollEnablement extends EventProvider {

	constructor() {
		super();
	}

	set scrollContainer(container) {
		this._container = container;
	}

	get scrollContainer() {
		return this._container;
	}

	scrollTo(left, top) {
		this._container.scrollLeft = left;
		this._container.scrollTop = top;
	}

	move(dx, dy) {
		return scroll({
			element: this._container,
			dx: dx,
			dy: dy
		});
	}

	getScrollLeft() {
		return this._container.scrollLeft;
	}

	getScrollTop() {
		return this._container.scrollTop;
	}

	_isTouchInside(touch) {
		let rect = this._container.getBoundingClientRect();
		let x = touch.clientX;
		let y = touch.clientY;

		return x >= rect.left && x <= rect.right &&
			y >= rect.top && y <= rect.bottom;
	}

	ontouchstart(event) {
		let touch = event.touches[0];
		this._prevDragX = touch.pageX;
		this._prevDragY = touch.pageY;

		this._canScroll = this._isTouchInside(touch);
	}

	ontouchmove(event) {

		if (!this._canScroll) {
			return;
		}

		let container = this._container;
		let touch = event.touches[0];

		let dragX = touch.pageX;
		let dragY = touch.pageY;

		container.scrollLeft += this._prevDragX - dragX;
		container.scrollTop += this._prevDragY - dragY;

		this.fireEvent(scrollEventName, {});

		this._prevDragX = dragX;
		this._prevDragY = dragY;
	}
}

class TabContainerTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			classes: {
				main: {
					sapMITB: true,
					sapMITBCollapsed: state.collapsed
				},
				tablist: {
					sapMITH: true,
					sapContrastPlus: true,
					sapMITHOverflowList: state.showOverflow,
					sapMITBScrollable: state._scrollable,
					sapMITBNotScrollable: !state._scrollable,

					sapMITBScrollForward: state._scrollable && state._scrollForward,
					sapMITBNoScrollForward: state._scrollable && !state._scrollForward,

					sapMITBScrollBack: state._scrollable && state._scrollBack,
					sapMITBNoScrollBack: state._scrollable && !state._scrollBack
				},
				head: {
					sapMITBHead: true,
					sapMITBTextOnly: state._isNoIcon,
					sapMITBNoText: state._isNoText,
					sapMITBInLine: state._isInline
				},
				content: {
					sapMITBContainerContent: true,
					sapMITBContentClosed: state.collapsed
				}
			}
		};

		context.classes.tablist['sapMITHBackgroundDesign' + state.headerBackgroundDesign] = true;
		context.classes.main['sapMITBBackgroundDesign' + state.backgroundDesign] = true;

		return context;
	}
}

/**
 * @public
 */
const metadata$l = {
	properties: {
	},
	events : {

	}
};

/**
 * @class
 * Represents a base class for all tabs inside a TabContainer.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TabBase
 * @public
 */
class TabBase extends WebComponent {

	static get metadata() {
		return metadata$l;
	}

	constructor(state) {
		super(state);
	}
}

class TabTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			classes: {
				main: {

				}
			}
		};

		return context;
	}
}

const TabDesignModes = {
	/**
	 * A horizontally layouted design providing more space for texts.
	 * @public
	 */
	Horizontal: "Horizontal",

	/**
	 * A vertically layouted design using minimum horizontal space.
	 * @public
	 */
	Vertical: "Vertical"
};

class TabDesignMode extends DataType {
	static isValid(value) {
		return !!TabDesignModes[value];
	}
}

TabDesignMode.generataTypeAcessors(TabDesignModes);

const html$j = index.html;
const repeat$j = index.repeat;

const TabLitRenderer = {};

const block0$i = (context) => { return html$j`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}">	${ repeat$j(context.ctr.content, undefined, (item, index$$1) => block1$c(item, index$$1, context)) }</div>`; };
const block1$c = (item, index$$1, context) => { return html$j`<slot name="${index.ifTruthy(item._slot)}"></slot>	`; };
const renderMe$i = block0$i;

TabLitRenderer.render = renderMe$i;

/**
 * @public
 */
const metadata$m = {
	tag: "ui5-tab",
	styleUrl: [],
	defaultSlot: "content",
	slots: {
		/**
		 * Defines the tab content.
		 * @type {HTMLElement}
		 * @public
		 */
		content: {type: HTMLElement, multiple: true}
	},
	properties: /** @lends  sap.ui.webcomponents.main.Tab.prototype */  {
		/**
		 * The text to be displayed for the item.
		 * @type {String}
		 * @public
		 */
		text: {type: String, group: "Misc", defaultValue: ""},

		/**
		 * Enabled items can be selected.
		 * @type {Boolean}
		 * @public
		 */
		disabled: {type: Boolean, group: "Misc"},

		/**
		 * Options are RTL and LTR. Alternatively, an item can inherit its text direction from its parent control.
		 * @type {TextDirection}
		 * @public
		 */
		textDirection: {type: TextDirection, group: "Misc", defaultValue: TextDirection.Inherit},

		/**
		 * Can be used as input for subsequent actions.
		 * @type {String}
		 * @public
		 */
		key: {type: String, group: "Data", defaultValue: ''},


		/**
		 * Represents the "count" text, which is displayed in the tab filter.
		 * @type {String}
		 * @public
		 */
		count: {type: String, group: "Data", defaultValue: ''},

		/**
		 * Specifies the icon to be displayed for the tab filter.
		 * @type {URI}
		 * @public
		 */
		icon: {type: URI$1, group: "Misc", defaultValue: ''},

		/**
		 * Specifies the icon color.
		 *
		 * If an icon font is used, the color can be chosen from the icon colors (sap.ui.core.IconColor).
		 * Possible semantic colors are: Neutral, Positive, Critical, Negative.
		 * Instead of the semantic icon color the brand color can be used, this is named Default.
		 * Semantic colors and brand colors should not be mixed up inside one IconTabBar.
		 * @type {IconColor}
		 * @public
		 */
		iconColor: {type: IconColor, group: "Appearance", defaultValue: IconColor.Default},

		/**
		 * Specifies whether the icon and the texts are placed vertically or horizontally.
		 * @type {TabDesignMode}
		 * @public
		 */
		design: {type: TabDesignMode, group: "Appearance", defaultValue: TabDesignMode.Vertical},

		_showAll: {type: Boolean},
		_isSelected: {type: Boolean},
		_isInline: {type: Boolean},
		_isNoIcon: {type: Boolean},
		_isNoText: {type: Boolean},
		_tabIndex: {type: String, defaultValue: "-1"},
		_posinset: {type: Integer},
		_setsize: {type: Integer},
		_contentId: {type: String, defaultValue: " "},
		_labelledbyControls: {type: String, defaultValue: " "},
		_isIconColorRead: {type: Boolean}
	},
	events : {

	}
};

/**
 * @class
 * Represents a selectable item inside a TabContainer.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Tab
 * @public
 */
class Tab extends TabBase {

	static get metadata() {
		return metadata$m;
	}

	static get renderer() {
		return TabLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	/**
	 * If the Tab doesn't have a key, the function returns the ID of the Tab,
	 * so the TabContainer can remember the selected Tab.
	 *
	 * @private
	 */
	_getUniqueKey() {
		if (this.key) {
			return this.key;
		}

		return this._id;
	}

	static get calculateTemplateContext() {
		return TabTemplateContext.calculate;
	}
}

Core$1.boot().then(async _ => {
	await Icon$2.define();
	Tab.define();
});

class TabSeparatorTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			isSeparator: true,
			classes: {
				main: {
					"sapMITBItem": true,
					"sapMITBSep": true,
					"sapMITBSepLine": true
				}
			}
		};


		return context;
	}
}

const html$k = index.html;

const TabSeparatorLitRenderer = {};

const block0$j = (context) => { return html$k`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}" role="separator" class="${index.ifTruthy(context.classes.main)}"></div>`; };
const renderMe$j = block0$j;

TabSeparatorLitRenderer.render = renderMe$j;

const metadata$n = {
	tag: "ui5-tab-separator",
	styleUrl: [],
	properties: {
	},
	events : {

	}
};

/**
 * @class
 * Represents an Icon used to separate 2 tabs inside a TabContainer.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TabSeparator
 * @public
 */
class TabSeparator extends TabBase {

	static get metadata() {
		return metadata$n;
	}

	static get renderer() {
		return TabSeparatorLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	static get calculateTemplateContext() {
		return TabSeparatorTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	TabSeparator.define();
});

const TabContainerHeaderModes = {

	/**
	 * Standard. In this mode when the <code>count</code> and the <code>text</code> are set, they are displayed in two separate lines.
	 * @public
	 */
	Standard: "Standard",

	/**
	 * Inline. In this mode when the <code>count</code> and the <code>text</code> are set, they are displayed in one line.
	 * @public
	 */
	Inline: "Inline"
};

class TabContainerHeaderMode extends DataType {
	static isValid(value) {
		return !!TabContainerHeaderModes[value];
	}
}

TabContainerHeaderMode.generataTypeAcessors(TabContainerHeaderModes);

const html$l = index.html;
const repeat$l = index.repeat;

const TabContainerLitRenderer = {};

const block0$k = (context) => { return html$l`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}" class="${index.ifTruthy(context.classes.main)}"><div role='tablist' class="${index.ifTruthy(context.classes.tablist)}"><ui5-icon no-tab-stop				  functional				  skip-icon-tooltip				  src="sap-icon://slim-arrow-left"				  class="${index.ifTruthy(context.ctr._leftArrow.classes)}"				  @press="${index.ifTruthy(context.ctr._leftArrow.onPress)}"></ui5-icon><div id="${index.ifTruthy(context.ctr._id)}-scrollContainer" class="sapMITBScrollContainer"><div id="${index.ifTruthy(context.ctr._id)}-head" tabindex="-1" class="${index.ifTruthy(context.classes.head)}">				${ repeat$l(context.ctr._headerItems, undefined, (item, index$$1) => block1$d(item, index$$1, context)) }</div></div><ui5-icon no-tab-stop				  functional				  skip-icon-tooltip				  src="sap-icon://slim-arrow-right"				  class="${index.ifTruthy(context.ctr._rightArrow.classes)}"				  @press="${index.ifTruthy(context.ctr._rightArrow.onPress)}"></ui5-icon>		${ context.ctr.showOverflow ? block22(context) : undefined }</div><div id="${index.ifTruthy(context.ctr._id)}-containerContent" class="${index.ifTruthy(context.classes.content)}"><div id="${index.ifTruthy(context.ctr._id)}-content" class="sapMITBContent" role="tabpanel">			${ repeat$l(context.ctr._selectedContent, undefined, (item, index$$1) => block23(item, index$$1, context)) }</div></div>	${ context.ctr.showOverflow ? block24(context) : undefined }</div>`; };
const block1$d = (item, index$$1, context) => { return html$l`${ item.isSeparator ? block2$7(item, index$$1, context) : block3$6(item, index$$1, context) }`; };
const block2$7 = (item, index$$1, context) => { return html$l`<div role="separator" class="sapMITBItem sapMITBSep sapMITBSepLine"></div>`; };
const block3$6 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}"			tabindex="${index.ifTruthy(item._tabIndex)}"			class="${index.ifTruthy(item.classes.main)}"			role="tab"			aria-selected="${index.ifTruthy(item.isSelected)}"			aria-disabled="${index.ifTruthy(item.isDisabled)}"			aria-posinset="${index.ifTruthy(item.posinset)}"			aria-setsize="${index.ifTruthy(item.setsize)}"			aria-controls="${index.ifTruthy(item.contentId)}"			aria-labelledby="${index.ifTruthy(item.labelledbyControls)}">		${ item.showAll ? block4$4(item, index$$1, context) : block6$1(item, index$$1, context) }<div class="sapMITBContentArrow"></div></div>`; };
const block4$4 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-tab" class="sapMITBTab"><span id="${index.ifTruthy(item.id)}-count" class="sapMITBCount">			${index.ifTruthy(item.count)}</span></div>			${ item.displayText ? block5$4(item, index$$1, context) : undefined }`; };
const block5$4 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-text" class="sapMITBText">					${index.ifTruthy(item.displayText)}</div>			`; };
const block6$1 = (item, index$$1, context) => { return html$l`${ item.isHorizontalDesign ? block7$1(item, index$$1, context) : block10(item, index$$1, context) }`; };
const block7$1 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-tab" class="sapMITBTab">				${ item.isIconColorRead ? block8$1(item, index$$1, context) : undefined }${ item.icon ? block9(item, index$$1, context) : undefined }</div><div class="sapMITBHorizontalWrapper"><span id="${index.ifTruthy(item.id)}-count" class="sapMITBCount">				${index.ifTruthy(item.count)}</span><div id="${index.ifTruthy(item.id)}-text" class="sapMITBText">					${index.ifTruthy(item.displayText)}</div></div>		`; };
const block8$1 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-iconColor" style="display: none;">${index.ifTruthy(item.iconColor)}</div>				`; };
const block9 = (item, index$$1, context) => { return html$l`<ui5-icon src="${index.ifTruthy(item.icon)}" class="sapMITBFilterIcon  sapMITBFilter${index.ifTruthy(item.iconColor)}"></ui5-icon>				`; };
const block10 = (item, index$$1, context) => { return html$l`${ item.isInline ? block11(item, index$$1, context) : block12(item, index$$1, context) }`; };
const block11 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-text" class="sapMITBText">				${index.ifTruthy(item.displayText)}</div>		`; };
const block12 = (item, index$$1, context) => { return html$l`${ item.isNoIcon ? block13(item, index$$1, context) : block15(item, index$$1, context) }`; };
const block13 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-tab" class="sapMITBTab"><span id="${index.ifTruthy(item.id)}-count" class="sapMITBCount">				${index.ifTruthy(item.count)}</span></div>			${ item.displayText ? block14(item, index$$1, context) : undefined }`; };
const block14 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-text" class="sapMITBText">					${index.ifTruthy(item.displayText)}</div>			`; };
const block15 = (item, index$$1, context) => { return html$l`${ item.isNoText ? block16(item, index$$1, context) : block19(item, index$$1, context) }`; };
const block16 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-tab" class="sapMITBTab">				${ item.isIconColorRead ? block17(item, index$$1, context) : undefined }${ item.icon ? block18(item, index$$1, context) : undefined }<span id="${index.ifTruthy(item.id)}-count" class="sapMITBCount">					${index.ifTruthy(item.count)}</span></div>		`; };
const block17 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-iconColor" style="display: none;">${index.ifTruthy(item.iconColor)}</div>				`; };
const block18 = (item, index$$1, context) => { return html$l`<ui5-icon src="${index.ifTruthy(item.icon)}" class="sapMITBFilterIcon sapMITBFilter${index.ifTruthy(item.iconColor)}"></ui5-icon>				`; };
const block19 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-tab" class="sapMITBTab">				${ item.isIconColorRead ? block20(item, index$$1, context) : undefined }${ item.icon ? block21(item, index$$1, context) : undefined }<span id="${index.ifTruthy(item.id)}-count" class="sapMITBCount">					${index.ifTruthy(item.count)}</span></div><div id="${index.ifTruthy(item.id)}-text" class="sapMITBText">				${index.ifTruthy(item.displayText)}</div>		`; };
const block20 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.id)}-iconColor" style="display: none;">${index.ifTruthy(item.iconColor)}</div>				`; };
const block21 = (item, index$$1, context) => { return html$l`<ui5-icon src="${index.ifTruthy(item.icon)}" class="sapMITBFilterIcon sapMITBFilter${index.ifTruthy(item.iconColor)}"></ui5-icon>				`; };
const block22 = (context) => { return html$l`<ui5-button ._customAttributes="${index.ifTruthy(context.ctr._overflowButton._customAttributes)}"						id="${index.ifTruthy(context.ctr._id)}-overflow-button"						class="${index.ifTruthy(context.ctr._overflowButton.classes)}"						@press="${index.ifTruthy(context.ctr._overflowButton.onPress)}"						icon="sap-icon://slim-arrow-down" type="Transparent"></ui5-button>		`; };
const block23 = (item, index$$1, context) => { return html$l`<slot name="${index.ifTruthy(item._slot)}"></slot>			`; };
const block24 = (context) => { return html$l`<ui5-popover id="${index.ifTruthy(context.ctr._id)}-popover"					 hide-arrow					 hide-header					 placement-type="Bottom"					 horizontal-align="Right"><ui5-list @itemPress="${index.ifTruthy(context.ctr._overflowList.onItemPress)}">				${ repeat$l(context.ctr._overflowList.items, undefined, (item, index$$1) => block25(item, index$$1, context)) }</ui5-list></ui5-popover>	`; };
const block25 = (item, index$$1, context) => { return html$l`<ui5-li-custom id="${index.ifTruthy(item.key)}"								   type="${index.ifTruthy(item.type)}"								   selected="${index.ifTruthy(item.selected)}"								   class="${index.ifTruthy(item.classes)}"><div class="${index.ifTruthy(item.innerClasses)}">							${ item.content.icon ? block26(item, index$$1, context) : undefined }${ !item.content._isNoText ? block27(item, index$$1, context) : undefined }${ item.content.isIconColorRead ? block28(item, index$$1, context) : undefined }</div></ui5-li-custom>				`; };
const block26 = (item, index$$1, context) => { return html$l`<ui5-icon src="${index.ifTruthy(item.content.icon)}" class="sapMITBSelectItemIcon"></ui5-icon>							`; };
const block27 = (item, index$$1, context) => { return html$l`<span class="sapMITBText sapMText sapMTextNoWrap">${index.ifTruthy(item.content.displayText)}</span>							`; };
const block28 = (item, index$$1, context) => { return html$l`<div id="${index.ifTruthy(item.content._id)}-iconColor" style="display: none;">${index.ifTruthy(item.content.iconColor)}</div>							`; };
const renderMe$k = block0$k;

TabContainerLitRenderer.render = renderMe$k;

const _convertSingleClass$1 = (oClass, customStyleClasses) => {
	// Push all custom classes first, if any
	if (Array.isArray(customStyleClasses)) {
		customStyleClasses.forEach(function (sClassName) {
			oClass[sClassName] = true;
		});
	}

	return Object.keys(oClass).filter(function (className) {
		return oClass[className];
	}).join(" ");
};

/**
 * @public
 */
const metadata$o = {
	tag: "ui5-tab-container",
	defaultSlot: "items",
	slots: /** @lends  sap.ui.webcomponents.main.TabContainer.prototype */ {
		/**
		 * Defines the tabs.
		 * @type {TabBase}
		 * @public
		 * @slot
		 */
		items: {
			type: TabBase,
			multiple: true,
			listenFor: {exclude: ["content"]}
		},

		/**
		 * Defines the default container content.
		 * @type {HTMLElement}
		 * @public
		 * @slot
		 */
		content: {type: HTMLElement, multiple: true}
	},
	styleUrl: [
		"TabContainer.css"
	],
	properties: /** @lends  sap.ui.webcomponents.main.TabContainer.prototype */ {
		/**
		 * Defines if the tabs are collapsible and expandable.
		 * @type {Boolean}
		 * @public
		 */
		fixed: {type: Boolean, group: "Misc"},

		/**
		 * Indicates if the actual tab content is expanded or not.
		 * @type {Boolean}
		 * @public
		 */
		collapsed: {type: Boolean, group: "Misc"},

		/**
		 * Key of the selected tab item.
		 *
		 * If the key has no corresponding aggregated item, no changes will apply.
		 * If duplicate keys exists the first item matching the key is used.
		 * @type {String}
		 * @public
		 */
		selectedKey: {type: String, group: "Data", defaultValue: null},

		/**
		 * Specifies the background color of the IconTabBar.
		 *
		 * Depending on the theme, you can change the state of
		 * the background color to "Solid", "Translucent", or "Transparent".
		 * Default is "Solid".
		 * @type {BackgroundDesign}
		 * @public
		 * @defaultvalue BackgroundDesign.Solid
		 */
		backgroundDesign: {
			type: BackgroundDesign,
			group: "Appearance",
			defaultValue: BackgroundDesign.Solid
		},

		/**
		 * Specifies the header mode.
		 * <b>Note:</b> The Inline mode works only if no icons are set.
		 * @type {TabContainerHeaderMode}
		 * @public
		 */
		headerMode: {
			type: TabContainerHeaderMode,
			group: "Appearance",
			defaultValue: TabContainerHeaderMode.Standard
		},

		/**
		 * Specifies if the overflow select list is displayed.
		 *
		 * The overflow select list represents a list, where all tab filters are displayed,
		 * so the user can select specific tab filter easier.
		 * @type {Boolean}
		 * @public
		 */
		showOverflow: {type: Boolean, group: "Appearance"},

		/**
		 * Specifies the background color of the header.
		 *
		 * Depending on the theme, you can change the state of
		 * the background color to "Solid", "Translucent", or "Transparent".
		 * Default is "Solid".
		 * @type {BackgroundDesign}
		 * @public
		 */
		headerBackgroundDesign: {
			type: BackgroundDesign,
			group: "Appearance",
			defaultValue: BackgroundDesign.Solid
		},

		_selectedContent: {
			type: HTMLElement,
			multiple: true,
			association: true
		},

		_selectedTab: {
			type: Tab,
			association: true
		},

		_scrollable: {type: Boolean},
		_scrollForward: {type: Boolean},
		_scrollBack: {type: Boolean},

		_isNoIcon: {type: Boolean},
		_isNoText: {type: Boolean},
		_isNoIconAndCount: {type: Boolean},

		_isInline: {type: Boolean},

		_leftArrow: {type: Object},
		_rightArrow: {type: Object},

		_overflowButton: {type: Object},
		_overflowList: {type: Object},

		_headerItems: {type: Object, multiple: true},

		_navigationItems: {type: Object, multiple: true}
	},
	events: {
		/**
		 * Fired, when an item is selected.
		 * @event
		 * @param {string} key The <code>key</code> of the selected item.
		 * @public
		 */
		itemSelect: {
			key: {type: String}
		}
	}
};

const maxActivateMove = 10;
const scrollStep = 128;

/**
 * @class
 * The TabContainer represents a collection of tabs with associated content.
 * <h3>Overview</h3>
 * The TabContainer can be used for navigation within an object, or as a filter.
 * Different types of TabContainer are used based on the contents.
 * <ul>
 * <li>Filter - There is only one main content for all tabs. The main content can be filtered, based on the selected tab.</li>
 * <li>Normal tab bar - The contents of each tab are independent from each other.</li>
 * <li>Combination of the above - There can be both filtered and independent contents.</li>
 * </ul>
 * <h3>Structure</h3>
 * The TabContainer can hold two types of entities {@link Tab Tab}
 * and {@link TabSeparator TabSeparator}
 *
 * The Tab holds all information on an item - text, icon and count.
 *
 * <h3>Usage</h3>
 * <h4>Text only</h4>
 * Uses text labels as tabs with optional counter
 * <ul>
 * <li>Used when there are no suitable icons for all items.</li>
 * <li>Used when longer labels are needed.</li>
 * <li>If <code>headerMode</code> property is set to <code>Inline</code> the text and the count are displayed in one line.</li>
 * <li>Use title case.</li>
 * </ul>
 * <h4>Icon Tabs</h4>
 * Round tabs with optional counter and label
 * <ul>
 * <li>Used when there are unique icons for all items.</li>
 * <li>Only shorter labels are possible.</li>
 * <li>Provide labels for all icons or for none. Do not mix these.</li>
 * </ul>
 * <h4>Tabs as filters</h4>
 * Tabs with filtered content from the same set of items
 * <ul>
 * <li>Provide an <i>"All"</i> tab to show all items without filtering.</li>
 * <li>Use counters to show the number of items in each filter.</li>
 * </ul>
 * <h4>Tabs as process steps</h4>
 * Tabs show a single step in a process
 * <ul>
 * <li>Use an arrow (e.g. triple-chevron) as a separator to connect the steps.</li>
 * <li>Use counters to show the number of items in each filter.</li>
 * </ul>
 * <h3>Responsive Behavior</h3>
 * <ul>
 * <li>Text-only tabs are never truncated.</li>
 * <li>Use the <code>expandable</code> property to specify whether users can collapse the tab container (default = true).</li>
 * <li>On desktop, tabs can be dragged and dropped (property <code>enableTabReordering</code>).</li>
 * <li>If you have a large number of tabs, you can scroll through them with the arrows. Additionally all tabs are available in an overflow button (property <code>showOverflowSelectList</code>).</li>
 * </ul>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TabContainer
 * @extends sap.ui.webcomponents.base.WebComponent
 * @customtag ui5-tab-container
 * @public
 */
class TabContainer$2 extends WebComponent {

	static get metadata() {
		return metadata$o;
	}

	static get renderer() {
		return TabContainerLitRenderer;
	}

	static _checkIfNoIcon(tabs) {
		for (let i = 0; i < tabs.length; i++) {
			if (tabs[i].icon) {
				return false;
			}
		}

		return true;
	}

	static _checkIfNoText(tabs) {
		for (let i = 0; i < tabs.length; i++) {
			if (tabs[i].text) {
				return false;
			}
		}

		return true;
	}

	static _checkIfNoIconAndCount(tabs) {

		let tab;

		for (let i = 0; i < tabs.length; i++) {
			tab = tabs[i];
			if (tab.icon || tab.count) {
				return false;
			}
		}

		return true;
	}

	static _findClosestTab(target) {

		let maxLevel = 4;

		while (target && maxLevel) {
			if (target.classList.contains('sapMITBItem')) {
				return target;
			}

			target = target.parentElement;
			maxLevel--;
		}
	}

	constructor(state) {
		super(state);

		this._updateScrollingHandler = this._updateScrolling.bind(this);

		this._scrollEnablement = new ScrollEnablement();
		this._scrollEnablement.attachEvent('scroll', this._updateScrollingHandler);
		this._delegates.push(this._scrollEnablement);

		this._leftArrow = {
			onPress: this._scrollLeft.bind(this),
			classes: 'sapMITBArrowScroll sapMITBArrowScrollLeft'
		};

		this._rightArrow = {
			onPress: this._scrollRight.bind(this),
			classes: 'sapMITBArrowScroll sapMITBArrowScrollRight'
		};

		this._overflowButton = {
			_customAttributes: {
				tabindex: -1
			},
			onPress: this._openOverflowList.bind(this),
			classes: ''
		};

		this._overflowList = {
			onItemPress: this._overflowItemSelected.bind(this),
			items: []
		};

		this._itemNavigation = new ItemNavigation(this, {
			cyclic: false
		});
		this._delegates.push(this._itemNavigation);

		this._itemNavigation.getItemsCallback = function() {
			return this._navigationItems;
		}.bind(this);

		this._itemNavigation.setItemsCallback = function(items) {
			this._navigationItems = items;
		}.bind(this);
	}

	_initSelectedTab() {
		let tabs = this.getTabs();

		let selectedKey = this.selectedKey;
		let selectedTab = this._selectedTab || tabs[0];

		if (selectedKey) {
			selectedTab = tabs.filter(function (item) {
				return item._getUniqueKey() === selectedKey;
			})[0] || selectedTab;
		}

		this.setSelectedTab(selectedTab);
	}

	onBeforeRendering() {
		let tabs = this.getTabs();

		if (!tabs.length) {
			return;
		}

		this._initSelectedTab();

		this._isNoIcon = TabContainer$2._checkIfNoIcon(tabs);
		this._isNoText = TabContainer$2._checkIfNoText(tabs);
		this._isNoIconAndCount = TabContainer$2._checkIfNoIconAndCount(tabs);
		this._isInline = this._isNoIconAndCount || (this._isNoIcon && this.headerMode === TabContainerHeaderMode.Inline);

		let suffix = this._isNoIcon ? "TextOnly" : "";

		this._leftArrow.classes = "sapMITBArrowScroll  sapMITBArrowScrollLeft" + suffix;
		this._rightArrow.classes = "sapMITBArrowScroll  sapMITBArrowScrollRight" + suffix;

		if (this.showOverflow) {

			let buttonCustomClass = '';

			if (this._isInline) {
				buttonCustomClass = 'sapMBtnInline';
			} else if (this._isNoIconAndCount) {
				buttonCustomClass = 'sapMBtnTextOnly';
			} else if (this._isNoText) {
				buttonCustomClass = 'sapMBtnNoText';
			}

			this._overflowButton.classes = 'sapMITHBtn ' + buttonCustomClass;
		}

		this._prepareHeaderTabs();
		this._prepareOverflowList();

		this._itemNavigation.init();
	}

	onAfterRendering() {
		this._scrollEnablement.scrollContainer = this._getScrollContainer();

		if (!this._isFirstAfterRendering) {
			this._updateScrolling();
			this._scrollIntoView();
			this._isFirstAfterRendering = true;
		}
	}

	onEnterDOM() {
		ResizeHandler.register(this._getScrollContainer(), this._updateScrollingHandler);
	}

	onExitDOM() {
		ResizeHandler.deregister(this._getScrollContainer(), this._updateScrollingHandler);
	}

	_prepareHeaderTabs() {
		let items = this.items;
		let tabs = this.getTabs();

		let ariaIndex = 1;
		let length = tabs.length;
		let contentId = this.id + '-content';

		let headerItems = [];
		let navigationItems = [];

		items.forEach(tab => {

			if (tab instanceof TabSeparator) {
				headerItems.push({
					isSeparator: true
				});

				return;
			}

			let isIconColorRead = tab.iconColor === IconColor.Positive ||
				tab.iconColor === IconColor.Critical ||
				tab.iconColor === IconColor.Negative;

			let isHorizontalDesign = tab.design === TabDesignMode.Horizontal;

			let displayText = tab.text;
			if (this._isInline && tab.count) {
				displayText += " (" + tab.count + ")";
			}

			let ids = [];

			if (tab.text) {
				ids.push(tab.id + '-text');
			}
			if (tab.count) {
				ids.push(tab.id  + '-count');
			}
			if (tab.icon) {
				ids.push(tab.id  + '-icon');
			}
			if (isIconColorRead) {
				ids.push(tab.id + '-iconColor');
			}

			let labelledbyControls = ids.join(' ');
			let showAll = !this._isNoIcon && !tab.icon;

			let headerItem = {

				id: tab._id + '-header',
				_tabIndex: this._navigationItems[ariaIndex - 1] ? this._navigationItems[ariaIndex - 1]._tabIndex : -1,

				isIconColorRead: isIconColorRead,
				labelledbyControls: labelledbyControls,
				displayText: displayText,
				isDisabled: tab.disabled ? true: undefined,
				isHorizontalDesign: isHorizontalDesign,

				text: tab.text,
				count: tab.count,
				icon: tab.icon,
				iconColor: tab.iconColor,

				isInline: this._isInline,
				isNoIcon: this._isNoIcon,
				isNoText: this._isNoText,
				isInlineOrTextOnly: this._isInline || this._isNoIcon,

				showAll: showAll,

				posinset: ariaIndex++,
				setsize: length,
				contentId: contentId,
				classes: {
					main: _convertSingleClass$1({
						'sapMITBItem': true,
						'sapMITBSelected': tab._isSelected,
						'sapMITBItemNoCount': !tab.count,
						'sapMITBHorizontal': isHorizontalDesign,
						'sapMITBVertical': !isHorizontalDesign,
						'sapMITBAll': showAll,
						'sapMITBFilter': !showAll,
						'sapMITBDisabled': !!tab.disabled
					})
				}
			};

			headerItems.push(headerItem);
			navigationItems.push(headerItem);
		});

		this._headerItems = headerItems;
		this._navigationItems = navigationItems;
	}

	_prepareOverflowList() {

		if (!this.showOverflow) {
			return;
		}

		let tabs = this.getTabs();
		let listItems = [];

		tabs.forEach(tab => {

			let isIconColorRead = tab.iconColor === IconColor.Positive ||
				tab.iconColor === IconColor.Critical ||
				tab.iconColor === IconColor.Negative;

			let displayText = tab.text;
			if (tab.count) {
				displayText += " (" + tab.count + ")";
			}

			let overflowTab = {
				id: tab.id + '-overflow',

				isIconColorRead: isIconColorRead,
				displayText: displayText,

				text: tab.text,
				count: tab.count,
				icon: tab.icon,
				iconColor: tab.iconColor,

				key: tab._getUniqueKey(),

				_isInline: this._isInline,
				_isNoIcon: this._isNoIcon,
				_isNoText: this._isNoText
			};

			let listItem = {
				key: tab._id,
				type: tab.disabled ? ListItemType.Inactive : ListItemType.Active,
				selected: tab._isSelected,
				content: overflowTab,
				classes: 'sapMITBFilter' + tab.iconColor,
				innerClasses: tab.disabled ? ' sapMITBDisabled': ''
			};

			listItems.push(listItem);
		});

		this._overflowList.items = listItems;
	}

	_getScrollContainer() {
		let domRef = this.getDomRef();
		return domRef && domRef.querySelector('.sapMITBScrollContainer');
	}

	_openOverflowList() {
		let popover = this.getDomRef().querySelector('ui5-popover');
		let overflowButton = this.getDomRef().querySelector('ui5-button');

		popover.openBy(overflowButton);
	}

	_overflowItemSelected(event) {
		let pressedItem = event.detail.item;
		let tabs = this.getTabs();
		let selectedTab = tabs.filter(function (item) {
			return item._id === pressedItem.id;
		})[0];

		this.setSelectedTab(selectedTab);

		let popover = this.getDomRef().querySelector('ui5-popover');
		popover.close();

		let headerTab = this.getDomRef().querySelector('#' + pressedItem.id + '-header');
		if (headerTab) {
			headerTab.focus();
		}
	}

	_scrollIntoView() {
		if (!this._scrollable) {
			return;
		}

		let selectedTab = this.getSelectedTab();
		if (!selectedTab) {
			return;
		}

		let scrollContainer = this._getScrollContainer();
		let scrollContainerWidth = scrollContainer.offsetWidth;

		let tabContainerDomRef = this.getDomRef();
		let headerTabDomRef = tabContainerDomRef.querySelector('#' + selectedTab._id + '-header');

		let itemLeft = headerTabDomRef.offsetLeft - scrollContainer.scrollLeft;
		let itemRight = itemLeft + headerTabDomRef.offsetWidth;

		if (itemLeft < 0) {
			scrollContainer.scrollLeft += itemLeft;
		} else if (itemRight > scrollContainerWidth) {
			scrollContainer.scrollLeft += itemRight - scrollContainerWidth;
		}

		this._updateScrolling();
	}

	_updateScrolling() {
		let scrollContainer = this._getScrollContainer();
		if (!scrollContainer) {
			return;
		}

		let scrollContainerContent = scrollContainer.querySelector('.sapMITBHead');

		let scrollContainerWidth = scrollContainer.offsetWidth;
		let scrollContainerContentWidth = scrollContainerContent.offsetWidth;

		if (scrollContainerWidth >= scrollContainerContentWidth) {
			this._scrollable = false;
			this._scrollForward = false;
			this._scrollBack = false;
		} else {
			this._scrollable = true;
			this._scrollForward =  scrollContainer.scrollLeft + scrollContainerWidth < scrollContainerContentWidth;
			this._scrollBack = scrollContainer.scrollLeft > 0;
		}
	}

	_scrollLeft() {
		this._scrollEnablement.move(-scrollStep, 0).promise()
			.then(_ => this._updateScrolling());
	}

	_scrollRight() {
		this._scrollEnablement.move(scrollStep, 0).promise()
			.then(_ => this._updateScrolling());
	}

	_findSelectedTab(event) {
		let tabElement = TabContainer$2._findClosestTab(event.ui5target);
		if (!tabElement) {
			return;
		}

		let tabs = this.getTabs();
		return tabs.filter(function (item) {
			return item._id + '-header' === tabElement.id;
		})[0];
	}

	setSelectedTab(tab, userInteraction) {
		if (!tab || tab.disabled) {
			return;
		}

		let tabs = this.getTabs();

		if (!tabs.length) {
			return;
		}

		this._selectedContent = tab._state.content.length ? [tab] : this._state.content;

		if (this._selectedTab === tab) {
			if (userInteraction && !this.fixed) {
				this.collapsed = !this.collapsed;
			}
			return;
		}

		if (!this.fixed) {
			this.collapsed = false;
		}

		this._itemNavigation.currentIndex = tabs.indexOf(tab);

		this._selectedTab = tab;

		tabs.forEach(item => {
			item._isSelected = item === tab;
		});

		this.selectedKey = tab._getUniqueKey() || "";

		if (userInteraction) {
			this.fireEvent('itemSelect', {
				key: this.selectedKey
			});
		}

		this._scrollIntoView();
	}

	getSelectedTab() {
		return this._selectedTab;
	}

	getTabs() {
		let items = this.items || [];

		return items.filter(function (item) {
			return item instanceof Tab;
		});
	}

	onsapselect(event) {
		let selectedTab = this._findSelectedTab(event);
		this.setSelectedTab(selectedTab, true);

		event.preventDefault();
	}

	ontouchstart(event) {
		let touch = event.touches[0];

		this._touchStartX = touch.pageX;
		this._touchStartY = touch.pageY;

		this._touchDragX = 0;
		this._touchDragY = 0;
	}

	ontouchmove(event) {
		let touch = event.touches[0];

		this._touchDragX += Math.abs(this._touchStartX - touch.pageX);
		this._touchDragY += Math.abs(this._touchStartY - touch.pageY);

		this._touchStartX = touch.pageX;
		this._touchStartY = touch.pageY;
	}

	ontouchend(event) {

		if (this._touchDragX > maxActivateMove ||
			this._touchDragY > maxActivateMove ) {
			return;
		}

		if (event.which !== undefined && // Lumia phone
			event.which !== 0 && // MOBILE TAP
			event.which !== 1 /* LEFT MOUSE CLICK */ ) {
			return;
		}

		let selectedTab = this._findSelectedTab(event);
		this.setSelectedTab(selectedTab, true);
	}

	ontap(event) {
		let selectedTab = this._findSelectedTab(event);
		this.setSelectedTab(selectedTab, true);
	}

	static get calculateTemplateContext() {
		return TabContainerTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	TabContainer$2.define();
});

const html$m = index.html;

const TableColumnLitRenderer = {};

const block0$l = (context) => { return html$m`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}" style="${index.ifTruthy(context.styles.main)}" class="${index.ifTruthy(context.classes.main)}" >	${ context.ctr.header ? block1$e(context) : undefined }</div>`; };
const block1$e = (context) => { return html$m`<slot name="${index.ifTruthy(context.ctr.header._slot)}"></slot>	`; };
const renderMe$l = block0$l;

TableColumnLitRenderer.render = renderMe$l;

const metadata$p = {
	tag: "ui5-table-column",
	styleUrl: [
		"TableColumn.css"
	],
	slots: {
		/**
		 * Control to be displayed in the column header.
		 * @type {HTMLElement}
		 * @public
		 */
		header: {
			type: HTMLElement
		}
	},
	properties: /** @lends sap.ui.webcomponents.main.TableColumn.prototype */ {
		/**
		 * Defines the horizontal alignment of the column content.
		 * @type {TextAlign}
		 * @public
		 */
		hAlign: {
			type: TextAlign,
			defaultValue: TextAlign.Begin
		},
		/**
		 * Defines the minimum screen width to show or hide this <code>Column</code>. By default <code>Column</code> is always shown.
		 * The responsive behavior of the <codeTable</code> is determined by this property. As an example by setting <code>minWidth</code> property to "40em" shows this column on tablet (and desktop) but hides on mobile.
		 * Please also see <code>demandPopin</code> property for further responsive design options.
		 * @type {number}
		 * @public
		 */
		minWidth: {
			type: Integer,
			defaultValue: Infinity
		},
		/**
		 * The text for the column when it pop-in
		 * @type {string}
		 * @public
		 */
		popinText: {
			type: String,
			defaultValue: ""
		},
		/**
		 * According to your minWidth settings, the <code>Column</code> can be hidden in different screen sizes.
		 * Setting this property to true, shows this column as pop-in instead of hiding it.
		 * @type {boolean}
		 * @public
		 */
		demandPopin: {
			type: Boolean
		},
		/**
		 * Defines the width of the column. If you leave it empty then this column covers the remaining space.
		 * @type {CSSSize}
		 * @public
		 */
		width: {
			type: CSSSize,
			defaultValue: ""
		},
		_first: {
			type: Boolean,
			defaultValue: false
		},
		_last: {
			type: Boolean,
			defaultValue: false
		}
	}
};

/**
 * @class
 * Constructor for a new Column.
 *
 * The <codeColumn</code> allows to define column specific properties that will be applied when rendering the <code>Table</code>.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TableColumn
 * @public
 */
class TableColumn$2 extends WebComponent {

	static get metadata() {
		return metadata$p;
	}

	static get renderer() {
		return TableColumnLitRenderer;
	}

	static calculateTemplateContext(state) {
		let context = {
			ctr: state,
			classes: {
				main: {
					"sapWCTableColumn": true,
					"sapWCTableColumnFirst": state._first,
					"sapWCTableColumnLast": state._last
				}
			},
			styles: {
				main: {
				}
			}
		};

		// to be changed once we support RTL
		const textAlign = TemplateHelper.getTextAlign(state.hAlign, "LTR");

		if (textAlign) {
			context.styles.main["text-align"] = textAlign;
		}

		return context;
	}
}

Core$1.boot().then(_ => {
	TableColumn$2.define();
});

const html$n = index.html;
const repeat$n = index.repeat;

const TableCellLitRenderer = {};

const block0$m = (context) => { return html$n`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}">	${ repeat$n(context.ctr.content, undefined, (item, index$$1) => block1$f(item, index$$1, context)) }</div>`; };
const block1$f = (item, index$$1, context) => { return html$n`<slot name="${index.ifTruthy(item._slot)}"></slot>	`; };
const renderMe$m = block0$m;

TableCellLitRenderer.render = renderMe$m;

/**
 * @public
 */
const metadata$q = {
	tag: "ui5-table-cell",
	styleUrl: [
		"TableCell.css"
	],
	slots: {
		/**
		 * This property specifies the content of the <code>Cell</code>
		 * @type {HTMLElement}
		 * @public
		 */
		content: {
			type: HTMLElement,
			multiple: true
		}
	},
	properties: /** @lends sap.ui.webcomponents.main.TableCell.prototype */ {

		_firstInRow: {
			type: Boolean
		},
		_lastInRow: {
			type: Boolean
		},
		_hAlign: {
			type: TextAlign,
			defaultValue: TextAlign.Begin
		},
		_hasBorder: {
			type: Boolean,
			defaultValue: false
		}
	},
	events: {
	}
};

/**
 * @class
 *
 * Constructor for a new <code>Cell</code>.
 *
 * The <code>Cell</code> element defines the structure of the data in one <code>Cell</code> from the <code>Row</code>
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TableCell
 * @public
 */
class TableCell$2 extends WebComponent {

	static get metadata() {
		return metadata$q;
	}

	static get renderer() {
		return TableCellLitRenderer;
	}

	static calculateTemplateContext(state) {
		let context = {
			ctr: state,
			classes: {
				main: {
					"sapWCTableCell": true,
					"sapWCTableCellFirst": state._firstInRow,
					"sapWCTableCellLast": state._lastInRow,
					"sapWCTableCellWithBorder": state._hasBorder
				}
			},
			styles: {
				main: {
				}
			}
		};

		// to be changed once we support RTL
		const textAlign = TemplateHelper.getTextAlign(state._hAlign, "LTR");

		if (textAlign) {
			context.styles.main["text-align"] = textAlign;
		}

		return context;
	}
}

Core$1.boot().then(_ => {
	TableCell$2.define();
});

const html$o = index.html;
const repeat$o = index.repeat;

const TableRowLitRenderer = {};

const block0$n = (context) => { return html$o`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"	tabindex="${index.ifTruthy(context.ctr._tabIndex)}">	${ repeat$o(context.visibleCells, undefined, (item, index$$1) => block1$g(item, index$$1, context)) }${ repeat$o(context.popinCells, undefined, (item, index$$1) => block2$8(item, index$$1, context)) }</div>`; };
const block1$g = (item, index$$1, context) => { return html$o`<div class="${index.ifTruthy(context.classes.cellWrapper)}"><slot name="${index.ifTruthy(item._slot)}"></slot></div>	`; };
const block2$8 = (item, index$$1, context) => { return html$o`<div class="${index.ifTruthy(context.classes.popin)}"			style="grid-column-end: ${index.ifTruthy(context.visibleColumnLength)}" ><span class="${index.ifTruthy(context.classes.popinTitle)}">${index.ifTruthy(item.popinText)}</span><div class="wtf"><slot name="${index.ifTruthy(item.cell._slot)}"></slot></div></div>	`; };
const renderMe$n = block0$n;

TableRowLitRenderer.render = renderMe$n;

/**
 * @public
 */
const metadata$r = {
	tag: "ui5-table-row",
	styleUrl: [
		"TableRow.css"
	],
	slots: {
		/**
		 * Defines the cells of the <code>Row</code>
		 * @type {TableCell}
		 * @public
		 */
		cells: {
			type: TableCell$2,
			multiple: true
		}
	},
	properties: /** @lends sap.ui.webcomponents.main.TableRow.prototype */ {
		_columnsInfo: {
			type: Object,
			multiple: true
		},
		_tabIndex: {
			type: String,
			defaultValue: "-1"
		}
	},
	events: {
		_focused: {}
	}
};

/**
 * @class
 *
 * Constructor for a new Row.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TableRow
 * @public
 */
class TableRow$2 extends WebComponent {

	static get metadata() {
		return metadata$r;
	}

	static get renderer() {
		return TableRowLitRenderer;
	}

	static get calculateTemplateContext() {
		return (state) => {
			let context = {
				ctr: state,
				visibleCells: [],
				popinCells: [],
				columnInfo: state._columnsInfo,
				classes: {
					main: {
						"sapWCTableRow": true,
						"sapWCTableRowWithBorder": true
					},
					popin: {
						"sapWCTablePopinRow": true
					},
					popinTitle: {
						"sapWCTablePopinTitle": true
					},
					cellWrapper: {
						"sapMWCTableRowCellContainer": true
					}
				},
				styles: {
					main: {
						"grid-template-columns": ""
					},
					popin: {
						"grid-column-end": 6
					}
				}
			};

			this.calculateCellsStyles(context);

			context.visibleColumnLength = context.visibleCells.length + 1;


			return context;
		};
	}

	static calculateCellsStyles(context) {
		context.columnInfo.forEach((info, index) => {
			if (info.visible) {
				// width of cells
				context.styles.main["grid-template-columns"] += `minmax(0, ${info.width || "1fr"}) `;

				context.visibleCells.push(context.ctr.cells[index]);

				// align of cells
				context.ctr.cells[index]._hAlign = info.hAlign;

				context.ctr.cells[index]._firstInRow = (index === 0);
			} else if (info.demandPopin) {
				context.popinCells.push({
					cell: context.ctr.cells[index],
					popinText: info.popinText
				});
			}
		}, this);

		const lastVisibleCell = context.visibleCells[context.visibleCells.length - 1];

		lastVisibleCell && (lastVisibleCell._lastInRow = true);
	}

	onfocusin(event) {
		this.fireEvent('_focused', event);
	}
}

Core$1.boot().then(_ => {
	TableRow$2.define();
});

const html$p = index.html;
const repeat$p = index.repeat;

const TableLitRenderer = {};

const block0$o = (context) => { return html$p`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	style="display: grid; place-items: center;"><!-- columns --><div class="${index.ifTruthy(context.classes.main)}" style="${index.ifTruthy(context.styles.main)}">		${ repeat$p(context.visibleColumns, undefined, (item, index$$1) => block1$h(item, index$$1, context)) }</div><!-- rows -->	${ repeat$p(context.ctr.rows, undefined, (item, index$$1) => block2$9(item, index$$1, context)) }</div>`; };
const block1$h = (item, index$$1, context) => { return html$p`<div class="sapWCTableColumnWrapper"><slot name="${index.ifTruthy(item._slot)}"></slot></div>		`; };
const block2$9 = (item, index$$1, context) => { return html$p`<div style="width: 100%"		><slot name="${index.ifTruthy(item._slot)}"></slot></div>	`; };
const renderMe$o = block0$o;

TableLitRenderer.render = renderMe$o;

var belize$1 = "";

ShadowDOM.registerStyle("sap_belize", "Table.css", belize$1);

/**
 * @public
 */
const metadata$s = {
	tag: "ui5-table",
	styleUrl: [
		"Table.css"
	],
	slots: {
		rows: {
			type: TableRow$2,
			multiple: true
		},
		/**
		 * Defines configuration for the column of the <code>Table</code>
		 * @type {TableColumn}
		 * @public
		 */
		columns: {
			type: TableColumn$2,
			multiple: true,
			listenFor: { exclude: ["header"] }
		}
	},
	properties: /** @lends sap.ui.webcomponents.main.Table.prototype */ {
		/**
		 * <code>ColumnHeaders</code> remains fixed at the top of the page during vertical scrolling as long as the control is in the viewport.
		 *
		 * There is limited browser support.
		 * Browsers that do not support this feature are listed below:
		 * <ul>
		 * <li>IE</li>
		 * <li>Edge lower than version 41 (EdgeHTML 16)</li>
		 * <li>Firefox lower than version 59</li>
		 * </ul>
		 *
		 * There are also some known limitations with respect to the scrolling behavior. A few are given below:
		 * <ul>
		 * <li>If the control is placed in layout containers that have the <code>overflow: hidden</code> or <code>overflow: auto</code> style definition, this can
		 * prevent the sticky elements of the control from becoming fixed at the top of the viewport.</li>
		 * </ul>
		 *
		 * @type {boolean}
		 * @public
		 */
		stickyColumnHeader: {
			type: Boolean
		},
		/**
		 * Defines the rows of the <code>Table</code>
		 * @type {TableRow}
		 * @public
		 */
		_hiddenColumns: {
			type: Object,
			multiple: true
		}
	},
	events: {
	}
};

/**
 * @class
 * Constructor for a new <code>Table</code>.
 *
 * <code>Table</code> control provides a set of sophisticated and convenience functions for responsive table design.
 * To render the <code>Table</code> properly, the order of the <code>columns</code> should match with the order of the items <code>cells</code> in the <code>rows</code>.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Table
 * @public
 */
class Table$1 extends WebComponent {

	static get metadata() {
		return metadata$s;
	}

	static get renderer() {
		return TableLitRenderer;
	}

	static get calculateTemplateContext() {
		return (state) => {

			let context = {
				ctr: state,
				visibleColumns: [],
				classes: {
					main: {
						"sapWCTableHeader": true
					},
					columns: {
						"sapWCTableColumnWrapper": true
					}
				},
				styles: {
					main: {
						"grid-template-columns": "",
						"position": state.stickyColumnHeader ? "sticky" : "",
						"top": state.stickyColumnHeader ? "0px" : ""
					}
				}
			};

			context.ctr.columns.forEach((column, index) => {

				if (!context.ctr._hiddenColumns[index]) {
					context.visibleColumns.push(column);

					// width of columns
					context.styles.main["grid-template-columns"] += `minmax(0, ${column.width || "1fr"}) `;
				}

			}, this);

			return context;
		};
	}

	constructor(props) {
		super(props);

		this._itemNavigation = new ItemNavigation(this);

		this._itemNavigation.getItemsCallback = function () {
			return this.rows;
		}.bind(this);

		this._delegates.push(this._itemNavigation);

		this.fnOnRowFocused = this.onRowFocused.bind(this);
	}

	onBeforeRendering() {
		const columnSettings = this.getColumnPropagationSettings();

		this._itemNavigation.init();

		this.rows.forEach(row => {
			row._columnsInfo = columnSettings;
			row.removeEventListener('_focused', this.fnOnRowFocused);
			row.addEventListener('_focused', this.fnOnRowFocused);
		});
	}

	onEnterDOM() {
		ResizeHandler.register(this.getDomRef(), this.popinContent.bind(this));
	}

	onExitDOM() {
		ResizeHandler.deregister(this.getDomRef(), this.popinContent.bind(this));
	}

	onRowFocused(event) {
		this._itemNavigation.update(event.target);
	}

	popinContent(_event) {
		const clientRect = this.getDomRef().getBoundingClientRect();
		const tableWidth = clientRect.width;
		const hiddenColumns = [];
		const visibleColumnsIndexes = [];

		// store the hidden columns
		this.columns.forEach((column, index) => {
			if (tableWidth < column.minWidth && column.minWidth !== Infinity) {
				hiddenColumns[index] = {
					index: index,
					popinText: column.popinText,
					demandPopin: column.demandPopin
				};
			} else {
				visibleColumnsIndexes.push(index);
			}
		});

		if (visibleColumnsIndexes.length) {
			this.columns[visibleColumnsIndexes[0]]._first = true;
			this.columns[visibleColumnsIndexes[visibleColumnsIndexes.length - 1]]._last = true;
		}

		// invalidate only if hidden columns count has changed
		if (this._hiddenColumns.length !== hiddenColumns.length) {
			this._hiddenColumns = hiddenColumns;
		}
	}

	/**
	 * Gets settings to be propagated from columns to rows
	 *
	 * @returns {object}
	 * @memberof Table
	 */
	getColumnPropagationSettings() {
		return this.columns.map((column, index) => ({
			index: index,
			width: column.width,
			minWidth: column.minWidth,
			demandPopin: column.demandPopin,
			popinText: column.popinText,
			hAlign: column.hAlign,
			visible: !this._hiddenColumns[index]
		}), this);
	}
}

Core$1.boot().then(_ => {
	Table$1.define();
});

class TextAreaTemplateContext {

	static calculate(state) {

		const mainClasses = {
			"sapWCTextArea": true,
			"sapWCTextAreaGrowing": state.growing,
			"sapWCTextAreaNoMaxLines": !state.growingMaxLines,
			"sapWCTextAreaWithCounter": state.showExceededText
		};

		const innerClasses = {
			"sapWCTextAreaInner": true,
			"sapCustomTextAreaStateInner": (state._exceededTextProps.leftCharactersCount < 0),
			"sapCustomTextAreaWarningInner": (state._exceededTextProps.leftCharactersCount < 0)
		};

		const context = {
			ctr: state,
			wrapping: state.wrapping === "None" ? undefined : state.wrapping,
			cols: state.cols || undefined,
			maxLength: state._exceededTextProps.calcedMaxLength,
			exceededText: state._exceededTextProps.exceededText,
			textTokens: state._mirrorText,
			tabIndex: state.disabled ? undefined : "0",
			classes: {
				main: mainClasses,
				inner: innerClasses,
				exceededText: {
					"sapWCTextAreaExceededText": true
				},
				mirror: {
					"sapWCTextAreaMirror": true
				}
			},
			styles: {
				mirror: { "max-height": (state._maxHeight) },
				main: { "width": "100%", "height": "100%" },
				inner: { "height": (state.showExceededText ? "calc(100% - 26px)" : "100%"), "max-height": (state._maxHeight) }
			},
			ariaInvalid: state.valueState === 'Error' ? 'true' : undefined
		};

		return context;
	}
}

var ar$1 = "3287ee20425d4b32.properties";

var bg$1 = "414f0bcd0be07b6e.properties";

var ca$1 = "262e2a7ebc17a052.properties";

var cs$1 = "3a71a693b977bb42.properties";

var da$1 = "deb1415f863a5702.properties";

var de$1 = "41c6c15b30e386ec.properties";

var el$1 = "355e1387578a5c37.properties";

var en_US_sappsd = "78aeee33e88ab846.properties";

var en_US_saptrc = "d4e7bfbe54f2fe04.properties";

var en$1 = "d47729b6ae8e1dd3.properties";

var es$1 = "41b6fdb3ee522c93.properties";

var et$1 = "5a8b8eaab6f8d158.properties";

var fi$1 = "c9e2b66d01436490.properties";

var fr$1 = "6468637d5ca298e4.properties";

var hi$1 = "f307f84ca75e3a6a.properties";

var hr$1 = "e3955517bac7d3ab.properties";

var hu$1 = "a539aaac0421d24d.properties";

var it$1 = "ecf3eb902f0d5823.properties";

var iw = "227d65d8e40ba4e1.properties";

var ja$1 = "85a0197b8a17c5ea.properties";

var kk$1 = "68550b31559e17d8.properties";

var ko$1 = "48e758c630067073.properties";

var lt$1 = "8a24f1210176baa7.properties";

var lv$1 = "bb8756d9ebb15255.properties";

var ms$1 = "62a24e8583ce25e7.properties";

var nl$1 = "3eb9858ef33db10b.properties";

var no = "1b21104ecdb39e08.properties";

var pl$1 = "37be130851ccb772.properties";

var pt$1 = "d2def3dec51c0870.properties";

var ro$1 = "18d5e1e381fd855e.properties";

var ru$1 = "e0a59a871a57442b.properties";

var sh = "c67e08c5d7b80438.properties";

var sk$1 = "c90bc7150fe6aee3.properties";

var sl$1 = "f5f7e1bef1dac965.properties";

var sv$1 = "9aa45d931e6e7ad1.properties";

var th$1 = "5a7f7ba43731e9b0.properties";

var tr$1 = "93610c807c04d99d.properties";

var uk$1 = "95df283506ff9db3.properties";

var vi$1 = "6b1d4c1830fbf5fe.properties";

var zh_CN$1 = "8f74205d65182d2d.properties";

var zh_TW$1 = "2b55d021127bef46.properties";

const bundleURLs = new Map();

const fetchResourceBundle = async (packageId) => {
	const assetPath = Core.getAssetPath();
	const locale = Core.getConfiguration().getLocale();
	const bundlePerPackage = bundleURLs.get(packageId);

	// fallback to en if config is not found
	const bundleURL = bundlePerPackage[locale] || bundlePerPackage["en"];

	const response = await fetch(assetPath + bundleURL);
	const data = await response.text();

	registerModuleContent(`${packageId}_${locale}.properties`, data);
};

const registerMessageBundles = (packageId, bundlesMap) => {
	bundleURLs.set(packageId, bundlesMap);
};

const getResourceBundle = (library) => {
	const locale = Core.getConfiguration().getLocale();

	return ResourceBundle.create({
		url: `${library}_${locale}.properties`,
		locale : locale,
	});
};

const bundleMap = {
	ar: ar$1,
	bg: bg$1,
	ca: ca$1,
	cs: cs$1,
	da: da$1,
	de: de$1,
	el: el$1,
	en_US_sappsd,
	en_US_saptrc,
	en: en$1,
	es: es$1,
	et: et$1,
	fi: fi$1,
	fr: fr$1,
	hi: hi$1,
	hr: hr$1,
	hu: hu$1,
	it: it$1,
	iw,
	ja: ja$1,
	kk: kk$1,
	ko: ko$1,
	lt: lt$1,
	lv: lv$1,
	ms: ms$1,
	nl: nl$1,
	no,
	pl: pl$1,
	pt: pt$1,
	ro: ro$1,
	ru: ru$1,
	sh,
	sk: sk$1,
	sl: sl$1,
	sv: sv$1,
	th: th$1,
	tr: tr$1,
	uk: uk$1,
	vi: vi$1,
	zh_CN: zh_CN$1,
	zh_TW: zh_TW$1
};

registerMessageBundles("@openui5/sap.ui.webcomponents.main", bundleMap);

const WrappingTypes = {
	/**
	 * The standard browser behavior is considered for wrapping.
	 * @public
	 */
	None: "None",

	/**
	 * The text is actually on the same line but displayed within several lines.
	 * @public
	 */
	Soft: "Soft",

	/**
	 * Inserts actual line breaks in the text at the wrap point.
	 * @public
	 */
	Hard: "Hard"
};

class Wrapping extends DataType {

	static isValid(value) {
		return !!WrappingTypes[value];
	}
}

Wrapping.generataTypeAcessors(WrappingTypes);

const html$q = index.html;
const repeat$q = index.repeat;

const TextAreaLitRenderer = {};

const block0$p = (context) => { return html$q`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"	aria-invalid="${index.ifTruthy(context.ariaInvalid)}"	aria-labelledBy="${index.ifTruthy(context.ariaLabelledBy)}">	${ context.ctr.growing ? block1$i(context) : undefined }<textarea		id="${index.ifTruthy(context.ctr._id)}-inner"		class="${index.ifTruthy(context.classes.inner)}"		style="${index.ifTruthy(context.styles.inner)}"		placeholder="${index.ifTruthy(context.ctr.placeholder)}"		?disabled="${index.ifTruthy(context.ctr.disabled)}"		rows="${index.ifTruthy(context.ctr.rows)}"		cols="${index.ifTruthy(context.cols)}"		wrap="${index.ifTruthy(context.wrapping)}"		maxlength="${index.ifTruthy(context.maxLength)}"		.value="${index.ifTruthy(context.ctr.value)}"		data-sap-focus-ref></textarea>	${ context.ctr.showExceededText ? block4$5(context) : undefined }</div>`; };
const block1$i = (context) => { return html$q`<div id="${index.ifTruthy(context.ctr._id)}-mirror" style="${index.ifTruthy(context.styles.mirror)}" class="${index.ifTruthy(context.classes.mirror)}" aria-hidden="true">			${ repeat$q(context.textTokens, undefined, (item, index$$1) => block2$a(item, index$$1, context)) }</div>	`; };
const block2$a = (item, index$$1, context) => { return html$q`${index.ifTruthy(item.text)}${ !item.last ? block3$7(item, index$$1, context) : undefined }`; };
const block3$7 = (item, index$$1, context) => { return html$q`<br/>				`; };
const block4$5 = (context) => { return html$q`<span class="${index.ifTruthy(context.classes.exceededText)}">${index.ifTruthy(context.exceededText)}</span>	`; };
const renderMe$p = block0$p;

TextAreaLitRenderer.render = renderMe$p;

/**
 * @public
 */
const metadata$t = {
	tag: "ui5-textarea",
	styleUrl: [
		"TextArea.css"
	],
	properties: /** @lends sap.ui.webcomponents.main.TextArea.prototype */ {
		/**
		 * Defines the value of the control.
		 *
		 * @type {string}
		 * @defaultvalue ""
		 * @public
		 */
		value: {
			defaultValue: "",
			type: String
		},

		/**
		 * Indicates whether the user can interact with the control or not.
		 * <b>Note:</b> Disabled controls cannot be focused and they are out of the tab-chain.
		 * @type {boolean}
		 * @defaultvalue false
		 * @public
		 */
		disabled: {
			type: Boolean
		},

		/**
		 * Defines a short hint intended to aid the user with data entry when the control has no value.
		 * @type {string}
		 * @defaultvalue ""
		 * @public
		 */
		placeholder: {
			defaultValue: "",
			type: String
		},
		/**
		 * Defines the number of visible text lines for the control.
		 * If growing is enabled, the property defined the minimum rows to be shown in the textarea.
		 * <b>Note:</b> The <code>height</code> css property wins over the <code>rows</code> property, if both are set.
		 * @type {number}
		 * @defaultvalue 0
		 * @public
		 */
		rows: {
			type: Integer,
			defaultValue: 0
		},

		/**
		 * Defines the maximum number of characters that the <code>value</code> can be.
		 * @type {number}
		 * @public
		 */
		maxLength: {
			type: Integer,
			defaultValue: null
		},

		/**
		 * Determines whether the characters, exceeding the maximum allowed character count, are visible in the <code>TextArea</code>.
		 *
		 * If set to <code>false</code> the user is not allowed to enter more characters than what is set in the <code>maxLength</code> property.
		 * If set to <code>true</code> the characters exceeding the <code>maxLength</code> value are selected on paste and the counter below
		 * the <code>TextArea</code> displays their number.
		 * @type {boolean}
		 * @defaultvalue false
		 * @public
		 */
		showExceededText: {
			type: Boolean,
			defaultValue: false
		},

		/**
		 * Indicates how the control wraps the text, e.g. <code>Soft</code>, <code>Hard</code>, <code>None</code>.
		 * @type {boolean}
		 * @defaultvalue "None"
		 * @public
		 */
		wrapping: {
			type: Wrapping,
			defaultValue: Wrapping.None
		},

		/**
		 * Indicates the ability of the control to automatically grow and shrink dynamically with its content.
		 * <b>Note:</b> The <code>height</code> css property is ignored, if this property set to <code>true</code>.
		 * @type {boolean}
		 * @defaultvalue false
		 * @public
		 */
		growing: {
			type: Boolean,
			defaultValue: false
		},

		/**
		 * Defines the maximum number of lines that the control can grow.
		 * @type {number}
		 * @defaultvalue 0
		 * @public
		 */
		growingMaxLines: {
			type: Integer,
			defaultValue: 0
		},

		_height: {
			type: CSSSize,
			defaultValue: null
		},

		_exceededTextProps: {
			type: Object,
			defaultValue: null
		},

		_mirrorText: {
			type: Object,
			multiple: true,
			defaultValue: ""
		},
		_maxHeight: {
			type: Number,
			defaultValue: ""
		}
	},
	events: /** @lends sap.ui.webcomponents.main.TextArea.prototype */ {
		/**
		 * Is fired when the text in the <code>TextArea</code> has changed and the focus leaves the
		 * <code>TextArea</code> or the enter key is pressed.
		 * @event
		 * @param {string} value The value of the <code>TextArea</code>.
		 * @public
		 */
		change: {
			value: { type: String }
		}
	}
};

/**
 * @class
 *
 * A control that is used for multi-line input of text.
 *
 * <h3>Overview</h3>
 * The <code>TextArea</code> is used to enter multiple lines of text. When empty, it can hold a placeholder similar to an {@link Input input}.
 * You can define the rows of the <code>TextArea</code> and also determine specific behavior when handling long texts.
 *
 * <h3>Structure</h3>
 * Parameters that determine the size:
 * <ul>
 * <li><code>rows</code> - Number of visible text lines</li>
 * </ul>
 * Parameters that determine the behavior:
 * <ul>
 * <li><code>growing</code> - The <code>TextArea</code> adjusts its size based on the content</li>
 * <li><code>growingMaxLines</code> - Threshold for the <code>growing</code> property (shouldn't exceed the screen size)</li>
 * <li><code>maxLength</code> - Maximum number of characters that can be entered in a <code>TextArea</code></li>
 * <li><code>wrapping</code> - The way the entered text is wrapped by the control</li>
 * <li><code>showExceededText</code> - Determines how text beyond the <code>maxLength</code> length is handled</li>
 * </ul>
 * <h3>Usage</h3>
 * <h4>When to use</h4>
 * <ul>
 * <li>You want to enter multiple lines of text.</li>
 * <li>Always provide labels for a <code>TextArea</code>.</li>
 * <li>A placeholder does not substitute a label.</li>
 * </ul>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.TextArea
 * @public
 */
class TextArea$2 extends WebComponent {

	static get metadata() {
		return metadata$t;
	}

	static get renderer() {
		return TextAreaLitRenderer;
	}

	static get calculateTemplateContext() {
		return TextAreaTemplateContext.calculate;
	}

	constructor(props) {
		super(props);

		this.resourceBundle = getResourceBundle("@openui5/sap.ui.webcomponents.main");
	}

	onBeforeRendering() {

		this._exceededTextProps = this._calcExceededText();
		this._mirrorText = this._tokenizeText(this.value);

		if (this.growingMaxLines) {
			// this should be complex calc between line height and paddings - TODO: make it stable
			this._maxHeight = ((this.growingMaxLines * 1.4 * 14) + 9) + "px";
		}
	}

	getInputDomRef() {
		return this.getDomRef().querySelector("textarea");
	}

	getInputValue() {
		let inputDOM = this.getDomRef();

		if (inputDOM) {
			return this.getInputDomRef().value;
		}

		return "";
	}

	oninput() {
		let inputValue = this.getInputValue();

		this.value = inputValue;
	}

	onfocusout() {
		this.fireEvent("change", { value: this.value });
	}

	_tokenizeText(value) {
		let tokenizedText = value.replace(/&/gm, '&amp;').replace(/"/gm, '&quot;').replace(/'/gm, '&#39;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;').split('\n');

		if (tokenizedText.length < this.rows) {
			return this._mapTokenizedTextToObject([...tokenizedText, ...Array(this.rows - tokenizedText.length).fill("")]);
		}

		return this._mapTokenizedTextToObject(tokenizedText);
	}

	_mapTokenizedTextToObject(tokenizedText) {
		return tokenizedText.map((token, index) => {
			return {
				text: token,
				last: index === (tokenizedText.length - 1)
			};
		});
	}

	_calcExceededText() {
		let calcedMaxLength, exceededText, leftCharactersCount;

		if (this.showExceededText) {
			const maxLength = this.maxLength || 0;

			if (maxLength) {
				leftCharactersCount = maxLength - this.value.length;

				if (leftCharactersCount >= 0) {
					exceededText = this.resourceBundle.getText("TEXTAREA_CHARACTERS_LEFT", [leftCharactersCount]);
				} else {
					exceededText = this.resourceBundle.getText("TEXTAREA_CHARACTERS_EXCEEDED", [Math.abs(leftCharactersCount)]);

				}
			}
		} else {
			calcedMaxLength = this.maxLength;
		}

		return {
			exceededText, leftCharactersCount, calcedMaxLength
		};
	}
}

Core$1.boot().then(async () => {
	await fetchResourceBundle("@openui5/sap.ui.webcomponents.main");
	TextArea$2.define();
});

const TitleLevels = {
	H1: "H1",
	H2: "H2",
	H3: "H3",
	H4: "H4",
	H5: "H5",
	H6: "H6"
};

class TitleLevel extends DataType {

	static isValid(value) {
		return !!TitleLevels[value];
	}
}

TitleLevel.generataTypeAcessors(TitleLevels);

const html$r = index.html;

const TitleLitRenderer = {};

const block0$q = (context) => { return html$r`<h2		id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	class="${index.ifTruthy(context.classes.main)}"	style="${index.ifTruthy(context.styles.main)}"	title="${index.ifTruthy(context.ctr.tooltip)}"	role="heading"><span id="${index.ifTruthy(context.ctr._id)}-inner">${index.ifTruthy(context.ctr._nodeText)}</span></h2>`; };
const renderMe$q = block0$q;

TitleLitRenderer.render = renderMe$q;

/**
 * @public
 */
const metadata$u = {
	tag: "ui5-title",
	styleUrl: [
		"Title.css"
	],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.Title.prototype */ {
		tooltip: {
			type : String,
			defaultValue : null
		},
		wrap: {
			type : Boolean
		},
		level: {
			type: TitleLevel,
			defaultValue : TitleLevel.H2
		}
		// textAlign : {type : "sap.ui.core.TextAlign", group : "Appearance", defaultValue : TextAlign.Initial},
	}
};

/**
 * @class
 * A constructor for <code>Title</code>
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Title
 * @public
 */
class Title$2 extends WebComponent {

	static get metadata() {
		return metadata$u;
	}

	static get renderer() {
		return TitleLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	static calculateTemplateContext(state) {
		let context = {
			tag: (state.level === TitleLevel.Auto ? 'div' : state.level).toLowerCase(),
			ctr: state,
			classes: {
				main: {
					"sapMTitle": true,
					"sapMTitleWrap": state.wrap,
					"sapUiSelectable": true,
					["sapMTitleStyle" + state.level]: true
				}
			},
			styles: {
				main: {}
			}
		};

		return context;
	}

}

Core$1.boot().then(_ => {
	Title$2.define();
});

class ToggleButtonTemplateContext {

	static calculate(state) {
		const calculatedState = ButtonTemplateContext.calculate(state);

		calculatedState.classes.main["sapMToggleBtnPressed"] = state.pressed;
		calculatedState.classes.main["sapMBtnActive"] = false;
		calculatedState.pressed = state.pressed ? "true" : undefined;

		return calculatedState;
	}
}

const html$s = index.html;

const ToggleButtonLitRenderer = {};

const block0$r = (context) => { return html$s`<button 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
		class="${index.ifTruthy(context.classes.main)}"
		style="${index.ifTruthy(context.styles.main)}"
		disabled="${index.ifTruthy(context.ctr.disabled)}"
		aria-disabled="${index.ifTruthy(context.ariaDisabled)}"
		title="${index.ifTruthy(context.ctr.tooltip)}"
		tabindex="${index.ifTruthy(context.tabindex)}"
		
	aria-pressed="${index.ifTruthy(context.pressed)}"

	>
		${ context.ctr._iconSettings ? block1$j(context) : undefined }${ context.ctr._nodeText ? block2$b(context) : undefined }</button>

`; };
const block1$j = (context) => { return html$s`<ui5-icon
				class="${index.ifTruthy(context.classes.icon)}"
				src="${index.ifTruthy(context.ctr._iconSettings.src)}"
			></ui5-icon>
		`; };
const block2$b = (context) => { return html$s`<span id="${index.ifTruthy(context.ctr._id)}-content" dir="${index.ifTruthy(context.dir)}" class="${index.ifTruthy(context.classes.text)}"><bdi>${index.ifTruthy(context.ctr._nodeText)}</bdi></span>
		`; };
const renderMe$r = block0$r;

ToggleButtonLitRenderer.render = renderMe$r;

/**
 * @public
 */
const metadata$v = {
	tag: "ui5-toggle-button",
	styleUrl: [
		"Button.css",
		"ToggleButton.css"
	],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.ToggleButton.prototype */ {
		/**
		 * Specifies if the button is currently pressed.
		 * @type {boolean}
		 * @public
		 */
		pressed: {
			"type": Boolean
		}
	}
};

/**
 *
 * @class
 * An enhanced {@link Button} that can be toggled between pressed and normal state.
 *
 * Clicking or tapping a <code>ToggleButton</code> changes its state to <code>pressed</code>. The button returns to
 * its initial state when the user clicks or taps it again.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.ToggleButton
 * @public
 */
class ToggleButton$2 extends Button$1 {

	static get metadata() {
		return metadata$v;
	}

	static get renderer() {
		return ToggleButtonLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	ontap() {
		if (!this.disabled) {
			this.pressed = !this.pressed;
			this.fireEvent("press", {pressed: this.pressed});
		}
	}

	onkeyup(event) {

		if (event.which === mKeyCodes.SPACE || event.which === mKeyCodes.ENTER && !this.disabled) {
		this.pressed = !this.pressed;
		}
	}

	static get calculateTemplateContext() {
		return ToggleButtonTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	ToggleButton$2.define();
});

const ToolbarDesignTypes = {
	/**
	 * The toolbar can be inserted into other controls and if the design is "Auto" then it inherits the design from parent control.
	 */
	Auto: "Auto",

	/**
	 * The toolbar and its content will be displayed transparent.
	 */
	Transparent: "Transparent",

	/**
	 * The toolbar appears smaller than the regular size to show information(e.g: text, icon).
	 */
	Info: "Info",

	/**
	 * The toolbar has a solid background. Its content will be rendered in a standard way.
	 */
	Solid: "Solid"
};

class ToolbarDesign extends DataType {
	static isValid(value) {
		return !!ToolbarDesignTypes[value];
	}
}

ToolbarDesign.generataTypeAcessors(ToolbarDesignTypes);

const ToolbarStyleTypes = {
	/**
	 * Default visual style dependent on the used theme.
	 */
	Standard: "Standard",

	/**
	 * Simplified visual style dependent on the used theme.
	 */
	Clear: "Clear"
};

class ToolbarStyle extends DataType {
	static isValid(value) {
		return !!ToolbarStyleTypes[value];
	}
}

ToolbarStyle.generataTypeAcessors(ToolbarStyleTypes);

const html$t = index.html;
const repeat$t = index.repeat;

const ToolbarLitRenderer = {};

const block0$s = (context) => { return html$t`<div 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"
	class="${index.ifTruthy(context.classes.main)}"
	tabindex="${index.ifTruthy(context._tabIndex)}"
>
	${ repeat$t(context.content, undefined, (item, index$$1) => block1$k(item, index$$1, context)) }</div>`; };
const block1$k = (item, index$$1, context) => { return html$t`<span class="${index.ifTruthy(item.classes)}"><slot name="${index.ifTruthy(item.child._slot)}"></slot></span>
	`; };
const renderMe$s = block0$s;

ToolbarLitRenderer.render = renderMe$s;

/**
 * @public
 */
const metadata$w = {
	tag: "ui5-toolbar-spacer",
	noShadowDOM: true,
	properties: /** @lends  sap.ui.webcomponents.main.ToolbarSpacer.prototype */ {

	}
};

/**
 * @class
 * Adds horizontal space between the items used within a {@link Toolbar}.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.ToolbarSpacer
 * @public
 */
class ToolbarSpacer extends WebComponent {

	static get metadata() {
		return metadata$w;
	}
}

Core$1.boot().then(_ => {
	ToolbarSpacer.define();
});

class ToolbarTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			content: ToolbarTemplateContext.buildContent(state),
			classes: {
				main: {
					sapMIBar: true,
					sapMTB: true,
					sapMTBNewFlex: true,
					[`sapMTB${state.toolbarStyle}`]: true,
					[`sapMTB-${state.design}-CTX`]: true,
					sapMTBActive: state.active,
					sapMTBInactive: !state.active
				}
			},
			styles: {
			}
		};

		context._tabIndex = state.active ? "0" : undefined;

		return context;
	}

	static buildContent(state) {
		const content = (state.content || []).map(child => {
			let classes = "sapMBarChild";

			if (child instanceof ToolbarSpacer) {
				classes += " sapMTBSpacer sapMTBSpacerFlex";
			} else {
				classes += " sapMTBShrinkItem";
			}

			return {
				id: child.id,
				classes: classes,
				child: child
			};
		});
		return content;
	}
}

/**
 * @public
 */
const metadata$x = {
	tag: "ui5-toolbar",
	styleUrl: [
		"Toolbar.css",
		"ToolbarSpacer.css"
	],
	defaultSlot: "content",
	slots: {
		/**
		 * The content of the <code>Toolbar</code>.
		 * @type {HTMLElement}
		 * @public
		 */
		content: {
			type: HTMLElement,
			multiple: true
		}
	},
	properties: /** @lends  sap.ui.webcomponents.main.Toolbar.prototype */ {
		/**
		 * Defines the toolbar design.
		 *
		 * <b>Note:</b> Design settings are theme-dependent. They also determine the default height of the toolbar.
		 * @type {ToolbarDesign}
		 * @public
		 */
		design: {
			type: ToolbarDesign,
			defaultValue: ToolbarDesign.Auto
		},
		/**
		 * Defines the visual style of the <code>Toolbar</code>.
		 *
		 * <b>Note:</b> The visual styles are theme-dependent.
		 * @type {ToolbarStyle}
		 * @public
		 */
		toolbarStyle: {
			type: ToolbarStyle,
			defaultValue: ToolbarStyle.Standard
		},
		/**
		 * Indicates that the whole <code>Toolbar</code> is clickable. The Press event is fired only if Active is set to true.
		 * Note: This property should be used when there are no interactive controls inside the <code>Toolbar</code> and the <code>Toolbar</code> itself is meant to be interactive.
		 * @type {boolean}
		 * @public
		 */
		active: {
			type: Boolean
		}
	}
};

/**
 *
 * @class
 * Constructor for a new <code>Toolbar</code>.
 *
 * Horizontal container most commonly used to display buttons, labels, selects and various
 * other input controls.
 *
 * <h3>Usage</h3>
 *
 * To add horizontal space between the <code>Toolbar</code> items, use the {@link ToolbarSpacer}.
 * You can define the width of the horizontal space or make it flexible to cover the remaining space
 * between the <code>Toolbar</code> items (for example, to to push an item to the edge of the <code>Toolbar</code>.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.Toolbar
 * @public
 */
class Toolbar$2 extends WebComponent {

	static get metadata() {
		return metadata$x;
	}

	static get renderer() {
		return ToolbarLitRenderer;
	}

	static get calculateTemplateContext() {
		return ToolbarTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	Toolbar$2.define();
});

class ListItemBase extends ControlType {}

class ListItem extends ListItemBase {}

class ListItemBaseTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			classes: {
				main: ListItemBaseTemplateContext.getMainClasses(state),
				inner: ListItemBaseTemplateContext.getInnerClasses(state)
			},
			styles: {
				main: {}
			}
		};

		return context;
	}

	static getMainClasses(state) {
		const isDesktop = Device.system.desktop;

		return {
			"sapMLIBBorder": !state.hideBorder,
			"sapMLIB": true,
			"sapMLIB-CTX": true,
			"sapMLIBShowSeparator": true,
			"sapMLIBFocusable": isDesktop,
			[`sapMLIB${state._background}`]: !!state._background
		};
	}

	static getInnerClasses() {
		return { "sapMLIBContent": true };
	}
}

/**
 * @public
 */
const metadata$y = {
	'abstract': true,
	properties: /** @lends  sap.ui.webcomponents.main.ListItemBase.prototype */  {

		/**
		 * Specifies if list item border is hidden.
		 * @type {string}
		 * @public
		 */
		hideBorder: {
			type: Boolean
		},

		_background: {
			type: String
		},

		_tabIndex: {
			type: String,
			defaultValue: "-1"
		}
	},
	events: {
		_focused: {},
		_focusForward: {}
	}
};

/**
 * A class to serve as a foundation
 * for the <code>ListItem</code> and <code>GroupHeaderListItem</code> classes.
 *
 * @abstract
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.ListItemBase
 * @public
 */
class ListItemBase$3 extends WebComponent {

	static get metadata() {
		return metadata$y;
	}

	constructor(state) {
		super(state);
	}

	static get calculateTemplateContext() {
		return ListItemBaseTemplateContext.calculate;
	}

	onfocusin(event) {
		this.fireEvent('_focused', event);
	}

	onsaptabnext(event) {
		const target = event.target.shadowRoot.activeElement;

		if (this.shouldForwardTabAfter(target)) {
			this.fireEvent('_forwardAfter', { item: target });
		}
	}

	onsaptabprevious(event) {
		const target = event.target.shadowRoot.activeElement;

		if (this.shouldForwardTabBefore(target)) {
			let eventData = event;
			eventData.item = target;
			this.fireEvent('_forwardBefore', eventData);
		}
	}

	/*
	* Determines if th current list item either has no tabbable content or
	* [TAB] is performed onto the last tabbale content item.
	*/
	shouldForwardTabAfter(target) {
		const aContent = FocusHelper.getTabbableContent(this.getDomRef());

		if (target.getFocusDomRef) {
			target = target.getFocusDomRef();
		}

		return !aContent.length || (aContent[aContent.length - 1] === target);
	}

	/*
	* Determines if the current list item is target of [SHIFT+TAB].
	*/
	shouldForwardTabBefore(target) {
		return this.getDomRef() === target;
	}
}

/**
 * @public
 */
const metadata$z = {
	T: ListItem,
	abstract: true,
	properties: /** @lends  sap.ui.webcomponents.main.ListItem.prototype */ {

		/**
		 * Defines the selected state of the <code>ListItem</code>.
		 * @type {boolean}
		 * @public
		 */
		selected: {
			type: Boolean
		},

		/**
		 * Defines the visual indication and behavior of the list items.
		 * Available options are <code>Active</code> and <code>Inactive</code>.
		 * @type {string}
		 * @public
		*/
		type: {
			type: ListItemType,
			defaultValue: ListItemType.Inactive
		},

		_active: {
			type: Boolean
		},

		_mode: {
			type: ListMode,
			defaultValue: ListMode.None
		},

		_selectionControl: {
			type: Object
		}
	},
	events: {
		_press: {},
		_detailPress: {},
		_focused: {},
		_focusForward: {}
	}
};

/**
 * @class
 * A class to serve as a base
 * for the <code>StandardListItem</code> and <code>CustomListItem</code> classes.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.ListItem
 * @public
 */
class ListItem$3 extends ListItemBase$3 {

	static get metadata() {
		return metadata$z;
	}

	constructor(state) {
		super(state);

		// TODO: discuss how to pass methods to the template
		// as the template context does not contain web component reference
		this._state.fnOnDelete = this.onDelete.bind(this);
	}

	onBeforeRendering() {}

	onkeydown(event) {
		const spaceUsed = event.which === mKeyCodes.SPACE;
		const enterUsed = event.which === mKeyCodes.ENTER;
		const itemActive = this.type === ListItemType.Active;

		if (spaceUsed) {
			event.preventDefault();
		}

		if ((spaceUsed || enterUsed) && itemActive) {
			this.activate();
		}

		if (enterUsed) {
			this.fireEvent('_press', { item: this, selected: this.selected });
		}
	}

	onkeyup(event) {
		const spaceUsed = event.which === mKeyCodes.SPACE;
		const enterUsed = event.which === mKeyCodes.ENTER;

		if (spaceUsed || enterUsed) {
			this.deactivate();
		}

		if (spaceUsed) {
			this.fireEvent('_press', { item: this, selected: this.selected });
		}
	}

	ondown() {
		this.activate();
	}

	onup() {
		this.deactivate();
	}

	ontap() {
		this.fireEvent('_press', { item: this, selected: this.selected });
	}

	onfocusout() {
		this.deactivate();
	}

	onmouseout() {
		this.deactivate();
	}

	activate() {
		if (this.type === ListItemType.Active) {
			this._active = true;
		}
	}

	deactivate() {
		this._active = false;
	}

	onDelete(event) {
		this.fireEvent("_selectionRequested", { item: this, selected: event.selected });
	}
}

class StandardListItem extends ListItem {}

const html$u = index.html;

const StandardListItemLitRenderer = {};

const block0$t = (context) => { return html$u`<li 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	tabindex="${index.ifTruthy(context.ctr._tabIndex)}"	style="${index.ifTruthy(context.styles.main)}"	class="${index.ifTruthy(context.classes.main)}">		${ context.placeSelectionControlBefore ? block1$l(context) : undefined }<div id="${index.ifTruthy(context.ctr._id)}-content" class="${index.ifTruthy(context.classes.inner)}">			${ context.ctr.imageSrc ? block5$5(context) : undefined }<span class="sapMSLITitle">${index.ifTruthy(context.ctr._nodeText)}</span>
</div>		${ context.ctr.iconSrc ? block6$2(context) : undefined }${ context.placeSelectionControlAfter ? block7$2(context) : undefined }</li>`; };
const block1$l = (context) => { return html$u`${ context.modeSingleSelect ? block2$c(context) : undefined }${ context.modeMultiSelect ? block3$8(context) : undefined }${ context.modeDelete ? block4$6(context) : undefined }`; };
const block2$c = (context) => { return html$u`<ui5-radiobutton				id="${index.ifTruthy(context.ctr._id)}-singleSelectionControl"				class="radioButtonInListItem"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-radiobutton>	`; };
const block3$8 = (context) => { return html$u`<ui5-checkbox				id="${index.ifTruthy(context.ctr._id)}-multiSelectionControl"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-checkbox>	`; };
const block4$6 = (context) => { return html$u`<ui5-button				id="${index.ifTruthy(context.ctr._id)}-deleteSelectionControl"				type="Transparent"				icon="sap-icon://delete"				@press="${index.ifTruthy(context.ctr.fnOnDelete)}"		></ui5-button>	`; };
const block5$5 = (context) => { return html$u`<img id="${index.ifTruthy(context.ctr._id)}-img" src="${index.ifTruthy(context.ctr.imageSrc)}" class="${index.ifTruthy(context.classes.image)}">
	`; };
const block6$2 = (context) => { return html$u`<ui5-icon src="${index.ifTruthy(context.ctr._iconControl.src)}" class="${index.ifTruthy(context.ctr._iconControl._customClasses)}"></ui5-icon>
	`; };
const block7$2 = (context) => { return html$u`${ context.modeSingleSelect ? block8$2(context) : undefined }${ context.modeMultiSelect ? block9$1(context) : undefined }${ context.modeDelete ? block10$1(context) : undefined }`; };
const block8$2 = (context) => { return html$u`<ui5-radiobutton				id="${index.ifTruthy(context.ctr._id)}-singleSelectionControl"				class="radioButtonInListItem"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-radiobutton>	`; };
const block9$1 = (context) => { return html$u`<ui5-checkbox				id="${index.ifTruthy(context.ctr._id)}-multiSelectionControl"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-checkbox>	`; };
const block10$1 = (context) => { return html$u`<ui5-button				id="${index.ifTruthy(context.ctr._id)}-deleteSelectionControl"				type="Transparent"				icon="sap-icon://delete"				@press="${index.ifTruthy(context.ctr.fnOnDelete)}"		></ui5-button>	`; };
const renderMe$t = block0$t;

StandardListItemLitRenderer.render = renderMe$t;

class ListItemTemplateContext {

	static calculate(state) {

		let context = {
			ctr: state,
			classes: {
				main: ListItemTemplateContext.getMainClasses(state),
				inner: ListItemTemplateContext.getInnerClasses(state),
				image: {}
			},
			styles: {
				main: {}
			}
		};

		const mode = state._mode;

		context.placeSelectionControlBefore = mode === ListMode.MultiSelect || mode === ListMode.SingleSelectBegin;

		context.placeSelectionControlAfter = !context.placeSelectionControlBefore
			&& (mode === ListMode.SingleSelectEnd || mode === ListMode.Delete);

		context.modeSingleSelect = [ListMode.SingleSelectBegin, ListMode.SingleSelectEnd, ListMode.SingleSelect].includes(mode);
		context.modeMultiSelect = mode === ListMode.MultiSelect;
		context.modeDelete = mode === ListMode.Delete;

		return context;
	}

	static getMainClasses(state) {
		const isDesktop = Device.system.desktop;
		const isActionable = (state.type === ListItemType.Active) && (state._mode !== ListMode.Delete);
		let context = ListItemBaseTemplateContext.getMainClasses(state);

		context[`sapMLIBType${state.type}`] = true;
		context["sapMSLI"] = true;
		context["sapMLIBActionable"] = isDesktop && isActionable;
		context["sapMLIBHoverable"] = isDesktop && isActionable;
		context["sapMLIBSelected"] = state.selected;
		context["sapMLIBActive"] = state._active;

		return context;
	}

	static getInnerClasses(state) {
		return ListItemBaseTemplateContext.getInnerClasses(state);
	}
}

class StandardListItemTemplateContext {

	static calculate(state) {
		let context = ListItemTemplateContext.calculate(state);
		context.classes.main["sapMSLIIconThumb"] = !!state.imageSrc;
		context.classes.main["sapMLIBTypeNavigation"] = !!state._iconControl;
		context.classes.image["sapMSLIImg"] = true;
		return context;
	}
}

/**
 * @public
 */
const metadata$A = {
	T: StandardListItem,
	tag: "ui5-li",
	styleUrl: [
		"ListItemBase.css",
		"ListItem.css"
	],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.StandardListItem.prototype */  {

		/**
		 * Defines the icon of the <code>StandardListItem</code>.
		 * @type {string}
		 * @public
		 */
		iconSrc: {
			type: URI$1,
			defaultValue: null
		},

		/**
		 * Defines the text of the <code>StandardListItem</code>.
		 * @type {string}
		 * @public
		 */
		imageSrc: {
			type: URI$1,
			defaultValue: null
		},

		_iconControl: {
			type: Object
		}
	}
};

/**
 * @class
 * A class for a new <code>StandardListItem</code>.
 *
 * <code>StandardListItem</code> is a list item,
 * providing the most common use cases such as <code>text</code>, <code>image</code> and <code>icon</code>.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.StandardListItem
 * @public
 */
class StandardListItem$1 extends ListItem$3 {

	constructor(state) {
		super(state);
	}

	static get renderer() {
		return StandardListItemLitRenderer;
	}

	static get metadata() {
		return metadata$A;
	}

	static get calculateTemplateContext() {
		return StandardListItemTemplateContext.calculate;
	}

	onBeforeRendering() {
		ListItem$3.prototype.onBeforeRendering.call(this, arguments);
		this._updateIcon();
	}

	_updateIcon() {
		if (this.iconSrc) {
			this._iconControl = {
				_customClasses: ["sapMLIBImgNav"]
			};
			this._iconControl.src = this.iconSrc;
		}
	}
}

Core$1.boot().then(async _ => {
	await Icon$2.define();
	StandardListItem$1.define();
});

class CustomListItemTemplateContext {

	static calculate(state) {
		let calculatedState = ListItemTemplateContext.calculate(state);
		return calculatedState;
	}
}

const html$v = index.html;
const repeat$v = index.repeat;

const CustomListItemLitRenderer = {};

const block0$u = (context) => { return html$v`<li 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	tabindex="${index.ifTruthy(context.ctr._tabIndex)}"	style="${index.ifTruthy(context.styles.main)}"	class="${index.ifTruthy(context.classes.main)}">		${ context.placeSelectionControlBefore ? block1$m(context) : undefined }<div id="${index.ifTruthy(context.ctr._id)}-content" class="${index.ifTruthy(context.classes.inner)}">			${ repeat$v(context.ctr.content, undefined, (item, index$$1) => block5$6(item, index$$1, context)) }</div>		${ context.placeSelectionControlAfter ? block6$3(context) : undefined }</li>`; };
const block1$m = (context) => { return html$v`${ context.modeSingleSelect ? block2$d(context) : undefined }${ context.modeMultiSelect ? block3$9(context) : undefined }${ context.modeDelete ? block4$7(context) : undefined }`; };
const block2$d = (context) => { return html$v`<ui5-radiobutton				id="${index.ifTruthy(context.ctr._id)}-singleSelectionControl"				class="radioButtonInListItem"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-radiobutton>	`; };
const block3$9 = (context) => { return html$v`<ui5-checkbox				id="${index.ifTruthy(context.ctr._id)}-multiSelectionControl"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-checkbox>	`; };
const block4$7 = (context) => { return html$v`<ui5-button				id="${index.ifTruthy(context.ctr._id)}-deleteSelectionControl"				type="Transparent"				icon="sap-icon://delete"				@press="${index.ifTruthy(context.ctr.fnOnDelete)}"		></ui5-button>	`; };
const block5$6 = (item, index$$1, context) => { return html$v`<slot name="${index.ifTruthy(item._slot)}" />    `; };
const block6$3 = (context) => { return html$v`${ context.modeSingleSelect ? block7$3(context) : undefined }${ context.modeMultiSelect ? block8$3(context) : undefined }${ context.modeDelete ? block9$2(context) : undefined }`; };
const block7$3 = (context) => { return html$v`<ui5-radiobutton				id="${index.ifTruthy(context.ctr._id)}-singleSelectionControl"				class="radioButtonInListItem"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-radiobutton>	`; };
const block8$3 = (context) => { return html$v`<ui5-checkbox				id="${index.ifTruthy(context.ctr._id)}-multiSelectionControl"				selected="${index.ifTruthy(context.ctr.selected)}"></ui5-checkbox>	`; };
const block9$2 = (context) => { return html$v`<ui5-button				id="${index.ifTruthy(context.ctr._id)}-deleteSelectionControl"				type="Transparent"				icon="sap-icon://delete"				@press="${index.ifTruthy(context.ctr.fnOnDelete)}"		></ui5-button>	`; };
const renderMe$u = block0$u;

CustomListItemLitRenderer.render = renderMe$u;

class CustomListItem extends ListItem {}

/**
 * @public
 */
const metadata$B = {
	T: CustomListItem,
	tag: "ui5-li-custom",
	styleUrl: [
		"ListItemBase.css",
		"ListItem.css"
	],
	defaultSlot: "content",
	slots: {

		/**
		 * Defines the content of the <code>CustomListItem</code>.
		 * @type {HTMLElement}
		 * @public
		 */
		content: {
			type: HTMLElement,
			multiple: true
		}
	},
	properties: /** @lends sap.ui.webcomponents.main.CustomListItem.prototype */ {
	}
};

/**
 * @class
 *
 * A class for a new <code>CustomListItem</code>.
 *
 * <code>CustomListItem</code> has content and it can be used to customize the <code>StandardListItem</code>.
 * <code>List</code> mode and <code>ListItem</code> type are applied to <code>CustomListItem</code> as well.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.CustomListItem
 * @public
 */
class CustomListItem$1 extends ListItem$3 {

	static get metadata() {
		return metadata$B;
	}

	static get renderer() {
		return CustomListItemLitRenderer;
	}

	constructor(state) {
		super(state);
	}

	static get calculateTemplateContext() {
		return CustomListItemTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	CustomListItem$1.define();
});

const html$w = index.html;

const GroupHeaderListItemLitRenderer = {};

const block0$v = (context) => { return html$w`<li 	id="${index.ifTruthy(context.ctr._id)}"	data-sap-ui="${index.ifTruthy(context.ctr._id)}"	aria-hidden="${index.ifTruthy(context.ariaHidden)}"	tabindex="${index.ifTruthy(context.ctr._tabIndex)}"	style="${index.ifTruthy(context.styles.main)}"	class="${index.ifTruthy(context.classes.main)}"><div id="${index.ifTruthy(context.ctr._id)}-content" class="${index.ifTruthy(context.classes.inner)}"><span class="${index.ifTruthy(context.classes.span)}">${index.ifTruthy(context.ctr._nodeText)}</span></div></li>`; };
const renderMe$v = block0$v;

GroupHeaderListItemLitRenderer.render = renderMe$v;

class GroupHeaderListItemTemplateContext {

	static calculate(state) {
		return {
			ctr: state,
			classes: {
				main: GroupHeaderListItemTemplateContext.getMainClasses(state),
				inner: GroupHeaderListItemTemplateContext.getInnerClasses(state),
				span: { "sapMGHLITitle": true }
			},
			styles: {
				main: {}
			}
		};
	}

	static getMainClasses(state) {
		let context = ListItemBaseTemplateContext.getMainClasses(state);
		context["sapMGHLI"] = true;
		context["sapMLIBTypeInactive"] = true;
		return context;
	}

	static getInnerClasses(state) {
		return ListItemBaseTemplateContext.getInnerClasses(state);
	}
}

/**
 * @public
 */
const metadata$C = {
	T: ListItemBase,
	tag: "ui5-li-group-header",
	styleUrl: [
		"ListItemBase.css",
		"GroupHeaderListItem.css"
	],
	usesNodeText: true,
	properties: /** @lends  sap.ui.webcomponents.main.GroupHeaderListItem.prototype */ {
	},
	events: {
	}
};

/**
 * @class
 *  A class to represent a  <code>GroupHeaderListItem</code>.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webcomponents.main.GroupHeaderListItem
 * @public
 */
class GroupHeaderListItem$2 extends ListItemBase$3 {

	constructor(state) {
		super(state);
	}

	static get renderer() {
		return GroupHeaderListItemLitRenderer;
	}

	static get metadata() {
		return metadata$C;
	}

	static get calculateTemplateContext() {
		return GroupHeaderListItemTemplateContext.calculate;
	}
}

Core$1.boot().then(_ => {
	GroupHeaderListItem$2.define();
});

var Buddhist = UniversalDate.extend("sap.ui.core.date.Buddhist", {
  constructor: function () {
    var aArgs = arguments;
    if (aArgs.length > 1) {
      aArgs = toGregorianArguments(aArgs);
    }
    this.oDate = this.createDate(Date, aArgs);
    this.sCalendarType = CalendarType.Buddhist;
  }
});
Buddhist.UTC = function () {
  var aArgs = toGregorianArguments(arguments);
  return Date.UTC.apply(Date, aArgs);
};
Buddhist.now = function () {
  return Date.now();
};
function toBuddhist(oGregorian) {
  var iEraStartYear = UniversalDate.getEraStartDate(CalendarType.Buddhist, 0).year, iYear = oGregorian.year - iEraStartYear + 1;
  if (oGregorian.year < 1941 && oGregorian.month < 3) {
    iYear -= 1;
  }
  if (oGregorian.year === null) {
    iYear = undefined;
  }
  return {
    year: iYear,
    month: oGregorian.month,
    day: oGregorian.day
  };
}
function toGregorian(oBuddhist) {
  var iEraStartYear = UniversalDate.getEraStartDate(CalendarType.Buddhist, 0).year, iYear = oBuddhist.year + iEraStartYear - 1;
  if (iYear < 1941 && oBuddhist.month < 3) {
    iYear += 1;
  }
  if (oBuddhist.year === null) {
    iYear = undefined;
  }
  return {
    year: iYear,
    month: oBuddhist.month,
    day: oBuddhist.day
  };
}
function toGregorianArguments(aArgs) {
  var oBuddhist, oGregorian;
  oBuddhist = {
    year: aArgs[0],
    month: aArgs[1],
    day: aArgs[2] !== undefined ? aArgs[2] : 1
  };
  oGregorian = toGregorian(oBuddhist);
  aArgs[0] = oGregorian.year;
  return aArgs;
}
Buddhist.prototype._getBuddhist = function () {
  var oGregorian = {
    year: this.oDate.getFullYear(),
    month: this.oDate.getMonth(),
    day: this.oDate.getDate()
  };
  return toBuddhist(oGregorian);
};
Buddhist.prototype._setBuddhist = function (oBuddhist) {
  var oGregorian = toGregorian(oBuddhist);
  return this.oDate.setFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Buddhist.prototype._getUTCBuddhist = function () {
  var oGregorian = {
    year: this.oDate.getUTCFullYear(),
    month: this.oDate.getUTCMonth(),
    day: this.oDate.getUTCDate()
  };
  return toBuddhist(oGregorian);
};
Buddhist.prototype._setUTCBuddhist = function (oBuddhist) {
  var oGregorian = toGregorian(oBuddhist);
  return this.oDate.setUTCFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Buddhist.prototype.getYear = function () {
  return this._getBuddhist().year;
};
Buddhist.prototype.getFullYear = function () {
  return this._getBuddhist().year;
};
Buddhist.prototype.getUTCFullYear = function () {
  return this._getUTCBuddhist().year;
};
Buddhist.prototype.setYear = function (iYear) {
  var oBuddhist = this._getBuddhist();
  oBuddhist.year = iYear;
  return this._setBuddhist(oBuddhist);
};
Buddhist.prototype.setFullYear = function (iYear, iMonth, iDay) {
  var oBuddhist = this._getBuddhist();
  oBuddhist.year = iYear;
  if (iMonth !== undefined) {
    oBuddhist.month = iMonth;
  }
  if (iDay !== undefined) {
    oBuddhist.day = iDay;
  }
  return this._setBuddhist(oBuddhist);
};
Buddhist.prototype.setUTCFullYear = function (iYear, iMonth, iDay) {
  var oBuddhist = this._getUTCBuddhist();
  oBuddhist.year = iYear;
  if (iMonth !== undefined) {
    oBuddhist.month = iMonth;
  }
  if (iDay !== undefined) {
    oBuddhist.day = iDay;
  }
  return this._setUTCBuddhist(oBuddhist);
};
Buddhist.prototype.getWeek = function () {
  return UniversalDate.getWeekByDate(this.sCalendarType, this.oDate.getFullYear(), this.getMonth(), this.getDate());
};
Buddhist.prototype.getUTCWeek = function () {
  return UniversalDate.getWeekByDate(this.sCalendarType, this.oDate.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate());
};
CalendarClassRegistry.setCalendarClass(CalendarType.Buddhist, Buddhist);

var Islamic = UniversalDate.extend('sap.ui.core.date.Islamic', {
    constructor: function () {
        var aArgs = arguments;
        if (aArgs.length > 1) {
            aArgs = toGregorianArguments$1(aArgs);
        }
        this.oDate = this.createDate(Date, aArgs);
        this.sCalendarType = CalendarType.Islamic;
    }
});
Islamic.UTC = function () {
    var aArgs = toGregorianArguments$1(arguments);
    return Date.UTC.apply(Date, aArgs);
};
Islamic.now = function () {
    return Date.now();
};
var BASE_YEAR = 1400, GREGORIAN_EPOCH_DAYS = 1721425.5, ISLAMIC_EPOCH_DAYS = 1948439.5, ISLAMIC_MILLIS = -42521587200000, ONE_DAY = 86400000;
var oCustomizationMap = null;
function toIslamic(oGregorian) {
    var iGregorianYear = oGregorian.year, iGregorianMonth = oGregorian.month, iGregorianDay = oGregorian.day, iIslamicYear, iIslamicMonth, iIslamicDay, iMonths, iDays, iLeapAdj, iJulianDay;
    iLeapAdj = 0;
    if (iGregorianMonth + 1 > 2) {
        iLeapAdj = isGregorianLeapYear(iGregorianYear) ? -1 : -2;
    }
    iJulianDay = GREGORIAN_EPOCH_DAYS - 1 + 365 * (iGregorianYear - 1) + Math.floor((iGregorianYear - 1) / 4) + -Math.floor((iGregorianYear - 1) / 100) + Math.floor((iGregorianYear - 1) / 400) + Math.floor((367 * (iGregorianMonth + 1) - 362) / 12 + iLeapAdj + iGregorianDay);
    iJulianDay = Math.floor(iJulianDay) + 0.5;
    iDays = iJulianDay - ISLAMIC_EPOCH_DAYS;
    iMonths = Math.floor(iDays / 29.530588853);
    if (iMonths < 0) {
        iIslamicYear = Math.floor(iMonths / 12) + 1;
        iIslamicMonth = iMonths % 12;
        if (iIslamicMonth < 0) {
            iIslamicMonth += 12;
        }
        iIslamicDay = iDays - monthStart(iIslamicYear, iIslamicMonth) + 1;
    } else {
        iMonths++;
        while (getCustomMonthStartDays(iMonths) > iDays) {
            iMonths--;
        }
        iIslamicYear = Math.floor(iMonths / 12) + 1;
        iIslamicMonth = iMonths % 12;
        iIslamicDay = iDays - getCustomMonthStartDays(12 * (iIslamicYear - 1) + iIslamicMonth) + 1;
    }
    return {
        day: iIslamicDay,
        month: iIslamicMonth,
        year: iIslamicYear
    };
}
function toGregorian$1(oIslamic) {
    var iIslamicYear = oIslamic.year, iIslamicMonth = oIslamic.month, iIslamicDate = oIslamic.day, iMonthStart = iIslamicYear < 1 ? monthStart(iIslamicYear, iIslamicMonth) : getCustomMonthStartDays(12 * (iIslamicYear - 1) + iIslamicMonth), iJulianDay = iIslamicDate + iMonthStart + ISLAMIC_EPOCH_DAYS - 1, iJulianDayNoon = Math.floor(iJulianDay - 0.5) + 0.5, iDaysSinceGregorianEpoch = iJulianDayNoon - GREGORIAN_EPOCH_DAYS, iQuadricent = Math.floor(iDaysSinceGregorianEpoch / 146097), iQuadricentNormalized = mod(iDaysSinceGregorianEpoch, 146097), iCent = Math.floor(iQuadricentNormalized / 36524), iCentNormalized = mod(iQuadricentNormalized, 36524), iQuad = Math.floor(iCentNormalized / 1461), iQuadNormalized = mod(iCentNormalized, 1461), iYearIndex = Math.floor(iQuadNormalized / 365), iYear = iQuadricent * 400 + iCent * 100 + iQuad * 4 + iYearIndex, iMonth, iDay, iGregorianYearStartDays, iDayOfYear, tjd, tjd2, iLeapAdj, iLeapAdj2;
    if (!(iCent == 4 || iYearIndex == 4)) {
        iYear++;
    }
    iGregorianYearStartDays = GREGORIAN_EPOCH_DAYS + 365 * (iYear - 1) + Math.floor((iYear - 1) / 4) - Math.floor((iYear - 1) / 100) + Math.floor((iYear - 1) / 400);
    iDayOfYear = iJulianDayNoon - iGregorianYearStartDays;
    tjd = GREGORIAN_EPOCH_DAYS - 1 + 365 * (iYear - 1) + Math.floor((iYear - 1) / 4) - Math.floor((iYear - 1) / 100) + Math.floor((iYear - 1) / 400) + Math.floor(739 / 12 + (isGregorianLeapYear(iYear) ? -1 : -2) + 1);
    iLeapAdj = 0;
    if (iJulianDayNoon < tjd) {
        iLeapAdj = 0;
    } else {
        iLeapAdj = isGregorianLeapYear(iYear) ? 1 : 2;
    }
    iMonth = Math.floor(((iDayOfYear + iLeapAdj) * 12 + 373) / 367);
    tjd2 = GREGORIAN_EPOCH_DAYS - 1 + 365 * (iYear - 1) + Math.floor((iYear - 1) / 4) - Math.floor((iYear - 1) / 100) + Math.floor((iYear - 1) / 400);
    iLeapAdj2 = 0;
    if (iMonth > 2) {
        iLeapAdj2 = isGregorianLeapYear(iYear) ? -1 : -2;
    }
    tjd2 += Math.floor((367 * iMonth - 362) / 12 + iLeapAdj2 + 1);
    iDay = iJulianDayNoon - tjd2 + 1;
    return {
        day: iDay,
        month: iMonth - 1,
        year: iYear
    };
}
function toGregorianArguments$1(aArgs) {
    var aGregorianArgs = Array.prototype.slice.call(aArgs), oIslamic, oGregorian;
    oIslamic = {
        year: aArgs[0],
        month: aArgs[1],
        day: aArgs[2] !== undefined ? aArgs[2] : 1
    };
    oGregorian = toGregorian$1(oIslamic);
    aGregorianArgs[0] = oGregorian.year;
    aGregorianArgs[1] = oGregorian.month;
    aGregorianArgs[2] = oGregorian.day;
    return aGregorianArgs;
}
function initCustomizationMap() {
    var sDateFormat, oCustomizationJSON;
    oCustomizationMap = {};
    sDateFormat = sap.ui.getCore().getConfiguration().getFormatSettings().getLegacyDateFormat();
    oCustomizationJSON = sap.ui.getCore().getConfiguration().getFormatSettings().getLegacyDateCalendarCustomizing();
    oCustomizationJSON = oCustomizationJSON || [];
    if (!sDateFormat && !oCustomizationJSON.length) {
        Log.info('No calendar customizations.');
        return;
    }
    if (sDateFormat && !oCustomizationJSON.length || !sDateFormat && oCustomizationJSON.length) {
        Log.warning('There is an inconsistency between customization data [' + JSON.stringify(oCustomizationJSON) + '] and the date format [' + sDateFormat + ']. Calendar customization won\'t be used.');
        return;
    }
    oCustomizationJSON.forEach(function (oEntry) {
        if (oEntry.dateFormat === sDateFormat) {
            var date = parseDate(oEntry.gregDate);
            var iGregorianDate = new Date(Date.UTC(date.year, date.month - 1, date.day));
            var iMillis = iGregorianDate.getTime();
            var iIslamicMonthStartDays = (iMillis - ISLAMIC_MILLIS) / ONE_DAY;
            date = parseDate(oEntry.islamicMonthStart);
            var iIslamicMonths = (date.year - 1) * 12 + date.month - 1;
            oCustomizationMap[iIslamicMonths] = iIslamicMonthStartDays;
        }
    });
    Log.info('Working with date format: [' + sDateFormat + '] and customization: ' + JSON.stringify(oCustomizationJSON));
}
function parseDate(sDate) {
    return {
        year: parseInt(sDate.substr(0, 4)),
        month: parseInt(sDate.substr(4, 2)),
        day: parseInt(sDate.substr(6, 2))
    };
}
function getCustomMonthStartDays(months) {
    if (!oCustomizationMap) {
        initCustomizationMap();
    }
    var iIslamicMonthStartDays = oCustomizationMap[months];
    if (!iIslamicMonthStartDays) {
        var year = Math.floor(months / 12) + 1;
        var month = months % 12;
        iIslamicMonthStartDays = monthStart(year, month);
    }
    return iIslamicMonthStartDays;
}
function monthStart(year, month) {
    return Math.ceil(29.5 * month) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30);
}
function mod(a, b) {
    return a - b * Math.floor(a / b);
}
function isGregorianLeapYear(iYear) {
    return !(iYear % 400) || !(iYear % 4) && !!(iYear % 100);
}
Islamic.prototype._getIslamic = function () {
    return toIslamic({
        day: this.oDate.getDate(),
        month: this.oDate.getMonth(),
        year: this.oDate.getFullYear()
    });
};
Islamic.prototype._setIslamic = function (oIslamic) {
    var oGregorian = toGregorian$1(oIslamic);
    return this.oDate.setFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Islamic.prototype._getUTCIslamic = function () {
    return toIslamic({
        day: this.oDate.getUTCDate(),
        month: this.oDate.getUTCMonth(),
        year: this.oDate.getUTCFullYear()
    });
};
Islamic.prototype._setUTCIslamic = function (oIslamic) {
    var oGregorian = toGregorian$1(oIslamic);
    return this.oDate.setUTCFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Islamic.prototype.getDate = function (iDate) {
    return this._getIslamic().day;
};
Islamic.prototype.getMonth = function () {
    return this._getIslamic().month;
};
Islamic.prototype.getYear = function () {
    return this._getIslamic().year - BASE_YEAR;
};
Islamic.prototype.getFullYear = function () {
    return this._getIslamic().year;
};
Islamic.prototype.setDate = function (iDate) {
    var oIslamic = this._getIslamic();
    oIslamic.day = iDate;
    return this._setIslamic(oIslamic);
};
Islamic.prototype.setMonth = function (iMonth, iDay) {
    var oIslamic = this._getIslamic();
    oIslamic.month = iMonth;
    if (iDay !== undefined) {
        oIslamic.day = iDay;
    }
    return this._setIslamic(oIslamic);
};
Islamic.prototype.setYear = function (iYear) {
    var oIslamic = this._getIslamic();
    oIslamic.year = iYear + BASE_YEAR;
    return this._setIslamic(oIslamic);
};
Islamic.prototype.setFullYear = function (iYear, iMonth, iDay) {
    var oIslamic = this._getIslamic();
    oIslamic.year = iYear;
    if (iMonth !== undefined) {
        oIslamic.month = iMonth;
    }
    if (iDay !== undefined) {
        oIslamic.day = iDay;
    }
    return this._setIslamic(oIslamic);
};
Islamic.prototype.getUTCDate = function (iDate) {
    return this._getUTCIslamic().day;
};
Islamic.prototype.getUTCMonth = function () {
    return this._getUTCIslamic().month;
};
Islamic.prototype.getUTCFullYear = function () {
    return this._getUTCIslamic().year;
};
Islamic.prototype.setUTCDate = function (iDate) {
    var oIslamic = this._getUTCIslamic();
    oIslamic.day = iDate;
    return this._setUTCIslamic(oIslamic);
};
Islamic.prototype.setUTCMonth = function (iMonth, iDay) {
    var oIslamic = this._getUTCIslamic();
    oIslamic.month = iMonth;
    if (iDay !== undefined) {
        oIslamic.day = iDay;
    }
    return this._setUTCIslamic(oIslamic);
};
Islamic.prototype.setUTCFullYear = function (iYear, iMonth, iDay) {
    var oIslamic = this._getUTCIslamic();
    oIslamic.year = iYear;
    if (iMonth !== undefined) {
        oIslamic.month = iMonth;
    }
    if (iDay !== undefined) {
        oIslamic.day = iDay;
    }
    return this._setUTCIslamic(oIslamic);
};
CalendarClassRegistry.setCalendarClass(CalendarType.Islamic, Islamic);

var Japanese = UniversalDate.extend("sap.ui.core.date.Japanese", {
  constructor: function () {
    var aArgs = arguments;
    if (aArgs.length > 1) {
      aArgs = toGregorianArguments$2(aArgs);
    }
    this.oDate = this.createDate(Date, aArgs);
    this.sCalendarType = CalendarType.Japanese;
  }
});
Japanese.UTC = function () {
  var aArgs = toGregorianArguments$2(arguments);
  return Date.UTC.apply(Date, aArgs);
};
Japanese.now = function () {
  return Date.now();
};
function toJapanese(oGregorian) {
  var iEra = UniversalDate.getEraByDate(CalendarType.Japanese, oGregorian.year, oGregorian.month, oGregorian.day), iEraStartYear = UniversalDate.getEraStartDate(CalendarType.Japanese, iEra).year;
  return {
    era: iEra,
    year: oGregorian.year - iEraStartYear + 1,
    month: oGregorian.month,
    day: oGregorian.day
  };
}
function toGregorian$2(oJapanese) {
  var iEraStartYear = UniversalDate.getEraStartDate(CalendarType.Japanese, oJapanese.era).year;
  return {
    year: iEraStartYear + oJapanese.year - 1,
    month: oJapanese.month,
    day: oJapanese.day
  };
}
function toGregorianArguments$2(aArgs) {
  var oJapanese, oGregorian, iEra, vYear = aArgs[0];
  if (typeof vYear == "number") {
    if (vYear >= 100) {
      return aArgs;
    } else {
      iEra = UniversalDate.getCurrentEra(CalendarType.Japanese);
      vYear = [iEra, vYear];
    }
  } else if (!Array.isArray(vYear)) {
    vYear = [];
  }
  oJapanese = {
    era: vYear[0],
    year: vYear[1],
    month: aArgs[1],
    day: aArgs[2] !== undefined ? aArgs[2] : 1
  };
  oGregorian = toGregorian$2(oJapanese);
  aArgs[0] = oGregorian.year;
  return aArgs;
}
Japanese.prototype._getJapanese = function () {
  var oGregorian = {
    year: this.oDate.getFullYear(),
    month: this.oDate.getMonth(),
    day: this.oDate.getDate()
  };
  return toJapanese(oGregorian);
};
Japanese.prototype._setJapanese = function (oJapanese) {
  var oGregorian = toGregorian$2(oJapanese);
  return this.oDate.setFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Japanese.prototype._getUTCJapanese = function () {
  var oGregorian = {
    year: this.oDate.getUTCFullYear(),
    month: this.oDate.getUTCMonth(),
    day: this.oDate.getUTCDate()
  };
  return toJapanese(oGregorian);
};
Japanese.prototype._setUTCJapanese = function (oJapanese) {
  var oGregorian = toGregorian$2(oJapanese);
  return this.oDate.setUTCFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Japanese.prototype.getYear = function () {
  return this._getJapanese().year;
};
Japanese.prototype.getFullYear = function () {
  return this._getJapanese().year;
};
Japanese.prototype.getEra = function () {
  return this._getJapanese().era;
};
Japanese.prototype.getUTCFullYear = function () {
  return this._getUTCJapanese().year;
};
Japanese.prototype.getUTCEra = function () {
  return this._getUTCJapanese().era;
};
Japanese.prototype.setYear = function (iYear) {
  var oJapanese = this._getJapanese();
  oJapanese.year = iYear;
  return this._setJapanese(oJapanese);
};
Japanese.prototype.setFullYear = function (iYear, iMonth, iDay) {
  var oJapanese = this._getJapanese();
  oJapanese.year = iYear;
  if (iMonth !== undefined) {
    oJapanese.month = iMonth;
  }
  if (iDay !== undefined) {
    oJapanese.day = iDay;
  }
  return this._setJapanese(oJapanese);
};
Japanese.prototype.setEra = function (iEra, iYear, iMonth, iDay) {
  var oEraStartDate = UniversalDate.getEraStartDate(CalendarType.Japanese, iEra), oJapanese = toJapanese(oEraStartDate);
  if (iYear !== undefined) {
    oJapanese.year = iYear;
  }
  if (iMonth !== undefined) {
    oJapanese.month = iMonth;
  }
  if (iDay !== undefined) {
    oJapanese.day = iDay;
  }
  return this._setJapanese(oJapanese);
};
Japanese.prototype.setUTCFullYear = function (iYear, iMonth, iDay) {
  var oJapanese = this._getUTCJapanese();
  oJapanese.year = iYear;
  if (iMonth !== undefined) {
    oJapanese.month = iMonth;
  }
  if (iDay !== undefined) {
    oJapanese.day = iDay;
  }
  return this._setUTCJapanese(oJapanese);
};
Japanese.prototype.setUTCEra = function (iEra, iYear, iMonth, iDay) {
  var oEraStartDate = UniversalDate.getEraStartDate(CalendarType.Japanese, iEra), oJapanese = toJapanese(oEraStartDate);
  if (iYear !== undefined) {
    oJapanese.year = iYear;
  }
  if (iMonth !== undefined) {
    oJapanese.month = iMonth;
  }
  if (iDay !== undefined) {
    oJapanese.day = iDay;
  }
  return this._setUTCJapanese(oJapanese);
};
Japanese.prototype.getWeek = function () {
  return UniversalDate.getWeekByDate(this.sCalendarType, this.oDate.getFullYear(), this.getMonth(), this.getDate());
};
Japanese.prototype.getUTCWeek = function () {
  return UniversalDate.getWeekByDate(this.sCalendarType, this.oDate.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate());
};
CalendarClassRegistry.setCalendarClass(CalendarType.Japanese, Japanese);

var Persian = UniversalDate.extend("sap.ui.core.date.Persian", {
  constructor: function () {
    var aArgs = arguments;
    if (aArgs.length > 1) {
      aArgs = toGregorianArguments$3(aArgs);
    }
    this.oDate = this.createDate(Date, aArgs);
    this.sCalendarType = CalendarType.Persian;
  }
});
Persian.UTC = function () {
  var aArgs = toGregorianArguments$3(arguments);
  return Date.UTC.apply(Date, aArgs);
};
Persian.now = function () {
  return Date.now();
};
var BASE_YEAR$1 = 1300;
function toPersian(oGregorian) {
  var iJulianDayNumber = g2d(oGregorian.year, oGregorian.month + 1, oGregorian.day);
  return d2j(iJulianDayNumber);
}
function toGregorian$3(oPersian) {
  var iJulianDayNumber = j2d(oPersian.year, oPersian.month + 1, oPersian.day);
  return d2g(iJulianDayNumber);
}
function toGregorianArguments$3(aArgs) {
  var aGregorianArgs = Array.prototype.slice.call(aArgs), oPersian, oGregorian;
  if (typeof aArgs[0] !== "number" || typeof aArgs[1] !== "number" || aArgs[2] !== undefined && typeof aArgs[2] != "number") {
    aGregorianArgs[0] = NaN;
    aGregorianArgs[1] = NaN;
    aGregorianArgs[2] = NaN;
    return aGregorianArgs;
  }
  oPersian = {
    year: aArgs[0],
    month: aArgs[1],
    day: aArgs[2] !== undefined ? aArgs[2] : 1
  };
  oGregorian = toGregorian$3(oPersian);
  aGregorianArgs[0] = oGregorian.year;
  aGregorianArgs[1] = oGregorian.month;
  aGregorianArgs[2] = oGregorian.day;
  return aGregorianArgs;
}
function jalCal(jy) {
  var breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178], bl = breaks.length, gy = jy + 621, leapJ = -14, jp = breaks[0], jm, jump, leap, leapG, march, n, i;
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm) {
      break;
    }
    leapJ = leapJ + div(jump, 33) * 8 + div(mod$1(jump, 33), 4);
    jp = jm;
  }
  n = jy - jp;
  leapJ = leapJ + div(n, 33) * 8 + div(mod$1(n, 33) + 3, 4);
  if (mod$1(jump, 33) === 4 && jump - n === 4) {
    leapJ += 1;
  }
  leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;
  march = 20 + leapJ - leapG;
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }
  leap = mod$1(mod$1(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }
  return {
    leap: leap,
    gy: gy,
    march: march
  };
}
function j2d(jy, jm, jd) {
  while (jm < 1) {
    jm += 12;
    jy--;
  }
  while (jm > 12) {
    jm -= 12;
    jy++;
  }
  var r = jalCal(jy);
  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}
function d2j(jdn) {
  var gy = d2g(jdn).year, jy = gy - 621, r = jalCal(jy), jdn1f = g2d(gy, 3, r.march), jd, jm, k;
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      jm = 1 + div(k, 31);
      jd = mod$1(k, 31) + 1;
      return {
        year: jy,
        month: jm - 1,
        day: jd
      };
    } else {
      k -= 186;
    }
  } else {
    jy -= 1;
    k += 179;
    if (r.leap === 1) {
      k += 1;
    }
  }
  jm = 7 + div(k, 30);
  jd = mod$1(k, 30) + 1;
  return {
    year: jy,
    month: jm - 1,
    day: jd
  };
}
function g2d(gy, gm, gd) {
  var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod$1(gm + 9, 12) + 2, 5) + gd - 34840408;
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}
function d2g(jdn) {
  var j, i, gd, gm, gy;
  j = 4 * jdn + 139361631;
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  i = div(mod$1(j, 1461), 4) * 5 + 308;
  gd = div(mod$1(i, 153), 5) + 1;
  gm = mod$1(div(i, 153), 12) + 1;
  gy = div(j, 1461) - 100100 + div(8 - gm, 6);
  return {
    year: gy,
    month: gm - 1,
    day: gd
  };
}
function div(a, b) {
  return ~~(a / b);
}
function mod$1(a, b) {
  return a - ~~(a / b) * b;
}
Persian.prototype._getPersian = function () {
  return toPersian({
    day: this.oDate.getDate(),
    month: this.oDate.getMonth(),
    year: this.oDate.getFullYear()
  });
};
Persian.prototype._setPersian = function (oPersian) {
  var oGregorian = toGregorian$3(oPersian);
  return this.oDate.setFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Persian.prototype._getUTCPersian = function () {
  return toPersian({
    day: this.oDate.getUTCDate(),
    month: this.oDate.getUTCMonth(),
    year: this.oDate.getUTCFullYear()
  });
};
Persian.prototype._setUTCPersian = function (oPersian) {
  var oGregorian = toGregorian$3(oPersian);
  return this.oDate.setUTCFullYear(oGregorian.year, oGregorian.month, oGregorian.day);
};
Persian.prototype.getDate = function (iDate) {
  return this._getPersian().day;
};
Persian.prototype.getMonth = function () {
  return this._getPersian().month;
};
Persian.prototype.getYear = function () {
  return this._getPersian().year - BASE_YEAR$1;
};
Persian.prototype.getFullYear = function () {
  return this._getPersian().year;
};
Persian.prototype.setDate = function (iDate) {
  var oPersian = this._getPersian();
  oPersian.day = iDate;
  return this._setPersian(oPersian);
};
Persian.prototype.setMonth = function (iMonth, iDay) {
  var oPersian = this._getPersian();
  oPersian.month = iMonth;
  if (iDay !== undefined) {
    oPersian.day = iDay;
  }
  return this._setPersian(oPersian);
};
Persian.prototype.setYear = function (iYear) {
  var oPersian = this._getPersian();
  oPersian.year = iYear + BASE_YEAR$1;
  return this._setPersian(oPersian);
};
Persian.prototype.setFullYear = function (iYear, iMonth, iDay) {
  var oPersian = this._getPersian();
  oPersian.year = iYear;
  if (iMonth !== undefined) {
    oPersian.month = iMonth;
  }
  if (iDay !== undefined) {
    oPersian.day = iDay;
  }
  return this._setPersian(oPersian);
};
Persian.prototype.getUTCDate = function (iDate) {
  return this._getUTCPersian().day;
};
Persian.prototype.getUTCMonth = function () {
  return this._getUTCPersian().month;
};
Persian.prototype.getUTCFullYear = function () {
  return this._getUTCPersian().year;
};
Persian.prototype.setUTCDate = function (iDate) {
  var oPersian = this._getUTCPersian();
  oPersian.day = iDate;
  return this._setUTCPersian(oPersian);
};
Persian.prototype.setUTCMonth = function (iMonth, iDay) {
  var oPersian = this._getUTCPersian();
  oPersian.month = iMonth;
  if (iDay !== undefined) {
    oPersian.day = iDay;
  }
  return this._setUTCPersian(oPersian);
};
Persian.prototype.setUTCFullYear = function (iYear, iMonth, iDay) {
  var oPersian = this._getUTCPersian();
  oPersian.year = iYear;
  if (iMonth !== undefined) {
    oPersian.month = iMonth;
  }
  if (iDay !== undefined) {
    oPersian.day = iDay;
  }
  return this._setUTCPersian(oPersian);
};
CalendarClassRegistry.setCalendarClass(CalendarType.Persian, Persian);

/* eslint no-unused-vars: 0 */
window.RenderScheduler = RenderScheduler;
//# sourceMappingURL=bundle.esm.js.map
